# WARNING: Do not edit this file. It is generated from a template and will be overwritten!
from __future__ import annotations
from pysmo.lib.exceptions import SacHeaderUndefined
from pysmo.lib.functions import _azdist
from pysmo.lib.defaults import SACIO_DEFAULTS
try:
    from typing import Any, Self  # py311+
except ImportError:
    from typing import Any
    from typing_extensions import Self  # py310
from attrs import define, field, validators, Attribute, converters
from attrs_strict import type_validator
from enum import Enum
import struct
import datetime
import io
import requests
import urllib.parse
import zipfile
import warnings
import numpy as np


@define(frozen=True)
class HeaderType:
    definition: str
    undefined: float | int | str | bool
    length: int
    format: str
    description: str | None = None


HEADER_TYPES = dict(
    {%- for type, values in header_types.items() %}
    {{ type}}=HeaderType(definition='{{ values.definition }}', undefined={{ values.undefined }}, length={{ values.length }}, format='{{ values.format }}'),
    {%- endfor %}
)


@define(frozen=True)
class Header:
    start: int
    length: int
    format: str
    type: str


SAC_HEADERS = dict(
    {%- for header, values in headers.items() %}
    {{ header }}=Header(start={{ values.start }}, length={{ values.length }}, format='{{ values.format }}', type='{{ values.header_type }}'),
    {%- endfor %}
)


class SacEnum(Enum):
{%- for k, v in enum_dict.items() %}
    {{ k }} = {{ v }}{% if k == 'l' %}  # NOQA: E741 {% endif %}
{%- endfor %}


ENUM_DICT = dict(
    {%- for header, values in headers.items() %}
    {%- if values.allowed_vals is defined %}
    {{ header }}=[
      {%- for key in values.allowed_vals.keys() %}
      '{{ key }}',
      {%- endfor %}
    ],
    {%- endif %}
    {%- endfor %}
)

def validate_sacenum(instance: SacIO, attribute: Attribute, value: Any) -> None:
    if not hasattr(SacEnum, value):
        raise ValueError(f"{value=} is not a known sac enum.")
    valid_values_list = ENUM_DICT[attribute.name]
    if value not in valid_values_list:
        raise ValueError(f"{value=} is not valid for {attribute=}." +
                         f"valid attributes are {valid_values_list}")

@define(kw_only=True)
class SacIO:
    """
    The `SacIO` class reads and writes data and header values to and from a
    SAC file. Instances of `SacIO` provide attributes named identially to
    header names in the SAC file format. Additonal attributes may be set, but are
    not written to a SAC file (because there is no space reserved for them there).
    Class attributes with corresponding header fields in a SAC file (for example the
    begin time `b`) are checked for a valid format before being saved in the
    `SacIO` instance.

    Warning:
        This class should typically never be used directly. Instead please
        use the [SAC][pysmo.classes.sac.SAC] class, which inherits all
        attributes and methods from here.

    Examples:
        Create a new instance from a file and print seismogram data:

        >>> from pysmo.lib.io import SacIO
        >>> my_sac = SacIO.from_file('testfile.sac')
        >>> data = my_sac.data
        >>> data
        array([-1616.0, -1609.0, -1568.0, -1606.0, -1615.0, -1565.0, ...

        Read the sampling rate:

        >>> delta = my_sac.delta
        >>> delta
        0.019999999552965164

        Change the sampling rate:

        >>> newdelta = 0.05
        >>> my_sac.delta = newdelta
        >>> my_sac.delta
        0.05

        Create a new instance from IRIS services:

        >>> from pysmo.lib.io import SacIO
        >>> my_sac = SacIO.from_iris(
        >>>             net="C1",
        >>>             sta="VA01",
        >>>             cha="BHZ",
        >>>             loc="--",
        >>>             start="2021-03-22T13:00:00",
        >>>             duration=1 * 60 * 60,
        >>>             scale="AUTO",
        >>>             demean="true",
        >>>             force_single_result=True)
        >>> my_sac.npts
        144001

    For each SAC(file) header field there is a corresponding attribute in this class.
    There are a lot of header fields in a SAC file, which are all called the
    same way when using `SAC`.

    Attributes:
    {%- for header, header_dict in headers.items() %}
        {{ header }}:
            {{ header_dict.description | wordwrap(70) | indent(12) -}}
    {% endfor %}
    """
    {%- for header, header_dict in headers.items() -%}
    {%- if header not in properties %}
    {{ header }}: {{ header_dict.python_type+ " "-}}

    {%- if sacio_defaults[header] is defined -%}
     = field(default=SACIO_DEFAULTS.{{ header}}
    {%- if header_dict.python_type in ['float'] -%}
    , converter={{ header_dict.python_type }}
    {%- endif -%}
    {%- else -%}
     | None = field(default=None
    {%- if header_dict.python_type in ['float'] -%}
    , converter=converters.optional({{ header_dict.python_type }})
    {%- endif -%}
    {%- endif -%}


    {%- if validators[header] is defined -%}
     , validator={{ validators[header] }})
    {%- elif sacio_defaults[header] is defined -%}
     , validator=[type_validator()
     {%- if header_dict.python_type == 'str' -%}, validators.max_len({{ header_dict.length }}){%- endif -%}])
    {%- else -%}
     , validator=validators.optional([type_validator()
     {%- if header_dict.python_type == 'str' -%}, validators.max_len({{ header_dict.length }}){%- endif -%}]))
    {%- endif -%}
    {%- endif -%}
    {%- endfor %}
    data: np.ndarray = field(factory=lambda: np.array([]))
    x: np.ndarray = field(factory=lambda: np.array([]))
    y: np.ndarray = field(factory=lambda: np.array([]))

    @property
    def depmin(self) -> float | None:
        if self.npts == 0:
            return None
        return np.min(self.data)

    @property
    def depmax(self) -> float | None:
        if self.npts == 0:
            return None
        return np.max(self.data)

    @property
    def depmen(self) -> float | None:
        if self.npts == 0:
            return None
        return np.mean(self.data)

    @property
    def e(self) -> float:
        if self.npts == 0:
            return self.b
        return self.b + (self.npts - 1) * self.delta

    @property
    def dist(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return _azdist(lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo)[2] / 1000
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def az(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return _azdist(lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo)[0]
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def baz(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return _azdist(lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo)[1]
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def gcarc(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            lat1, lon1 = np.deg2rad(self.stla), np.deg2rad(self.stlo)
            lat2, lon2 = np.deg2rad(self.evla), np.deg2rad(self.evlo)
            return np.rad2deg(np.arccos(np.sin(lat1) * np.sin(lat2) + np.cos(lat1)
                              * np.cos(lat2) * np.cos(np.abs(lon1 - lon2))))
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def xminimum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return float(np.min(self.x))

    @property
    def xmaximum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return np.max(self.x)

    @property
    def yminimum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.min(self.y)

    @property
    def ymaximum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.max(self.y)

    @property
    def npts(self) -> int:
        return np.size(self.data)

    @property
    def nxsize(self) -> float | None:
        if np.size(self.x) == 0:
            return None
        return np.size(self.x)

    @property
    def nysize(self) -> float | None:
        if np.size(self.y) == 0:
            return None
        return np.size(self.y)

    @property
    def lcalda(self) -> bool:
        # all distances and bearings are always calculated...
        return True

    @property
    def kzdate(self) -> str | None:
        """
        Returns:
            ISO 8601 format of GMT reference date.
        """
        if self.nzyear is None or self.nzjday is None:
            return None
        _kzdate = datetime.date(self.nzyear, 1, 1) + datetime.timedelta(self.nzjday - 1)
        return _kzdate.isoformat()

    @property
    def kztime(self) -> str | None:
        """
        Returns:
            Alphanumeric form of GMT reference time.
        """
        if self.nzhour is None or self.nzmin is None or self.nzsec is None or self.nzmsec is None:
            return None
        _kztime = datetime.time(self.nzhour, self.nzmin, self.nzsec, self.nzmsec * 1000)
        return _kztime.isoformat(timespec='milliseconds')

    def read(self, filename: str) -> None:
        """Read data and header values from a SAC file into an existing SAC instance.

        Parameters:
            filename: Name of the sac file to read.
        """

        with open(filename, 'rb') as file_handle:
            self.read_buffer(file_handle.read())

    def read_buffer(self, buffer: bytes) -> None:
        """Read data and header values from a SAC byte buffer into an existing SAC instance.

        Parameters:
            buffer: Buffer containing SAC file content.
        """

        if len(buffer) < 632:
            raise EOFError()

        # Guess the file endianness first using the unused12 header field.
        # It is located at position 276 and its value should be -12345.0.
        # Try reading with little endianness
        if struct.unpack('<f', buffer[276:280])[-1] == -12345.0:
            file_byteorder = '<'
        # otherwise assume big endianness.
        else:
            file_byteorder = '>'

        # Loop over all header fields and store them in the SAC object under their
        # respective private names.
        npts = 0
        for header, metadata in SAC_HEADERS.items():
            header_type = metadata.type
            header_undefined = HEADER_TYPES[header_type].undefined
            start = metadata.start
            length = metadata.length
            end = start + length
            if end >= len(buffer):
                continue
            content = buffer[start:end]
            value = struct.unpack(file_byteorder + metadata.format, content)[0]
            if isinstance(value, bytes):
                # strip spaces and "\x00" chars
                value = value.decode().rstrip(" \x00")

            # npts is read only property in this class, but is needed for reading data
            if header == "npts":
                npts = int(value)

            # skip if undefined (value == -12345...)
            if value == header_undefined:
                continue

            # convert enumerated header to string and format others
            if header_type == "i":
                value = SacEnum(value).name

            # SAC file has headers fields which are read only attributes in this
            # class. We skip them with this try/except.
            # TODO: This is a bit crude, should maybe be a bit more specific.
            try:
                setattr(self, header, value)
            except AttributeError as e:
                if "object has no setter" in str(e):
                    pass

        # Only accept IFTYPE = ITIME SAC files. Other IFTYPE use two data blocks, which is something
        # we don't support.
        if self.iftype.lower() != 'time':
            raise NotImplementedError(f"Reading SAC files with IFTYPE=(I){self.iftype.upper()} is not supported.")

        # Read first data block
        start = 632
        length = npts * 4
        self.data = np.array([])
        if length > 0:
            end = start + length
            data_format = file_byteorder + str(npts) + 'f'
            if end > len(buffer):
                raise EOFError()
            content = buffer[start:end]
            data = struct.unpack(data_format, content)
            self.data = np.array(data)

        # TODO: implement reading and writing footer with double precision values.
        # Warn users for now that footer is not read in case of SAC header version 7.
        if self.nvhdr == 7:
            warnings.warn(f"SAC header version {self.nvhdr} not implemented. Reverting to version 6")
            self.nvhdr = 6

    @classmethod
    def from_file(cls, filename: str) -> Self:
        """Create a new SAC instance from a SAC file.

        Parameters:
            filename: Name of the SAC file to read.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read(filename)
        return newinstance

    @classmethod
    def from_buffer(cls, buffer: bytes) -> Self:
        """Create a new SAC instance from a SAC data buffer.

        Parameters:
            buffer: Buffer containing SAC file content.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read_buffer(buffer)
        return newinstance

    @classmethod
    def from_iris(cls, net: str, sta: str, cha: str, loc: str, force_single_result: bool = False,
                  **kwargs: Any) -> Self | dict[str, Self] | None:
        """Create a list of SAC instances from a single IRIS
        request using the output format as "sac.zip".

        Parameters:
            force_single_result: If true, the function will return a single SAC
                                 object or None if the requests returns nothing.

        Returns:
            A new SacIO instance.
        """
        kwargs["net"] = net
        kwargs["sta"] = sta
        kwargs["cha"] = cha
        kwargs["loc"] = loc
        kwargs["output"] = "sac.zip"

        if isinstance(kwargs["start"], datetime.datetime):
            kwargs["start"] = kwargs["start"].isoformat()

        end = kwargs.get("end", None)
        if end is not None and isinstance(end, datetime.datetime):
            kwargs["end"] = end.isoformat()

        base = "https://service.iris.edu/irisws/timeseries/1/query"
        params = urllib.parse.urlencode(kwargs, doseq=False)
        url = f"{base}?{params}"
        response = requests.get(url)
        if not response:
            raise ValueError(response.content.decode("utf-8"))
        zip = zipfile.ZipFile(io.BytesIO(response.content))
        result = {}
        for name in zip.namelist():
            buffer = zip.read(name)
            sac = cls.from_buffer(buffer)
            if force_single_result:
                return sac
            result[name] = sac
        return None if force_single_result else result

    def write(self, filename: str) -> None:
        """Writes data and header values to a SAC file.

        Parameters:
            filename: Name of the sacfile to write to.
        """
        with open(filename, 'wb') as file_handle:
            # loop over all valid header fields and write them to the file
            for header, metadata in SAC_HEADERS.items():
                header_type = metadata.type
                header_format = metadata.format
                start = metadata.start
                header_undefined = HEADER_TYPES[header_type].undefined

                value = None
                try:
                    value = getattr(self, header)
                except SacHeaderUndefined:
                    value = None

                # convert enumerated header to integer if it is not None
                if header_type == "i" and value:
                    value = SacEnum[value].value

                # set None to -12345
                if not value:
                    value = header_undefined

                # Encode strings to bytes
                if isinstance(value, str):
                    value = value.encode()

                # write to file
                file_handle.seek(start)
                file_handle.write(struct.pack(header_format, value))

            # write data (if npts > 0)
            start1 = 632
            file_handle.truncate(start1)
            if self.npts > 0:
                file_handle.seek(start1)
                for x in self.data:
                    file_handle.write(struct.pack('f', x))
