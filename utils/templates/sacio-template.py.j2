# WARNING: Do not edit this file!
# It is generated by running the script 'generate_sacio.py' using values from
# 'sacheader.yml' and the 'sacio-template.py.j2' file. These 3 files are found
# in the utils directory.
from pysmo import MiniLocation
from pysmo.tools.azdist import azimuth, backazimuth, distance
from pysmo.exc import SacHeaderUndefined
from pysmo._lib.defaults import SACIO_DEFAULTS
from typing import Any, Self
from attrs import define, field, validators, converters, Attribute
from attrs_strict import type_validator
from enum import Enum
import struct
import datetime
import io
import requests
import urllib.parse
import zipfile
import numpy as np
import numpy.typing as npt


{%- for header, values in headers.items() %}
{%- if values.is_enum %}
class {{ header|upper }}(Enum):
  {%- for key in values.allowed_vals.keys() %}
  {{ key }} = {{ enum_dict[key] }}
  {%- endfor %}
{%- endif %}
{%- endfor %}

SAC_ENUMS_DICT = dict(
  {%- for header, values in headers.items() %}
  {%- if values.is_enum %}
  {{ header }}={{ header|upper }},
  {%- endif %}
  {%- endfor %}
)


@define(frozen=True)
class HeaderType:
    definition: str
    undefined: float | int | str | bool
    length: int
    format: str
    description: str | None = None


HEADER_TYPES = dict(
    {%- for type, values in header_types.items() %}
    {{ type }}=HeaderType(definition='{{ values.definition }}', undefined={{ values.undefined }}, length={{ values.length }}, format='{{ values.format }}'),
    {%- endfor %}
)


@define(frozen=True)
class Header:
    start: int
    length: int
    format: str
    type: str
    required: bool


SAC_HEADERS = dict(
    {%- for header, values in headers.items() %}
    {{ header }}=Header(start={{ values.start }}, length={{ values.length }}, format='{{ values.format }}', type='{{ values.header_type }}', required={{ values.required | default(False) }}),
    {%- endfor %}
)


@define(frozen=True)
class Footer:
    start: int
    length: int = 8
    format: str = 'f'
    type: str = 'd'

SAC_FOOTERS = dict(
    {%- for footer, values in footers.items() %}
    {{ footer }}=Footer(start={{ values.start }}),
    {%- endfor %}
)



{#
ENUM_DICT = dict(
    {%- for header, values in headers.items() %}
    {%- if values.is_enum %}
    {{ header }}=[
      {%- for key in values.allowed_vals.keys() %}
      '{{ key }}',
      {%- endfor %}
    ],
    {%- endif %}
    {%- endfor %}
)
#}

def validate_sacenum(instance: "SacIO", attribute: Attribute, value: Any) -> None:
    if not hasattr(SAC_ENUMS_DICT[attribute.name], value):
        raise ValueError(f"{value=} is an invalid enum value for sac attribute {attribute.name}.")

@define(kw_only=True)
class SacIO:
    """
    Access SAC files in Python.

    The `SacIO` class reads and writes data and header values to and from a
    SAC file. Instances of `SacIO` provide attributes named identially to
    header names in the SAC file format. Additonal attributes may be set, but
    are not written to a SAC file (because there is no space reserved for them
    there). Class attributes with corresponding header fields in a SAC file
    (for example the begin time [`b`][pysmo._io.SacIO.b]) are checked for a
    valid format before being saved in the `SacIO` instance.

    Warning:
        This class should typically never be used directly. Instead please
        use the [`SAC`][pysmo.classes.SAC] class, which inherits all attributes
        and methods from here.

    Examples:
        Create a new instance from a file and print seismogram data:

        >>> from pysmo._io import SacIO
        >>> my_sac = SacIO.from_file('testfile.sac')
        >>> data = my_sac.data
        >>> data
        array([-1616.0, -1609.0, -1568.0, -1606.0, -1615.0, -1565.0, ...

        Read the sampling rate:

        >>> delta = my_sac.delta
        >>> delta
        0.019999999552965164

        Change the sampling rate:

        >>> newdelta = 0.05
        >>> my_sac.delta = newdelta
        >>> my_sac.delta
        0.05

        Create a new instance from IRIS services:

        >>> from pysmo._io import SacIO
        >>> my_sac = SacIO.from_iris(
        >>>             net="C1",
        >>>             sta="VA01",
        >>>             cha="BHZ",
        >>>             loc="--",
        >>>             start="2021-03-22T13:00:00",
        >>>             duration=1 * 60 * 60,
        >>>             scale="AUTO",
        >>>             demean="true",
        >>>             force_single_result=True)
        >>> my_sac.npts
        144001

    For each SAC(file) header field there is a corresponding attribute in this
    class. There are a lot of header fields in a SAC file, which are all called
    the same way when using `SacIO`.
    """
    {%- for header, header_dict in headers.items() -%}
    {%- if 'unused' not in header and 'internal' not in header %}
    {%- if header not in properties %}
    {{ header }}: {{ header_dict.python_type + " "-}}

    {%- if sacio_defaults[header] is defined -%}
     = field(default=SACIO_DEFAULTS.{{ header}}
    {%- if header_dict.python_type in ['float'] -%}
    , converter={{ header_dict.python_type }}
    {%- endif -%}
    {%- else -%}
     | None = field(default=None
    {%- if header_dict.python_type in ['float'] -%}
    , converter=converters.optional({{ header_dict.python_type }})
    {%- endif -%}
    {%- endif -%}


    {%- if validators[header] is defined -%}
     , validator={{ validators[header] }})
    {%- elif sacio_defaults[header] is defined -%}
     , validator=[type_validator()
     {%- if header_dict.python_type == 'str' -%}, validators.max_len({{ header_dict.length }}){%- endif -%}])
    {%- else -%}
     , validator=validators.optional([type_validator()
     {%- if header_dict.python_type == 'str' -%}, validators.max_len({{ header_dict.length }}){%- endif -%}]))
    {%- endif -%}
    {%- endif -%}
    {%- endif %}
    {%- if 'unused' not in header and 'internal' not in header %}
    """{{ header_dict.description | wordwrap(70) | indent(12) -}}"""
    {%- endif %}
    {%- endfor %}
    data: npt.NDArray = field(factory=lambda: np.array([]), validator=type_validator())
    x: npt.NDArray = field(factory=lambda: np.array([]), validator=type_validator())
    y: npt.NDArray = field(factory=lambda: np.array([]), validator=type_validator())

    @property
    def depmin(self) -> float | None:
        if self.npts == 0:
            return None
        return np.min(self.data).item()

    @property
    def depmax(self) -> float | None:
        if self.npts == 0:
            return None
        return np.max(self.data).item()

    @property
    def depmen(self) -> float | None:
        if self.npts == 0:
            return None
        return np.mean(self.data).item()

    @property
    def e(self) -> float:
        if self.npts == 0:
            return self.b
        return self.b + (self.npts - 1) * self.delta

    @property
    def dist(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            station_location = MiniLocation(latitude=self.stla, longitude=self.stlo)
            event_location = MiniLocation(latitude=self.evla, longitude=self.evlo)
            return (
                distance(location_1=station_location, location_2=event_location) / 1000
            )
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def az(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            station_location = MiniLocation(latitude=self.stla, longitude=self.stlo)
            event_location = MiniLocation(latitude=self.evla, longitude=self.evlo)
            return azimuth(location_1=station_location, location_2=event_location)
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def baz(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            station_location = MiniLocation(latitude=self.stla, longitude=self.stlo)
            event_location = MiniLocation(latitude=self.evla, longitude=self.evlo)
            return backazimuth(location_1=station_location, location_2=event_location)
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def gcarc(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            lat1, lon1 = np.deg2rad(self.stla), np.deg2rad(self.stlo)
            lat2, lon2 = np.deg2rad(self.evla), np.deg2rad(self.evlo)
            return np.rad2deg(np.arccos(np.sin(lat1) * np.sin(lat2) + np.cos(lat1)
                              * np.cos(lat2) * np.cos(np.abs(lon1 - lon2))))
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def xminimum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return np.min(self.x).item()

    @property
    def xmaximum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return np.max(self.x).item()

    @property
    def yminimum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.min(self.y).item()

    @property
    def ymaximum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.max(self.y).item()

    @property
    def npts(self) -> int:
        return np.size(self.data)

    @property
    def nxsize(self) -> float | None:
        if np.size(self.x) == 0:
            return None
        return np.size(self.x)

    @property
    def nysize(self) -> float | None:
        if np.size(self.y) == 0:
            return None
        return np.size(self.y)

    @property
    def lcalda(self) -> bool:
        # all distances and bearings are always calculated...
        return True

    @property
    def kzdate(self) -> str | None:
        """ISO 8601 format of GMT reference date."""
        if self.nzyear is None or self.nzjday is None:
            return None
        _kzdate = datetime.date(self.nzyear, 1, 1) + datetime.timedelta(self.nzjday - 1)
        return _kzdate.isoformat()

    @property
    def kztime(self) -> str | None:
        """Alphanumeric form of GMT reference time."""
        if self.nzhour is None or self.nzmin is None or self.nzsec is None or self.nzmsec is None:
            return None
        _kztime = datetime.time(self.nzhour, self.nzmin, self.nzsec, self.nzmsec * 1000)
        return _kztime.isoformat(timespec='milliseconds')

    def read(self, filename: str) -> None:
        """Read data and headers from a SAC file into an existing SAC instance.

        Parameters:
            filename: Name of the sac file to read.
        """

        with open(filename, 'rb') as file_handle:
            self.read_buffer(file_handle.read())

    def read_buffer(self, buffer: bytes) -> None:
        """Read data and headers from a SAC byte buffer into an existing SAC instance.

        Parameters:
            buffer: Buffer containing SAC file content.
        """

        if len(buffer) < 632:
            raise EOFError()

        # Guess the file endianness first using the unused12 header field.
        # It is located at position 276 and its value should be -12345.0.
        # Try reading with little endianness
        if struct.unpack('<f', buffer[276:280])[-1] == -12345.0:
            file_byteorder = '<'
        # otherwise assume big endianness.
        else:
            file_byteorder = '>'

        # Loop over all header fields and store them in the SAC object under their
        # respective private names.
        npts = 0
        for header, header_metadata in SAC_HEADERS.items():
            header_type = header_metadata.type
            header_required = header_metadata.required
            header_undefined = HEADER_TYPES[header_type].undefined
            start = header_metadata.start
            length = header_metadata.length
            end = start + length
            if end >= len(buffer):
                continue
            content = buffer[start:end]
            value = struct.unpack(file_byteorder + header_metadata.format, content)[0]
            if isinstance(value, bytes):
                # strip spaces and "\x00" chars
                value = value.decode().rstrip(" \x00")

            # npts is read only property in this class, but is needed for reading data
            if header == "npts":
                npts = int(value)

            # raise error if header is undefined AND required
            if value == header_undefined and header_required:
                raise RuntimeError(f"Required {header=} is undefined - invalid SAC file!")

            # skip if undefined (value == -12345...) and not required
            if value == header_undefined and not header_required:
                continue

            # convert enumerated header to string and format others
            if header_type == "i":
                value = SAC_ENUMS_DICT[header](value).name

            # SAC file has headers fields which are read only attributes in this
            # class. We skip them with this try/except.
            # TODO: This is a bit crude, should maybe be a bit more specific.
            try:
                setattr(self, header, value)
            except AttributeError as e:
                if "object has no setter" in str(e):
                    pass

        # Only accept IFTYPE = ITIME SAC files. Other IFTYPE use two data blocks,
        # which is something we don't support for now.
        if self.iftype.lower() != 'time':
            raise NotImplementedError(
                f"Reading SAC files with IFTYPE=(I){self.iftype.upper()} is not supported."  # noqa: E501
            )

        # Read first data block
        start = 632
        length = npts * 4
        data_end = start + length
        self.data = np.array([])
        if length > 0:
            data_end = start + length
            data_format = file_byteorder + str(npts) + 'f'
            if data_end > len(buffer):
                raise EOFError()
            content = buffer[start:data_end]
            data = struct.unpack(data_format, content)
            self.data = np.array(data)

        if self.nvhdr == 7:
            for footer, footer_metadata in SAC_FOOTERS.items():
                undefined = -12345.0
                length = 8
                start = footer_metadata.start + data_end
                end = start + length

                if end > len(buffer):
                    raise EOFError()
                content = buffer[start:end]

                value = struct.unpack(file_byteorder + 'd', content)[0]

                # skip if undefined (value == -12345...)
                if value == undefined:
                    continue

                # SAC file has headers fields which are read only attributes in this
                # class. We skip them with this try/except.
                # TODO: This is a bit crude, should maybe be a bit more specific.
                try:
                    setattr(self, footer, value)
                except AttributeError as e:
                    if "object has no setter" in str(e):
                        pass

    @classmethod
    def from_file(cls, filename: str) -> Self:
        """Create a new SAC instance from a SAC file.

        Parameters:
            filename: Name of the SAC file to read.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read(filename)
        return newinstance

    @classmethod
    def from_buffer(cls, buffer: bytes) -> Self:
        """Create a new SAC instance from a SAC data buffer.

        Parameters:
            buffer: Buffer containing SAC file content.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read_buffer(buffer)
        return newinstance

    @classmethod
    def from_iris(cls, net: str, sta: str, cha: str, loc: str, force_single_result: bool = False,
                  **kwargs: Any) -> Self | dict[str, Self] | None:
        """Create a list of SAC instances from a single IRIS
        request using the output format as "sac.zip".

        Parameters:
            net: Network code (e.g. "US")
            sta: Station code (e.g. "BSS")
            cha: Channel code (e.g. "BHZ")
            loc: Location code (e.g. "00")
            force_single_result: If true, the function will return a single SAC
                                 object or None if the requests returns nothing.

        Returns:
            A new SacIO instance.
        """
        kwargs["net"] = net
        kwargs["sta"] = sta
        kwargs["cha"] = cha
        kwargs["loc"] = loc
        kwargs["output"] = "sac.zip"

        if isinstance(kwargs["start"], datetime.datetime):
            kwargs["start"] = kwargs["start"].isoformat()

        end = kwargs.get("end", None)
        if end is not None and isinstance(end, datetime.datetime):
            kwargs["end"] = end.isoformat()

        base = "https://service.iris.edu/irisws/timeseries/1/query"
        params = urllib.parse.urlencode(kwargs, doseq=False)
        url = f"{base}?{params}"
        response = requests.get(url)
        if not response:
            raise ValueError(response.content.decode("utf-8"))
        zip = zipfile.ZipFile(io.BytesIO(response.content))
        result = {}
        for name in zip.namelist():
            buffer = zip.read(name)
            sac = cls.from_buffer(buffer)
            if force_single_result:
                return sac
            result[name] = sac
        return None if force_single_result else result

    def write(self, filename: str) -> None:
        """Writes data and header values to a SAC file.

        Parameters:
            filename: Name of the sacfile to write to.
        """
        with open(filename, 'wb') as file_handle:
            # loop over all valid header fields and write them to the file
            for header, header_metadata in SAC_HEADERS.items():
                header_type = header_metadata.type
                header_format = header_metadata.format
                start = header_metadata.start
                header_undefined = HEADER_TYPES[header_type].undefined

                value = None
                try:
                    if hasattr(self, header):
                        value = getattr(self, header)
                except SacHeaderUndefined:
                    value = None

                # convert enumerated header to integer if it is not None
                if header_type == "i" and value is not None:
                    value = SAC_ENUMS_DICT[header][value].value

                # set None to -12345
                if value is None:
                    value = header_undefined

                # Encode strings to bytes
                if isinstance(value, str):
                    value = value.encode()

                # write to file
                file_handle.seek(start)
                file_handle.write(struct.pack(header_format, value))

            # write data (if npts > 0)
            data_1_start = 632
            data_1_end = data_1_start + self.npts * 4
            file_handle.truncate(data_1_start)
            if self.npts > 0:
                file_handle.seek(data_1_start)
                for x in self.data:
                    file_handle.write(struct.pack('f', x))

            if self.nvhdr == 7:
                for footer, footer_metadata in SAC_FOOTERS.items():
                    undefined = -12345.0
                    start = footer_metadata.start + data_1_end
                    value = None
                    try:
                        if hasattr(self, footer):
                            value = getattr(self, footer)
                    except SacHeaderUndefined:
                        value = None

                    # set None to -12345
                    if value is None:
                        value = undefined

                    # write to file
                    file_handle.seek(start)
                    file_handle.write(struct.pack("d", value))
