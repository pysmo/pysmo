{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pysmo","text":"pysmo <p> Documentation: https://docs.pysmo.org </p> <p> Source Code: https://github.com/pysmo/pysmo </p> <p>The addition of type annotations to Python marked a significant step forward in user experience (e.g. intelligent autocompletion in modern editors) and type safety (by catching errors before code is executed). With types thus becoming more meaningful, it is worth revisiting what a type should mean to a seismologist.</p> <p>Traditionally a lot of data are stored together (e.g. in a seismogram file of some format containing a time series and its metadata), only for most of that data to be ignored during processing. While it makes sense to store the data together, it is better to split them up into far simpler types when writing code for processing.</p> <p>Pysmo offers simple data types for seismologists to write code with. Instead of working with one big class containing all kinds of data, psymo uses separate, narrowly defined protocol classes that are not tied to any particular file format or existing class.</p> <p>Code written with pysmo types is easy to understand and maintain. Most importantly, it can often be reused in different projects, thus reducing the duplication of effort.</p> <p>Pysmo itself is designed to be modular and easy to expand without interfering with the existing code base, making it straightforward to incorporate user contributions.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#latest-changes","title":"Latest Changes","text":"<ul> <li>fix: add event time to SacEvent</li> <li>feat: add Event type and MiniEvent class</li> <li>refactor: move functions into a single file</li> <li>docs: switch to google type docstrings</li> <li>docs: switch from sphinx to mkdocs</li> </ul>"},{"location":"contributors/","title":"Contributors","text":"<ul> <li>Omkar Ranadive</li> <li>Helio Tejedor</li> <li>Xioating Lou</li> <li>Lay Kuan Loh</li> </ul>"},{"location":"api/","title":"Index","text":""},{"location":"api/#pysmo","title":"pysmo","text":"<p>Pysmo types and corresponding Mini Classes.</p> <p>The psymo base namespace exposes the protocol classes that are used as type hints, as well as reference implementations of a generic class for each protocol. The reference classes are subclasses of their respective protocol classes that contain exactly the same attributes (though some extra methods may be defined for convenience). They can be considered minimal implementations of a class that can be used with pysmo protocols, and are therefore named \"Mini\" + \"name of protocol\" (e.g. <code>MiniSeismogram</code> is an implementation of the <code>Seismogram</code> type).</p> <p>Classes, functions and other tools that make use of pysmo types and mini need to be imported from other modules.</p> <p>Modules:</p> <ul> <li> <code>classes</code>           \u2013            <p>Classes that work with pysmo types.</p> </li> <li> <code>functions</code>           \u2013            <p>Simple operations using pysmo types.</p> </li> <li> <code>lib</code>           \u2013            <p>Pysmo library module.</p> </li> <li> <code>tools</code>           \u2013            <p>Extra tools or topics that use pysmo types.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Seismogram</code>           \u2013            <p>Protocol class to define the <code>Seismogram</code> type.</p> </li> <li> <code>Station</code>           \u2013            <p>Protocol class to define the <code>Station</code> type.</p> </li> <li> <code>Event</code>           \u2013            <p>Protocol class to define the <code>Event</code> type.</p> </li> <li> <code>Location</code>           \u2013            <p>Protocol class to define the <code>Location</code> type.</p> </li> <li> <code>LocationWithDepth</code>           \u2013            <p>Protocol class to define the <code>LocationWithDepth</code> type.</p> </li> <li> <code>MiniSeismogram</code>           \u2013            <p>Minimal class for use with the <code>Seismogram</code> type.</p> </li> <li> <code>MiniStation</code>           \u2013            <p>Minimal class for use with the Station type.</p> </li> <li> <code>MiniEvent</code>           \u2013            <p>Minimal class for use with the <code>Event</code> type.</p> </li> <li> <code>MiniLocation</code>           \u2013            <p>Minimal class for use with the <code>Location</code> type.</p> </li> <li> <code>MiniLocationWithDepth</code>           \u2013            <p>Minimal class for use with the <code>MiniLocationWithDepth</code> type.</p> </li> </ul>"},{"location":"api/#pysmo.Seismogram","title":"Seismogram","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol class to define the <code>Seismogram</code> type.</p> <p>Examples:</p> <p>Usage for a function that takes a Seismogram compatible class instance as argument and returns the begin time in isoformat:</p> <pre><code>&gt;&gt;&gt; from pysmo import Seismogram\n&gt;&gt;&gt; from pysmo.classes import SAC  # SAC is a class that \"speaks\" Seismogram\n&gt;&gt;&gt;\n&gt;&gt;&gt; def example_function(seis_in: Seismogram) -&gt; str:\n...     return seis_in.begin_time.isoformat()\n...\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; seismogram = sac.seismogram\n&gt;&gt;&gt; example_function(seismogram)\n'2005-03-01T07:23:02.160000+00:00'\n&gt;&gt;&gt;\n</code></pre> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              <p>The length of the Seismogram.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Seismogram data.</p> </li> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram begin time.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram end time.</p> </li> <li> <code>delta</code>               (<code>timedelta</code>)           \u2013            <p>The sampling interval.</p> </li> </ul> Source code in <code>pysmo/_types/_seismogram.py</code> <pre><code>@runtime_checkable\nclass Seismogram(Protocol):\n    \"\"\"Protocol class to define the `Seismogram` type.\n\n    Examples:\n        Usage for a function that takes a Seismogram compatible class instance as\n        argument and returns the begin time in isoformat:\n\n        ```python\n        &gt;&gt;&gt; from pysmo import Seismogram\n        &gt;&gt;&gt; from pysmo.classes import SAC  # SAC is a class that \"speaks\" Seismogram\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def example_function(seis_in: Seismogram) -&gt; str:\n        ...     return seis_in.begin_time.isoformat()\n        ...\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; seismogram = sac.seismogram\n        &gt;&gt;&gt; example_function(seismogram)\n        '2005-03-01T07:23:02.160000+00:00'\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"The length of the Seismogram.\n\n        Returns:\n            Number of samples in the data array.\n        \"\"\"\n        ...\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        \"\"\"Seismogram data.\"\"\"\n        ...\n\n    @data.setter\n    def data(self, value: np.ndarray) -&gt; None: ...\n\n    @property\n    def begin_time(self) -&gt; datetime:\n        \"\"\"Seismogram begin time.\"\"\"\n        ...\n\n    @begin_time.setter\n    def begin_time(self, value: datetime) -&gt; None: ...\n\n    @property\n    def end_time(self) -&gt; datetime:\n        \"\"\"Seismogram end time.\"\"\"\n        ...\n\n    @property\n    def delta(self) -&gt; timedelta:\n        \"\"\"The sampling interval.\"\"\"\n        ...\n\n    @delta.setter\n    def delta(self, value: timedelta) -&gt; None: ...\n</code></pre>"},{"location":"api/#pysmo.Seismogram.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Seismogram data.</p>"},{"location":"api/#pysmo.Seismogram.begin_time","title":"begin_time  <code>property</code> <code>writable</code>","text":"<pre><code>begin_time: datetime\n</code></pre> <p>Seismogram begin time.</p>"},{"location":"api/#pysmo.Seismogram.end_time","title":"end_time  <code>property</code>","text":"<pre><code>end_time: datetime\n</code></pre> <p>Seismogram end time.</p>"},{"location":"api/#pysmo.Seismogram.delta","title":"delta  <code>property</code> <code>writable</code>","text":"<pre><code>delta: timedelta\n</code></pre> <p>The sampling interval.</p>"},{"location":"api/#pysmo.Seismogram.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The length of the Seismogram.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of samples in the data array.</p> </li> </ul> Source code in <code>pysmo/_types/_seismogram.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"The length of the Seismogram.\n\n    Returns:\n        Number of samples in the data array.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/#pysmo.Station","title":"Station","text":"<p>               Bases: <code>Location</code>, <code>Protocol</code></p> <p>Protocol class to define the <code>Station</code> type.</p> <p>Attributes:</p> <ul> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Latitude in degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Longitude in degrees.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Station name or identifier.</p> </li> <li> <code>network</code>               (<code>str</code>)           \u2013            <p>Network name or identifier.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>Location ID.</p> </li> <li> <code>channel</code>               (<code>str</code>)           \u2013            <p>Channel code.</p> </li> <li> <code>elevation</code>               (<code>float | None</code>)           \u2013            <p>Station elevation in metres.</p> </li> </ul> Source code in <code>pysmo/_types/_station.py</code> <pre><code>@runtime_checkable\nclass Station(Location, Protocol):\n    \"\"\"Protocol class to define the `Station` type.\"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Station name or identifier.\n\n        A 1-5 character identifier for the station recording the data.\n        \"\"\"\n        ...\n\n    @name.setter\n    def name(self, value: str) -&gt; None: ...\n\n    @property\n    def network(self) -&gt; str:\n        \"\"\"Network name or identifier.\n\n        A 1-2 character code identifying the network/owner of the data.\n        \"\"\"\n        ...\n\n    @network.setter\n    def network(self, value: str) -&gt; None: ...\n\n    @property\n    def location(self) -&gt; str:\n        \"\"\"Location ID.\n\n        A two character code used to uniquely identify different data streams\n        at a single stationa.\n        \"\"\"\n        ...\n\n    @location.setter\n    def location(self, value: str) -&gt; None: ...\n\n    @property\n    def channel(self) -&gt; str:\n        \"\"\"Channel code.\n\n        A three character combination used to identify:\n\n        1. Band and general sample rate.\n        2. Instrument type.\n        3. Orientation of the sensor.\n        \"\"\"\n        ...\n\n    @channel.setter\n    def channel(self, value: str) -&gt; None: ...\n\n    @property\n    def elevation(self) -&gt; float | None:\n        \"\"\"Station elevation in metres.\"\"\"\n        ...\n\n    @elevation.setter\n    def elevation(self, value: float) -&gt; None: ...\n</code></pre>"},{"location":"api/#pysmo.Station.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/#pysmo.Station.longitude","title":"longitude  <code>property</code> <code>writable</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/#pysmo.Station.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Station name or identifier.</p> <p>A 1-5 character identifier for the station recording the data.</p>"},{"location":"api/#pysmo.Station.network","title":"network  <code>property</code> <code>writable</code>","text":"<pre><code>network: str\n</code></pre> <p>Network name or identifier.</p> <p>A 1-2 character code identifying the network/owner of the data.</p>"},{"location":"api/#pysmo.Station.location","title":"location  <code>property</code> <code>writable</code>","text":"<pre><code>location: str\n</code></pre> <p>Location ID.</p> <p>A two character code used to uniquely identify different data streams at a single stationa.</p>"},{"location":"api/#pysmo.Station.channel","title":"channel  <code>property</code> <code>writable</code>","text":"<pre><code>channel: str\n</code></pre> <p>Channel code.</p> <p>A three character combination used to identify:</p> <ol> <li>Band and general sample rate.</li> <li>Instrument type.</li> <li>Orientation of the sensor.</li> </ol>"},{"location":"api/#pysmo.Station.elevation","title":"elevation  <code>property</code> <code>writable</code>","text":"<pre><code>elevation: float | None\n</code></pre> <p>Station elevation in metres.</p>"},{"location":"api/#pysmo.Event","title":"Event","text":"<p>               Bases: <code>LocationWithDepth</code>, <code>Protocol</code></p> <p>Protocol class to define the <code>Event</code> type.</p> <p>Attributes:</p> <ul> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Latitude in degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Longitude in degrees.</p> </li> <li> <code>depth</code>               (<code>float</code>)           \u2013            <p>Location depth in metres.</p> </li> <li> <code>time</code>               (<code>datetime</code>)           \u2013            <p>Event origin time.</p> </li> </ul> Source code in <code>pysmo/_types/_event.py</code> <pre><code>@runtime_checkable\nclass Event(LocationWithDepth, Protocol):\n    \"\"\"Protocol class to define the `Event` type.\"\"\"\n\n    @property\n    def time(self) -&gt; datetime:\n        \"\"\"Event origin time.\"\"\"\n        ...\n\n    @time.setter\n    def time(self, value: datetime) -&gt; None: ...\n</code></pre>"},{"location":"api/#pysmo.Event.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/#pysmo.Event.longitude","title":"longitude  <code>property</code> <code>writable</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/#pysmo.Event.depth","title":"depth  <code>property</code> <code>writable</code>","text":"<pre><code>depth: float\n</code></pre> <p>Location depth in metres.</p>"},{"location":"api/#pysmo.Event.time","title":"time  <code>property</code> <code>writable</code>","text":"<pre><code>time: datetime\n</code></pre> <p>Event origin time.</p>"},{"location":"api/#pysmo.Location","title":"Location","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol class to define the <code>Location</code> type.</p> <p>Attributes:</p> <ul> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Latitude in degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Longitude in degrees.</p> </li> </ul> Source code in <code>pysmo/_types/_location.py</code> <pre><code>@runtime_checkable\nclass Location(Protocol):\n    \"\"\"Protocol class to define the `Location` type.\"\"\"\n\n    @property\n    def latitude(self) -&gt; float:\n        \"\"\"Latitude in degrees.\"\"\"\n        ...\n\n    @latitude.setter\n    def latitude(self, value: float) -&gt; None: ...\n\n    @property\n    def longitude(self) -&gt; float:\n        \"\"\"Longitude in degrees.\"\"\"\n        ...\n\n    @longitude.setter\n    def longitude(self, value: float) -&gt; None: ...\n</code></pre>"},{"location":"api/#pysmo.Location.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/#pysmo.Location.longitude","title":"longitude  <code>property</code> <code>writable</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/#pysmo.LocationWithDepth","title":"LocationWithDepth","text":"<p>               Bases: <code>Location</code>, <code>Protocol</code></p> <p>Protocol class to define the <code>LocationWithDepth</code> type.</p> <p>Attributes:</p> <ul> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Latitude in degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Longitude in degrees.</p> </li> <li> <code>depth</code>               (<code>float</code>)           \u2013            <p>Location depth in metres.</p> </li> </ul> Source code in <code>pysmo/_types/_location_with_depth.py</code> <pre><code>@runtime_checkable\nclass LocationWithDepth(Location, Protocol):\n    \"\"\"Protocol class to define the `LocationWithDepth` type.\"\"\"\n\n    @property\n    def depth(self) -&gt; float:\n        \"\"\"Location depth in metres.\"\"\"\n        ...\n\n    @depth.setter\n    def depth(self, value: float) -&gt; None: ...\n</code></pre>"},{"location":"api/#pysmo.LocationWithDepth.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Latitude in degrees.</p>"},{"location":"api/#pysmo.LocationWithDepth.longitude","title":"longitude  <code>property</code> <code>writable</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Longitude in degrees.</p>"},{"location":"api/#pysmo.LocationWithDepth.depth","title":"depth  <code>property</code> <code>writable</code>","text":"<pre><code>depth: float\n</code></pre> <p>Location depth in metres.</p>"},{"location":"api/#pysmo.MiniSeismogram","title":"MiniSeismogram","text":"<p>Minimal class for use with the <code>Seismogram</code> type.</p> <p>The <code>MiniSeismogram</code> class provides a minimal implementation of class that is compatible with the <code>Seismogram</code> type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo import MiniSeismogram, Seismogram\n&gt;&gt;&gt; from datetime import datetime, timedelta, timezone\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; now = datetime.now(timezone.utc)\n&gt;&gt;&gt; delta = timedelta(seconds=0.1)\n&gt;&gt;&gt; seismogram = MiniSeismogram(begin_time=now, delta=delta, data=np.random.rand(100))\n&gt;&gt;&gt; isinstance(seismogram, Seismogram)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              <p>The length of the Seismogram.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram begin time.</p> </li> <li> <code>delta</code>               (<code>timedelta</code>)           \u2013            <p>Seismogram sampling interval.</p> </li> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Seismogram data.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram end time.</p> </li> </ul> Source code in <code>pysmo/_types/_seismogram.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass MiniSeismogram:\n    \"\"\"Minimal class for use with the [`Seismogram`][pysmo.Seismogram] type.\n\n    The `MiniSeismogram` class provides a minimal implementation of class that\n    is compatible with the [`Seismogram`][pysmo.Seismogram] type.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo import MiniSeismogram, Seismogram\n        &gt;&gt;&gt; from datetime import datetime, timedelta, timezone\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; now = datetime.now(timezone.utc)\n        &gt;&gt;&gt; delta = timedelta(seconds=0.1)\n        &gt;&gt;&gt; seismogram = MiniSeismogram(begin_time=now, delta=delta, data=np.random.rand(100))\n        &gt;&gt;&gt; isinstance(seismogram, Seismogram)\n        True\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    begin_time: datetime = field(\n        default=SEISMOGRAM_DEFAULTS.begin_time.value, validator=datetime_is_utc\n    )\n    \"\"\"Seismogram begin time.\"\"\"\n\n    delta: timedelta = SEISMOGRAM_DEFAULTS.delta.value\n    \"\"\"Seismogram sampling interval.\"\"\"\n\n    data: np.ndarray = field(factory=lambda: np.array([]))\n    \"\"\"Seismogram data.\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"The length of the Seismogram.\n\n        Returns:\n            Number of samples in the data array.\n        \"\"\"\n        return np.size(self.data)\n\n    @property\n    def end_time(self) -&gt; datetime:\n        \"\"\"Seismogram end time.\"\"\"\n        if len(self) == 0:\n            return self.begin_time\n        return self.begin_time + self.delta * (len(self) - 1)\n</code></pre>"},{"location":"api/#pysmo.MiniSeismogram.begin_time","title":"begin_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>begin_time: datetime = field(\n    default=begin_time.value, validator=datetime_is_utc\n)\n</code></pre> <p>Seismogram begin time.</p>"},{"location":"api/#pysmo.MiniSeismogram.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: timedelta = delta.value\n</code></pre> <p>Seismogram sampling interval.</p>"},{"location":"api/#pysmo.MiniSeismogram.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: ndarray = field(factory=lambda: array([]))\n</code></pre> <p>Seismogram data.</p>"},{"location":"api/#pysmo.MiniSeismogram.end_time","title":"end_time  <code>property</code>","text":"<pre><code>end_time: datetime\n</code></pre> <p>Seismogram end time.</p>"},{"location":"api/#pysmo.MiniSeismogram.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The length of the Seismogram.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of samples in the data array.</p> </li> </ul> Source code in <code>pysmo/_types/_seismogram.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"The length of the Seismogram.\n\n    Returns:\n        Number of samples in the data array.\n    \"\"\"\n    return np.size(self.data)\n</code></pre>"},{"location":"api/#pysmo.MiniStation","title":"MiniStation","text":"<p>Minimal class for use with the Station type.</p> <p>The <code>MiniStation</code> class provides a minimal implementation of class that is compatible with the <code>Station</code> type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo import MiniStation, Station, Location\n&gt;&gt;&gt; station = MiniStation(latitude=-21.680301, longitude=-46.732601, name=\"CACB\", network=\"BL\", channel=\"BHZ\", location=\"00\")\n&gt;&gt;&gt; isinstance(station, Station)\nTrue\n&gt;&gt;&gt; isinstance(station, Location)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Station name.</p> </li> <li> <code>network</code>               (<code>str</code>)           \u2013            <p>Network name.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>Location ID.</p> </li> <li> <code>channel</code>               (<code>str</code>)           \u2013            <p>Channel code.</p> </li> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Station latitude from -90 to 90 degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Station longitude from -180 to 180 degrees.</p> </li> <li> <code>elevation</code>               (<code>float | None</code>)           \u2013            <p>Station elevation.</p> </li> </ul> Source code in <code>pysmo/_types/_station.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass MiniStation:\n    \"\"\"Minimal class for use with the Station type.\n\n    The `MiniStation` class provides a minimal implementation of class that\n    is compatible with the `Station` type.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo import MiniStation, Station, Location\n        &gt;&gt;&gt; station = MiniStation(latitude=-21.680301, longitude=-46.732601, name=\"CACB\", network=\"BL\", channel=\"BHZ\", location=\"00\")\n        &gt;&gt;&gt; isinstance(station, Station)\n        True\n        &gt;&gt;&gt; isinstance(station, Location)\n        True\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    name: str = field(validator=[validators.min_len(1), validators.max_len(5)])\n    \"\"\"Station name.\n\n    See [`Station.name`][pysmo.Station.name] for more details.\n    \"\"\"\n\n    network: str = field(validator=[validators.min_len(1), validators.max_len(2)])\n    \"\"\"Network name.\n\n    See [`Station.network`][pysmo.Station.network] for more details.\n    \"\"\"\n\n    location: str = field(\n        default=\"  \",\n        validator=[validators.min_len(2), validators.max_len(2)],\n        converter=pad_string,\n    )\n    \"\"\"Location ID.\n\n    See [`Station.location`][pysmo.Station.location] for more details.\n    \"\"\"\n\n    channel: str = field(validator=[validators.min_len(3), validators.max_len(3)])\n    \"\"\"Channel code.\n\n    See [`Station.channel`][pysmo.Station.channel] for more details.\n    \"\"\"\n\n    latitude: float = field(validator=[validators.ge(-90), validators.le(90)])\n    \"\"\"Station latitude from -90 to 90 degrees.\"\"\"\n\n    longitude: float = field(validator=[validators.gt(-180), validators.le(180)])\n    \"\"\"Station longitude from -180 to 180 degrees.\"\"\"\n\n    elevation: float | None = field(\n        default=None, validator=validators.optional(validators.instance_of(float | int))\n    )\n    \"\"\"Station elevation.\"\"\"\n</code></pre>"},{"location":"api/#pysmo.MiniStation.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str = field(validator=[min_len(1), max_len(5)])\n</code></pre> <p>Station name.</p> <p>See <code>Station.name</code> for more details.</p>"},{"location":"api/#pysmo.MiniStation.network","title":"network  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>network: str = field(validator=[min_len(1), max_len(2)])\n</code></pre> <p>Network name.</p> <p>See <code>Station.network</code> for more details.</p>"},{"location":"api/#pysmo.MiniStation.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: str = field(\n    default=\"  \",\n    validator=[min_len(2), max_len(2)],\n    converter=pad_string,\n)\n</code></pre> <p>Location ID.</p> <p>See <code>Station.location</code> for more details.</p>"},{"location":"api/#pysmo.MiniStation.channel","title":"channel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>channel: str = field(validator=[min_len(3), max_len(3)])\n</code></pre> <p>Channel code.</p> <p>See <code>Station.channel</code> for more details.</p>"},{"location":"api/#pysmo.MiniStation.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(validator=[ge(-90), le(90)])\n</code></pre> <p>Station latitude from -90 to 90 degrees.</p>"},{"location":"api/#pysmo.MiniStation.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(validator=[gt(-180), le(180)])\n</code></pre> <p>Station longitude from -180 to 180 degrees.</p>"},{"location":"api/#pysmo.MiniStation.elevation","title":"elevation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elevation: float | None = field(\n    default=None,\n    validator=optional(instance_of(float | int)),\n)\n</code></pre> <p>Station elevation.</p>"},{"location":"api/#pysmo.MiniEvent","title":"MiniEvent","text":"<p>Minimal class for use with the <code>Event</code> type.</p> <p>The <code>MiniEvent</code> class provides a minimal implementation of class that is compatible with the <code>Event</code> type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo import MiniEvent, Event, LocationWithDepth, Location\n&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; now = datetime.now(timezone.utc)\n&gt;&gt;&gt; event = MiniEvent(latitude=-24.68, longitude=-26.73, depth=15234.0, time=now)\n&gt;&gt;&gt; isinstance(event, Event)\nTrue\n&gt;&gt;&gt; isinstance(event, Location)\nTrue\n&gt;&gt;&gt; isinstance(event, LocationWithDepth)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>time</code>               (<code>datetime</code>)           \u2013            <p>Event origin time.</p> </li> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Event atitude from -90 to 90 degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Event longitude from -180 to 180 degrees.</p> </li> <li> <code>depth</code>               (<code>float</code>)           \u2013            <p>Event depth in metres.</p> </li> </ul> Source code in <code>pysmo/_types/_event.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass MiniEvent:\n    \"\"\"Minimal class for use with the [`Event`][pysmo.Event] type.\n\n    The `MiniEvent` class provides a minimal implementation of class that is\n    compatible with the [`Event`][pysmo.Event] type.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo import MiniEvent, Event, LocationWithDepth, Location\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; now = datetime.now(timezone.utc)\n        &gt;&gt;&gt; event = MiniEvent(latitude=-24.68, longitude=-26.73, depth=15234.0, time=now)\n        &gt;&gt;&gt; isinstance(event, Event)\n        True\n        &gt;&gt;&gt; isinstance(event, Location)\n        True\n        &gt;&gt;&gt; isinstance(event, LocationWithDepth)\n        True\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    time: datetime = field(validator=datetime_is_utc)\n    \"\"\"Event origin time.\"\"\"\n\n    latitude: float = field(validator=[validators.ge(-90), validators.le(90)])\n    \"\"\"Event atitude from -90 to 90 degrees.\"\"\"\n\n    longitude: float = field(validator=[validators.gt(-180), validators.le(180)])\n    \"\"\"Event longitude from -180 to 180 degrees.\"\"\"\n\n    depth: float\n    \"\"\"Event depth in metres.\"\"\"\n</code></pre>"},{"location":"api/#pysmo.MiniEvent.time","title":"time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>time: datetime = field(validator=datetime_is_utc)\n</code></pre> <p>Event origin time.</p>"},{"location":"api/#pysmo.MiniEvent.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(validator=[ge(-90), le(90)])\n</code></pre> <p>Event atitude from -90 to 90 degrees.</p>"},{"location":"api/#pysmo.MiniEvent.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(validator=[gt(-180), le(180)])\n</code></pre> <p>Event longitude from -180 to 180 degrees.</p>"},{"location":"api/#pysmo.MiniEvent.depth","title":"depth  <code>instance-attribute</code>","text":"<pre><code>depth: float\n</code></pre> <p>Event depth in metres.</p>"},{"location":"api/#pysmo.MiniLocation","title":"MiniLocation","text":"<p>Minimal class for use with the <code>Location</code> type.</p> <p>The <code>MiniLocation</code> class provides a minimal implementation of class that is compatible with the <code>Location</code> type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo import MiniLocation, Location\n&gt;&gt;&gt; location = MiniLocation(latitude=41.8781, longitude=-87.6298)\n&gt;&gt;&gt; isinstance(location, Location)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Latitude from -90 to 90 degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Longitude from -180 to 180 degrees.</p> </li> </ul> Source code in <code>pysmo/_types/_location.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass MiniLocation:\n    \"\"\"Minimal class for use with the [`Location`][pysmo.Location] type.\n\n    The `MiniLocation` class provides a minimal implementation of class that\n    is compatible with the [`Location`][pysmo.Location] type.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo import MiniLocation, Location\n        &gt;&gt;&gt; location = MiniLocation(latitude=41.8781, longitude=-87.6298)\n        &gt;&gt;&gt; isinstance(location, Location)\n        True\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    latitude: float = field(validator=[validators.ge(-90), validators.le(90)])\n    \"\"\"Latitude from -90 to 90 degrees.\"\"\"\n\n    longitude: float = field(validator=[validators.gt(-180), validators.le(180)])\n    \"\"\"Longitude from -180 to 180 degrees.\"\"\"\n</code></pre>"},{"location":"api/#pysmo.MiniLocation.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(validator=[ge(-90), le(90)])\n</code></pre> <p>Latitude from -90 to 90 degrees.</p>"},{"location":"api/#pysmo.MiniLocation.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(validator=[gt(-180), le(180)])\n</code></pre> <p>Longitude from -180 to 180 degrees.</p>"},{"location":"api/#pysmo.MiniLocationWithDepth","title":"MiniLocationWithDepth","text":"<p>Minimal class for use with the <code>MiniLocationWithDepth</code> type.</p> <p>The <code>MiniLocationWithDepth</code> class provides a minimal implementation of class that is compatible with the <code>MiniLocationWithDepth</code> type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo import MiniLocationWithDepth, LocationWithDepth, Location\n&gt;&gt;&gt; hypo = MiniLocationWithDepth(latitude=-24.68, longitude=-26.73, depth=15234.0)\n&gt;&gt;&gt; isinstance(hypo, LocationWithDepth)\nTrue\n&gt;&gt;&gt; isinstance(hypo, Location)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Location latitude from -90 to 90 degrees.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Location longitude from -180 to 180 degrees.</p> </li> <li> <code>depth</code>               (<code>float</code>)           \u2013            <p>Location depth in metres.</p> </li> </ul> Source code in <code>pysmo/_types/_location_with_depth.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass MiniLocationWithDepth:\n    \"\"\"Minimal class for use with the [`MiniLocationWithDepth`][pysmo.MiniLocationWithDepth] type.\n\n    The `MiniLocationWithDepth` class provides a minimal implementation of class that\n    is compatible with the [`MiniLocationWithDepth`][pysmo.MiniLocationWithDepth] type.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo import MiniLocationWithDepth, LocationWithDepth, Location\n        &gt;&gt;&gt; hypo = MiniLocationWithDepth(latitude=-24.68, longitude=-26.73, depth=15234.0)\n        &gt;&gt;&gt; isinstance(hypo, LocationWithDepth)\n        True\n        &gt;&gt;&gt; isinstance(hypo, Location)\n        True\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    latitude: float = field(validator=[validators.ge(-90), validators.le(90)])\n    \"\"\"Location latitude from -90 to 90 degrees.\"\"\"\n\n    longitude: float = field(validator=[validators.gt(-180), validators.le(180)])\n    \"\"\"Location longitude from -180 to 180 degrees.\"\"\"\n\n    depth: float\n    \"\"\"Location depth in metres.\"\"\"\n</code></pre>"},{"location":"api/#pysmo.MiniLocationWithDepth.latitude","title":"latitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>latitude: float = field(validator=[ge(-90), le(90)])\n</code></pre> <p>Location latitude from -90 to 90 degrees.</p>"},{"location":"api/#pysmo.MiniLocationWithDepth.longitude","title":"longitude  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>longitude: float = field(validator=[gt(-180), le(180)])\n</code></pre> <p>Location longitude from -180 to 180 degrees.</p>"},{"location":"api/#pysmo.MiniLocationWithDepth.depth","title":"depth  <code>instance-attribute</code>","text":"<pre><code>depth: float\n</code></pre> <p>Location depth in metres.</p>"},{"location":"api/pysmo/classes/","title":"Index","text":""},{"location":"api/pysmo/classes/#pysmo.classes","title":"pysmo.classes","text":"<p>Classes that work with pysmo types.</p> <p>Classes:</p> <ul> <li> <code>SAC</code>           \u2013            <p>Access and modify data stored in SAC files.</p> </li> <li> <code>SacEvent</code>           \u2013            <p>Helper class for SAC event attributes.</p> </li> <li> <code>SacSeismogram</code>           \u2013            <p>Helper class for SAC seismogram attributes.</p> </li> <li> <code>SacStation</code>           \u2013            <p>Helper class for SAC station attributes.</p> </li> <li> <code>SacTimestamps</code>           \u2013            <p>Helper class to access times stored in SAC headers as datetime objects.</p> </li> </ul>"},{"location":"api/pysmo/classes/#pysmo.classes.SAC","title":"SAC","text":"<p>               Bases: <code>SacIO</code></p> <p>Access and modify data stored in SAC files.</p> <p>The <code>SAC</code> class inherits all attributes and methods of the <code>SacIO</code> class, and extends it with attributes that allow using pysmo types. The extra attributes are themselves instances of \"helper\" classes that shouldn't be instantiated directly.</p> <p>Examples:</p> <p>SAC instances are typically created by reading a SAC file. Users familiar with the SAC file format can access header and data using the names they are used to:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; sac.delta\n0.019999999552965164\n&gt;&gt;&gt; sac.data\narray([2302., 2313., 2345., ..., 2836., 2772., 2723.], shape=(180000,))\n&gt;&gt;&gt; sac.evla\n-31.465999603271484\n&gt;&gt;&gt;\n</code></pre> <p>Presenting the data in the above way is not compatible with pysmo types. For example, event coordinates are stored in the <code>evla</code> and <code>evlo</code> attributes, which do not match the pysmo <code>Location</code> type. Renaming or aliasing <code>evla</code> to <code>latitude</code> and <code>evlo</code> to <code>longitude</code> would solve the problem for the event coordinates, but since the SAC format also specifies station coordinates (<code>stla</code>, <code>stlo</code>) we still run into compatibility issues.</p> <p>In order to map these incompatible attributes to ones that can be used with pysmo types, we use helper classes as a way to access the attributes under different names that are compatible with pysmo types:</p> <pre><code>&gt;&gt;&gt; # Import the Seismogram type to check if the nested class is compatible:\n&gt;&gt;&gt; from pysmo import Seismogram\n&gt;&gt;&gt;\n&gt;&gt;&gt; # First verify that a SAC instance is not a pysmo Seismogram:\n&gt;&gt;&gt; isinstance(sac, Seismogram)\nFalse\n&gt;&gt;&gt; # The sac.seismogram object is, however:\n&gt;&gt;&gt; isinstance(sac.seismogram, Seismogram)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Because the SAC file format defines a large amount of header fields for metadata, it needs to allow for many of these to be optional. Since the helper classes are more specific (and intended to be used with pysmo types), their attributes typically may not be <code>None</code>:</p> <pre><code>&gt;&gt;&gt; # No error: a SAC file doesn't have to contain event information:\n&gt;&gt;&gt; sac.evla = None\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Error: the sac.event object may not have attributes set to `None`:\n&gt;&gt;&gt; sac.event.latitude = None\nTraceback (most recent call last):\n...\nTypeError: SacEvent.latitude may not be of None type.\n&gt;&gt;&gt;\n</code></pre> Tip <p>The <code>SAC</code> class directly inherits from the <code>SacIO</code> class. This gives access to all SAC headers, ability to load from a file, download data, and so on. Using <code>SAC</code> is therefore almost always preferred over using <code>SacIO</code>.</p> <p>Attributes:</p> <ul> <li> <code>event</code>               (<code>SacEvent</code>)           \u2013            <p>Access data stored in the SAC object compatible with the <code>Event</code> type.</p> </li> <li> <code>seismogram</code>               (<code>SacSeismogram</code>)           \u2013            <p>Access data stored in the SAC object compatible with the <code>Seismogram</code> type.</p> </li> <li> <code>station</code>               (<code>SacStation</code>)           \u2013            <p>Access data stored in the SAC object compatible with the <code>Station</code> type.</p> </li> <li> <code>timestamps</code>               (<code>SacTimestamps</code>)           \u2013            <p>Maps a SAC times such as B, E, O, T0-T9 to datetime objects.</p> </li> </ul> Source code in <code>pysmo/classes/_sac.py</code> <pre><code>@define(kw_only=True)\nclass SAC(SacIO):\n    \"\"\"Access and modify data stored in SAC files.\n\n    The [`SAC`][pysmo.classes.SAC] class inherits all attributes and methods\n    of the [`SacIO`][pysmo.lib.io.SacIO] class, and extends it with attributes\n    that allow using pysmo types. The extra attributes are themselves instances\n    of \"helper\" classes that shouldn't be instantiated directly.\n\n    Examples:\n        SAC instances are typically created by reading a SAC file. Users\n        familiar with the SAC file format can access header and data using\n        the names they are used to:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; sac.delta\n        0.019999999552965164\n        &gt;&gt;&gt; sac.data\n        array([2302., 2313., 2345., ..., 2836., 2772., 2723.], shape=(180000,))\n        &gt;&gt;&gt; sac.evla\n        -31.465999603271484\n        &gt;&gt;&gt;\n        ```\n\n        Presenting the data in the above way is *not* compatible with pysmo\n        types. For example, event coordinates are stored in the\n        [`evla`][pysmo.lib.io.SacIO.evla] and [`evlo`][pysmo.lib.io.SacIO.evlo]\n        attributes, which do not match the pysmo [`Location`][pysmo.Location]\n        type. Renaming or aliasing `evla` to `latitude` and `evlo` to\n        `longitude` would solve the problem for the event coordinates, but\n        since the SAC format also specifies station coordinates\n        ([`stla`][pysmo.lib.io.SacIO.stla], [`stlo`][pysmo.lib.io.SacIO.stlo])\n        we still run into compatibility issues.\n\n        In order to map these incompatible attributes to ones that can be\n        used with pysmo types, we use helper classes as a way to access the\n        attributes under different names that *are* compatible with pysmo\n        types:\n\n        ```python\n        &gt;&gt;&gt; # Import the Seismogram type to check if the nested class is compatible:\n        &gt;&gt;&gt; from pysmo import Seismogram\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # First verify that a SAC instance is not a pysmo Seismogram:\n        &gt;&gt;&gt; isinstance(sac, Seismogram)\n        False\n        &gt;&gt;&gt; # The sac.seismogram object is, however:\n        &gt;&gt;&gt; isinstance(sac.seismogram, Seismogram)\n        True\n        &gt;&gt;&gt;\n        ```\n\n        Because the SAC file format defines a large amount of header fields for\n        metadata, it needs to allow for many of these to be optional. Since the\n        helper classes are more specific (and intended to be used with pysmo\n        types), their attributes typically may *not* be [`None`][None]:\n\n        ```python\n        &gt;&gt;&gt; # No error: a SAC file doesn't have to contain event information:\n        &gt;&gt;&gt; sac.evla = None\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Error: the sac.event object may not have attributes set to `None`:\n        &gt;&gt;&gt; sac.event.latitude = None\n        Traceback (most recent call last):\n        ...\n        TypeError: SacEvent.latitude may not be of None type.\n        &gt;&gt;&gt;\n        ```\n\n    Tip:\n        The [`SAC`][pysmo.classes.SAC] class directly inherits from the\n        [`SacIO`][pysmo.lib.io.SacIO] class. This gives access to all\n        SAC headers, ability to load from a file, download data, and so on.\n        Using [`SAC`][pysmo.classes.SAC] is therefore almost always\n        preferred over using [`SacIO`][pysmo.lib.io.SacIO].\n    \"\"\"\n\n    seismogram: SacSeismogram = field(init=False)\n    \"\"\"Access data stored in the SAC object compatible with the [`Seismogram`][pysmo.Seismogram] type.\"\"\"\n\n    station: SacStation = field(init=False)\n    \"\"\"Access data stored in the SAC object compatible with the [`Station`][pysmo.Station] type.\"\"\"\n\n    event: SacEvent = field(init=False)\n    \"\"\"Access data stored in the SAC object compatible with the [`Event`][pysmo.Event] type.\"\"\"\n\n    timestamps: SacTimestamps = field(init=False)\n    \"\"\"Maps a SAC times such as B, E, O, T0-T9 to datetime objects.\"\"\"\n\n    def __attrs_post_init__(self) -&gt; None:\n        self.seismogram = SacSeismogram(parent=self)\n        self.station = SacStation(parent=self)\n        self.event = SacEvent(parent=self)\n        self.timestamps = SacTimestamps(parent=self)\n</code></pre>"},{"location":"api/pysmo/classes/#pysmo.classes.SAC.event","title":"event  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>event: SacEvent = field(init=False)\n</code></pre> <p>Access data stored in the SAC object compatible with the <code>Event</code> type.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SAC.seismogram","title":"seismogram  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seismogram: SacSeismogram = field(init=False)\n</code></pre> <p>Access data stored in the SAC object compatible with the <code>Seismogram</code> type.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SAC.station","title":"station  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>station: SacStation = field(init=False)\n</code></pre> <p>Access data stored in the SAC object compatible with the <code>Station</code> type.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SAC.timestamps","title":"timestamps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timestamps: SacTimestamps = field(init=False)\n</code></pre> <p>Maps a SAC times such as B, E, O, T0-T9 to datetime objects.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacEvent","title":"SacEvent","text":"<p>               Bases: <code>_SacNested</code></p> <p>Helper class for SAC event attributes.</p> <p>The <code>SacEvent</code> class is used to map SAC attributes in a way that matches pysmo types. An instance of this class is created for each new (parent) <code>SAC</code> instance to enable pysmo types compatibility.</p> <p>Examples:</p> <p>Checking if a SacEvent matches the pysmo <code>Event</code> type:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo import Event\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; isinstance(sac.event, Event)\nTrue\n&gt;&gt;&gt;\n</code></pre> Note <p>Not all SAC files contain event information.</p> <p>Attributes:</p> <ul> <li> <code>depth</code>               (<code>float</code>)           \u2013            <p>Event depth in meters.</p> </li> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Event Latitude.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Event Longitude.</p> </li> <li> <code>time</code>               (<code>datetime</code>)           \u2013            <p>Event origin time (UTC).</p> </li> </ul> Source code in <code>pysmo/classes/_sac.py</code> <pre><code>@define(kw_only=True)\nclass SacEvent(_SacNested):\n    \"\"\"Helper class for SAC event attributes.\n\n    The `SacEvent` class is used to map SAC attributes in a way that\n    matches pysmo types. An instance of this class is created for each\n    new (parent) [`SAC`][pysmo.classes.SAC] instance to enable pysmo\n    types compatibility.\n\n    Examples:\n        Checking if a SacEvent matches the pysmo\n        [`Event`][pysmo.Event] type:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo import Event\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; isinstance(sac.event, Event)\n        True\n        &gt;&gt;&gt;\n        ```\n\n    Note:\n        Not all SAC files contain event information.\n    \"\"\"\n\n    @property\n    def latitude(self) -&gt; float:\n        \"\"\"Event Latitude.\"\"\"\n\n        if self._parent.evla is None:\n            raise TypeError(\"SAC object event latitude 'evla' is None.\")\n        return self._parent.evla\n\n    @latitude.setter\n    @value_not_none\n    def latitude(self, value: float) -&gt; None:\n        setattr(self._parent, \"evla\", value)\n\n    @property\n    def longitude(self) -&gt; float:\n        \"\"\"Event Longitude.\"\"\"\n\n        if self._parent.evlo is None:\n            raise TypeError(\"SAC object event longitude 'evlo' is None.\")\n        return self._parent.evlo\n\n    @longitude.setter\n    @value_not_none\n    def longitude(self, value: float) -&gt; None:\n        setattr(self._parent, \"evlo\", value)\n\n    @property\n    def depth(self) -&gt; float:\n        \"\"\"Event depth in meters.\"\"\"\n\n        if self._parent.evdp is None:\n            raise TypeError(\"Sac object event depth 'evdp' is None.\")\n        return self._parent.evdp * 1000\n\n    @depth.setter\n    @value_not_none\n    def depth(self, value: float) -&gt; None:\n        setattr(self._parent, \"evdp\", value / 1000)\n\n    @property\n    def time(self) -&gt; datetime:\n        \"\"\"Event origin time (UTC).\n\n        Important:\n            This property uses the [`SacIO.o`][pysmo.lib.io.SacIO.o] time\n            header. If [`SacIO.iztype`][pysmo.lib.io.SacIO.iztype] is set to\n            `\"o\"`, then this is also the \"Reference time equivalance\" and\n            [`SacIO.o`][pysmo.lib.io.SacIO.o] cannot be changed (it is always\n            0). Changing the [`time`][pysmo.classes.SacEvent.time] directly\n            is not possible if this is is the case.\n        \"\"\"\n\n        event_time = self._get_datetime_from_sac(SAC_TIME_HEADERS.o)\n        if event_time is None:\n            raise TypeError(\"SAC object event time 'o' is None.\")\n        return event_time\n\n    @time.setter\n    @value_not_none\n    def time(self, value: datetime) -&gt; None:\n        self._set_sac_from_datetime(SAC_TIME_HEADERS.o, value)\n</code></pre>"},{"location":"api/pysmo/classes/#pysmo.classes.SacEvent.depth","title":"depth  <code>property</code> <code>writable</code>","text":"<pre><code>depth: float\n</code></pre> <p>Event depth in meters.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacEvent.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Event Latitude.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacEvent.longitude","title":"longitude  <code>property</code> <code>writable</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Event Longitude.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacEvent.time","title":"time  <code>property</code> <code>writable</code>","text":"<pre><code>time: datetime\n</code></pre> <p>Event origin time (UTC).</p> Important <p>This property uses the <code>SacIO.o</code> time header. If <code>SacIO.iztype</code> is set to <code>\"o\"</code>, then this is also the \"Reference time equivalance\" and <code>SacIO.o</code> cannot be changed (it is always 0). Changing the <code>time</code> directly is not possible if this is is the case.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacSeismogram","title":"SacSeismogram","text":"<p>               Bases: <code>_SacNested</code></p> <p>Helper class for SAC seismogram attributes.</p> <p>The <code>SacSeismogram</code> class is used to map SAC attributes in a way that matches pysmo types. An instance of this class is created for each new (parent) <code>SAC</code> instance to enable pysmo types compatibility.</p> <p>Examples:</p> <p>Checking if a SacSeismogram matches the pysmo <code>Seismogram</code> type:</p> <pre><code>&gt;&gt;&gt; from pysmo import Seismogram\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; isinstance(sac.seismogram, Seismogram)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Timing operations in a SAC file use a reference time, and all times (begin time, event origin time, picks, etc.) are relative to this reference time. In pysmo only absolute times are used. The example below shows the <code>begin_time</code> is the absolute time (in UTC) of the first data point:</p> <pre><code>&gt;&gt;&gt; sac.seismogram.begin_time\ndatetime.datetime(2005, 3, 1, 7, 23, 2, 160000, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram begin time.</p> </li> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Seismogram data.</p> </li> <li> <code>delta</code>               (<code>timedelta</code>)           \u2013            <p>Sampling interval.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram end time.</p> </li> </ul> Source code in <code>pysmo/classes/_sac.py</code> <pre><code>@define(kw_only=True)\nclass SacSeismogram(_SacNested):\n    \"\"\"Helper class for SAC seismogram attributes.\n\n    The `SacSeismogram` class is used to map SAC attributes in a way that\n    matches pysmo types. An instance of this class is created for each new\n    (parent) [`SAC`][pysmo.classes.SAC] instance to enable pysmo types\n    compatibility.\n\n    Examples:\n        Checking if a SacSeismogram matches the pysmo\n        [`Seismogram`][pysmo.Seismogram] type:\n\n        ```python\n        &gt;&gt;&gt; from pysmo import Seismogram\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; isinstance(sac.seismogram, Seismogram)\n        True\n        &gt;&gt;&gt;\n        ```\n\n        Timing operations in a SAC file use a reference time, and all times\n        (begin time, event origin time, picks, etc.) are relative to this\n        reference time. In pysmo only absolute times are used. The example\n        below shows the `begin_time` is the absolute time (in UTC) of the first\n        data point:\n\n        ```python\n        &gt;&gt;&gt; sac.seismogram.begin_time\n        datetime.datetime(2005, 3, 1, 7, 23, 2, 160000, tzinfo=datetime.timezone.utc)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    def __len__(self) -&gt; int:\n        return np.size(self.data)\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        \"\"\"Seismogram data.\"\"\"\n\n        return self._parent.data\n\n    @data.setter\n    def data(self, value: np.ndarray) -&gt; None:\n        self._parent.data = value\n\n    @property\n    def delta(self) -&gt; timedelta:\n        \"\"\"Sampling interval.\"\"\"\n        return timedelta(seconds=self._parent.delta)\n\n    @delta.setter\n    def delta(self, value: timedelta) -&gt; None:\n        self._parent.delta = value.total_seconds()\n\n    @property\n    def begin_time(self) -&gt; datetime:\n        \"\"\"Seismogram begin time.\"\"\"\n\n        value = self._get_datetime_from_sac(SAC_TIME_HEADERS.b)\n        if value is None:\n            raise TypeError(\"SAC file has no begin time 'b'.\")\n        return value\n\n    @begin_time.setter\n    @value_not_none\n    def begin_time(self, value: datetime) -&gt; None:\n        self._set_sac_from_datetime(SAC_TIME_HEADERS.b, value)\n\n    @property\n    def end_time(self) -&gt; datetime:\n        \"\"\"Seismogram end time.\"\"\"\n\n        if len(self) == 0:\n            return self.begin_time\n        return self.begin_time + self.delta * (len(self) - 1)\n</code></pre>"},{"location":"api/pysmo/classes/#pysmo.classes.SacSeismogram.begin_time","title":"begin_time  <code>property</code> <code>writable</code>","text":"<pre><code>begin_time: datetime\n</code></pre> <p>Seismogram begin time.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacSeismogram.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Seismogram data.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacSeismogram.delta","title":"delta  <code>property</code> <code>writable</code>","text":"<pre><code>delta: timedelta\n</code></pre> <p>Sampling interval.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacSeismogram.end_time","title":"end_time  <code>property</code>","text":"<pre><code>end_time: datetime\n</code></pre> <p>Seismogram end time.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation","title":"SacStation","text":"<p>               Bases: <code>_SacNested</code></p> <p>Helper class for SAC station attributes.</p> <p>The <code>SacStation</code> class is used to map SAC attributes in a way that matches pysmo types. An instance of this class is created for each new (parent) <code>SAC</code>instance to enable pysmo types compatibility.</p> <p>Examples:</p> <p>Checking if a SacStation matches the pysmo <code>Station</code> type:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo import Station\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; isinstance(sac.station, Station)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>channel</code>               (<code>str</code>)           \u2013            <p>Channel code.</p> </li> <li> <code>elevation</code>               (<code>float | None</code>)           \u2013            <p>Station elevation in meters.</p> </li> <li> <code>latitude</code>               (<code>float</code>)           \u2013            <p>Station latitude.</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>Location code.</p> </li> <li> <code>longitude</code>               (<code>float</code>)           \u2013            <p>Station longitude.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Station name or code.</p> </li> <li> <code>network</code>               (<code>str</code>)           \u2013            <p>Network name or code.</p> </li> </ul> Source code in <code>pysmo/classes/_sac.py</code> <pre><code>@define(kw_only=True)\nclass SacStation(_SacNested):\n    \"\"\"Helper class for SAC station attributes.\n\n    The `SacStation` class is used to map SAC attributes in a way that\n    matches pysmo types. An instance of this class is created for each\n    new (parent) [`SAC`][pysmo.classes.SAC]instance to enable pysmo\n    types compatibility.\n\n    Examples:\n        Checking if a SacStation matches the pysmo\n        [`Station`][pysmo.Station] type:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo import Station\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; isinstance(sac.station, Station)\n        True\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Station name or code.\"\"\"\n\n        if self._parent.kstnm is None:\n            raise TypeError(\"SAC object station name 'kstnm' is None.\")\n        return self._parent.kstnm\n\n    @name.setter\n    @value_not_none\n    def name(self, value: str) -&gt; None:\n        setattr(self._parent, \"kstnm\", value)\n\n    @property\n    def network(self) -&gt; str:\n        \"\"\"Network name or code.\"\"\"\n\n        if self._parent.knetwk is None:\n            raise TypeError(\"SAC object network name 'knetwk' is None.\")\n\n        return self._parent.knetwk\n\n    @network.setter\n    @value_not_none\n    def network(self, value: str) -&gt; None:\n        setattr(self._parent, \"knetwk\", value)\n\n    @property\n    def location(self) -&gt; str:\n        \"\"\"Location code.\"\"\"\n\n        if self._parent.khole is None:\n            raise TypeError(\"SAC object location code 'khole' is None.\")\n        return self._parent.khole\n\n    @location.setter\n    @value_not_none\n    def location(self, value: str) -&gt; None:\n        setattr(self._parent, \"khole\", value)\n\n    @property\n    def channel(self) -&gt; str:\n        \"\"\"Channel code.\"\"\"\n\n        if self._parent.kcmpnm is None:\n            raise TypeError(\"SAC object channel code 'kcmpnm' is None.\")\n        return self._parent.kcmpnm\n\n    @channel.setter\n    @value_not_none\n    def channel(self, value: str) -&gt; None:\n        setattr(self._parent, \"kcmpnm\", value)\n\n    @property\n    def latitude(self) -&gt; float:\n        \"\"\"Station latitude.\"\"\"\n\n        if self._parent.stla is None:\n            raise TypeError(\"SAC object station latitude 'stla' is None.\")\n        return self._parent.stla\n\n    @latitude.setter\n    @value_not_none\n    def latitude(self, value: float) -&gt; None:\n        setattr(self._parent, \"stla\", value)\n\n    @property\n    def longitude(self) -&gt; float:\n        \"\"\"Station longitude.\"\"\"\n\n        if self._parent.stlo is None:\n            raise TypeError(\"SAC object station longitude 'stlo' is None.\")\n        return self._parent.stlo\n\n    @longitude.setter\n    @value_not_none\n    def longitude(self, value: float) -&gt; None:\n        setattr(self._parent, \"stlo\", value)\n\n    @property\n    def elevation(self) -&gt; float | None:\n        \"\"\"Station elevation in meters.\"\"\"\n\n        return self._parent.stel\n\n    @elevation.setter\n    def elevation(self, value: float) -&gt; None:\n        setattr(self._parent, \"stel\", value)\n</code></pre>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.channel","title":"channel  <code>property</code> <code>writable</code>","text":"<pre><code>channel: str\n</code></pre> <p>Channel code.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.elevation","title":"elevation  <code>property</code> <code>writable</code>","text":"<pre><code>elevation: float | None\n</code></pre> <p>Station elevation in meters.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.latitude","title":"latitude  <code>property</code> <code>writable</code>","text":"<pre><code>latitude: float\n</code></pre> <p>Station latitude.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.location","title":"location  <code>property</code> <code>writable</code>","text":"<pre><code>location: str\n</code></pre> <p>Location code.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.longitude","title":"longitude  <code>property</code> <code>writable</code>","text":"<pre><code>longitude: float\n</code></pre> <p>Station longitude.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Station name or code.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacStation.network","title":"network  <code>property</code> <code>writable</code>","text":"<pre><code>network: str\n</code></pre> <p>Network name or code.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps","title":"SacTimestamps","text":"<p>               Bases: <code>_SacNested</code></p> <p>Helper class to access times stored in SAC headers as datetime objects.</p> <p>The <code>SacTimestamps</code> class is used to map SAC attributes in a way that matches pysmo types. An instance of this class is created for each new (parent) <code>SAC</code> instance to enable pysmo types compatibility.</p> <p>Examples:</p> <p>Relative seismogram begin time as a float vs absolute begin time as a <code>datetime</code> object.</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; # SAC header \"B\" as stored in a SAC file\n&gt;&gt;&gt; sac.b\n-63.34000015258789\n&gt;&gt;&gt; # the output above is the number of seconds relative\n&gt;&gt;&gt; # to the reference time and date:\n&gt;&gt;&gt; sac.kzdate , sac.kztime\n('2005-03-01', '07:24:05.500')\n&gt;&gt;&gt; # Accessing the same SAC header via a `SacTimestamps` object\n&gt;&gt;&gt; # yields a corresponding datetime object with the absolute time:\n&gt;&gt;&gt; sac.timestamps.b\ndatetime.datetime(2005, 3, 1, 7, 23, 2, 160000, tzinfo=datetime.timezone.utc)\n&gt;&gt;&gt;\n</code></pre> <p>Changing timestamp values:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; # Original value of the \"B\" SAC header:\n&gt;&gt;&gt; sac.b\n-63.34000015258789\n&gt;&gt;&gt; # Add 30 seconds to the absolute time:\n&gt;&gt;&gt; sac.timestamps.b += timedelta(seconds=30)\n&gt;&gt;&gt; # The relative time also changes by the same amount:\n&gt;&gt;&gt; sac.b\n-33.34\n&gt;&gt;&gt;\n</code></pre> <p>Attributes:</p> <ul> <li> <code>a</code>               (<code>SacTimeConverter</code>)           \u2013            <p>First arrival time.</p> </li> <li> <code>b</code>               (<code>SacTimeConverter</code>)           \u2013            <p>Beginning time of the independent variable.</p> </li> <li> <code>e</code>               (<code>SacTimeConverter</code>)           \u2013            <p>Ending time of the independent variable (read-only).</p> </li> <li> <code>f</code>               (<code>SacTimeConverter</code>)           \u2013            <p>Fini or end of event time.</p> </li> <li> <code>o</code>               (<code>SacTimeConverter</code>)           \u2013            <p>Event origin time.</p> </li> <li> <code>t0</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 0.</p> </li> <li> <code>t1</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 1.</p> </li> <li> <code>t2</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 2.</p> </li> <li> <code>t3</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 3.</p> </li> <li> <code>t4</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 4.</p> </li> <li> <code>t5</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 5.</p> </li> <li> <code>t6</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 6.</p> </li> <li> <code>t7</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 7.</p> </li> <li> <code>t8</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 8.</p> </li> <li> <code>t9</code>               (<code>SacTimeConverter</code>)           \u2013            <p>User defined time pick or marker 9.</p> </li> </ul> Source code in <code>pysmo/classes/_sac.py</code> <pre><code>class SacTimestamps(_SacNested):\n    \"\"\"Helper class to access times stored in SAC headers as datetime objects.\n\n    The `SacTimestamps` class is used to map SAC attributes in a way that\n    matches pysmo types. An instance of this class is created for each\n    new (parent) [`SAC`][pysmo.classes.SAC] instance to enable pysmo\n    types compatibility.\n\n\n    Examples:\n        Relative seismogram begin time as a float vs absolute begin time\n        as a [`datetime`][datetime] object.\n\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; # SAC header \"B\" as stored in a SAC file\n        &gt;&gt;&gt; sac.b\n        -63.34000015258789\n        &gt;&gt;&gt; # the output above is the number of seconds relative\n        &gt;&gt;&gt; # to the reference time and date:\n        &gt;&gt;&gt; sac.kzdate , sac.kztime\n        ('2005-03-01', '07:24:05.500')\n        &gt;&gt;&gt; # Accessing the same SAC header via a `SacTimestamps` object\n        &gt;&gt;&gt; # yields a corresponding datetime object with the absolute time:\n        &gt;&gt;&gt; sac.timestamps.b\n        datetime.datetime(2005, 3, 1, 7, 23, 2, 160000, tzinfo=datetime.timezone.utc)\n        &gt;&gt;&gt;\n        ```\n\n        Changing timestamp values:\n\n        ```python\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; # Original value of the \"B\" SAC header:\n        &gt;&gt;&gt; sac.b\n        -63.34000015258789\n        &gt;&gt;&gt; # Add 30 seconds to the absolute time:\n        &gt;&gt;&gt; sac.timestamps.b += timedelta(seconds=30)\n        &gt;&gt;&gt; # The relative time also changes by the same amount:\n        &gt;&gt;&gt; sac.b\n        -33.34\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    b: SacTimeConverter = SacTimeConverter()\n    \"\"\"Beginning time of the independent variable.\"\"\"\n\n    e: SacTimeConverter = SacTimeConverter(readonly=True)\n    \"\"\"Ending time of the independent variable (read-only).\"\"\"\n\n    o: SacTimeConverter = SacTimeConverter()\n    \"\"\"Event origin time.\"\"\"\n\n    a: SacTimeConverter = SacTimeConverter()\n    \"\"\"First arrival time.\"\"\"\n\n    f: SacTimeConverter = SacTimeConverter()\n    \"\"\"Fini or end of event time.\"\"\"\n\n    t0: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 0.\"\"\"\n\n    t1: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 1.\"\"\"\n\n    t2: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 2.\"\"\"\n\n    t3: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 3.\"\"\"\n\n    t4: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 4.\"\"\"\n\n    t5: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 5.\"\"\"\n\n    t6: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 6.\"\"\"\n\n    t7: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 7.\"\"\"\n\n    t8: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 8.\"\"\"\n\n    t9: SacTimeConverter = SacTimeConverter()\n    \"\"\"User defined time pick or marker 9.\"\"\"\n</code></pre>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>First arrival time.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.b","title":"b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>Beginning time of the independent variable.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.e","title":"e  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>e: SacTimeConverter = SacTimeConverter(readonly=True)\n</code></pre> <p>Ending time of the independent variable (read-only).</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.f","title":"f  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>f: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>Fini or end of event time.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.o","title":"o  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>Event origin time.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t0","title":"t0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t0: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 0.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t1","title":"t1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t1: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 1.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t2","title":"t2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t2: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 2.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t3","title":"t3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t3: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 3.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t4","title":"t4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t4: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 4.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t5","title":"t5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t5: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 5.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t6","title":"t6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t6: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 6.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t7","title":"t7  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t7: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 7.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t8","title":"t8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t8: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 8.</p>"},{"location":"api/pysmo/classes/#pysmo.classes.SacTimestamps.t9","title":"t9  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t9: SacTimeConverter = SacTimeConverter()\n</code></pre> <p>User defined time pick or marker 9.</p>"},{"location":"api/pysmo/functions/","title":"Index","text":""},{"location":"api/pysmo/functions/#pysmo.functions","title":"pysmo.functions","text":"<p>Simple operations using pysmo types.</p> <p>This module provides functions that perform common operations using pysmo types (mostly <code>Seismogram</code>). They are meant to be building blocks that can be used to construct more complex processing algorithms.</p> <p>Many functions have a <code>clone</code> argument that controls whether the function should operate on the input directly, or first create a clone of it (using <code>deepcopy</code>) and return the clone after using it for the the function. For example:</p> <pre><code>&gt;&gt;&gt; from pysmo.functions import resample\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; new_delta = sac_seis.delta * 2\n&gt;&gt;&gt;\n&gt;&gt;&gt; # create a clone and modify data in clone instead of sac_seis:\n&gt;&gt;&gt; new_sac_seis = resample(sac_seis, new_delta, clone=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # modify data in sac_seis directly:\n&gt;&gt;&gt; resample(sac_seis, new_delta)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # because the deepcopy operation can be computationaly expensive,\n&gt;&gt;&gt; # you should NOT use the following pattern:\n&gt;&gt;&gt; sac_seis = resample(sac_seis, new_delta, clone=True)\n&gt;&gt;&gt;\n</code></pre> Hint <p>Additional functions may be found in <code>pysmo.tools</code>.</p> <p>Functions:</p> <ul> <li> <code>clone_to_mini</code>             \u2013              <p>Create a new instance of a Mini class from a matching other one.</p> </li> <li> <code>copy_from_mini</code>             \u2013              <p>Copy attributes from a Mini instance to matching other one.</p> </li> <li> <code>crop</code>             \u2013              <p>Shorten a seismogram by providing new begin and end times.</p> </li> <li> <code>detrend</code>             \u2013              <p>Remove linear and/or constant trends from a seismogram.</p> </li> <li> <code>normalize</code>             \u2013              <p>Normalize a seismogram with its absolute max value.</p> </li> <li> <code>pad</code>             \u2013              <p>Pad seismogram data.</p> </li> <li> <code>resample</code>             \u2013              <p>Resample Seismogram data using the Fourier method.</p> </li> <li> <code>taper</code>             \u2013              <p>Apply a symetric taper to the ends of a Seismogram.</p> </li> <li> <code>time2index</code>             \u2013              <p>Retuns data index corresponding to a given time.</p> </li> </ul>"},{"location":"api/pysmo/functions/#pysmo.functions.clone_to_mini","title":"clone_to_mini","text":"<pre><code>clone_to_mini(\n    mini_cls: type[clone_to_mini[TMini]],\n    source: _AnyProto,\n    update: dict | None = None,\n) -&gt; clone_to_mini[TMini]\n</code></pre> <p>Create a new instance of a Mini class from a matching other one.</p> <p>This function is creates a clone of an exising class by copying the attributes defined in <code>mini_cls</code> from the source to the target. Attributes only present in the source object are ignored, potentially resulting in a smaller and more performant object.</p> <p>If the source instance is missing an attribute for which a default is defined in the target class, then that default value for that attribute is used.</p> <p>Parameters:</p> <ul> <li> <code>mini_cls</code>               (<code>type[clone_to_mini[TMini]]</code>)           \u2013            <p>The type of Mini class to create.</p> </li> <li> <code>source</code>               (<code>_AnyProto</code>)           \u2013            <p>The instance to clone (must contain all attributes present in <code>mini_cls</code>).</p> </li> <li> <code>update</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Update or add attributes in the returned <code>mini_cls</code> instance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>clone_to_mini[TMini]</code>           \u2013            <p>A new Mini instance type mini_cls.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>If the <code>source</code> instance does not contain all attributes in <code>mini_cls</code> (unless they are provided with the <code>update</code> keyword argument).</p> </li> </ul> <p>Examples:</p> <p>Create a <code>MiniSeismogram</code> from a <code>SacSeismogram</code> instance with a new <code>begin_time</code>.</p> <pre><code>&gt;&gt;&gt; from pysmo.functions import clone_to_mini\n&gt;&gt;&gt; from pysmo import MiniSeismogram\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from datetime import datetime, timezone\n&gt;&gt;&gt; now = datetime.now(timezone.utc)\n&gt;&gt;&gt; sac_seismogram = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; mini_seismogram = clone_to_mini(MiniSeismogram, sac_seismogram, update={\"begin_time\": now})\n&gt;&gt;&gt; all(sac_seismogram.data == mini_seismogram.data)\nTrue\n&gt;&gt;&gt; mini_seismogram.begin_time == now\nTrue\n&gt;&gt;&gt;\n</code></pre> See Also <p><code>copy_from_mini</code>: Copy attributes from a Mini instance to matching other one.</p> Source code in <code>pysmo/functions/_utils.py</code> <pre><code>def clone_to_mini[TMini: _AnyMini](\n    mini_cls: type[TMini], source: \"_AnyProto\", update: dict | None = None\n) -&gt; TMini:\n    \"\"\"Create a new instance of a Mini class from a matching other one.\n\n    This function is creates a clone of an exising class by\n    [copying][copy.copy] the attributes defined in `mini_cls` from the source\n    to the target. Attributes only present in the source object are ignored,\n    potentially resulting in a smaller and more performant object.\n\n    If the source instance is missing an attribute for which a default is\n    defined in the target class, then that default value for that attribute is\n    used.\n\n    Parameters:\n        mini_cls: The type of Mini class to create.\n        source: The instance to clone (must contain all attributes present\n            in `mini_cls`).\n        update: Update or add attributes in the returned `mini_cls` instance.\n\n    Returns:\n        A new Mini instance type mini_cls.\n\n    Raises:\n        AttributeError: If the `source` instance does not contain all\n            attributes in `mini_cls` (unless they are provided with the\n            `update` keyword argument).\n\n    Examples:\n        Create a [`MiniSeismogram`][pysmo.MiniSeismogram] from a\n        [`SacSeismogram`][pysmo.classes.SacSeismogram] instance with\n        a new `begin_time`.\n\n        ```python\n        &gt;&gt;&gt; from pysmo.functions import clone_to_mini\n        &gt;&gt;&gt; from pysmo import MiniSeismogram\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from datetime import datetime, timezone\n        &gt;&gt;&gt; now = datetime.now(timezone.utc)\n        &gt;&gt;&gt; sac_seismogram = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; mini_seismogram = clone_to_mini(MiniSeismogram, sac_seismogram, update={\"begin_time\": now})\n        &gt;&gt;&gt; all(sac_seismogram.data == mini_seismogram.data)\n        True\n        &gt;&gt;&gt; mini_seismogram.begin_time == now\n        True\n        &gt;&gt;&gt;\n        ```\n\n    Tip: See Also\n        [`copy_from_mini`][pysmo.functions.copy_from_mini]: Copy attributes\n        from a Mini instance to matching other one.\n    \"\"\"\n\n    update = update or dict()\n\n    if all(\n        map(\n            lambda x: hasattr(source, x.name)\n            or x.name in update\n            or x.default is not NOTHING,\n            fields(mini_cls),\n        )\n    ):\n        clone_dict = {\n            attr.name: (\n                update[attr.name]\n                if attr.name in update\n                else copy(getattr(source, attr.name, attr.default))\n            )\n            for attr in fields(mini_cls)\n        }\n        # TODO: why do we need cast here for mypy?\n        return cast(TMini, mini_cls(**clone_dict))\n\n    raise AttributeError(\n        f\"Unable to create clone: {source} not compatible with {mini_cls}.\"\n    )\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.copy_from_mini","title":"copy_from_mini","text":"<pre><code>copy_from_mini(\n    source: _AnyMini,\n    target: _AnyProto,\n    update: dict | None = None,\n) -&gt; None\n</code></pre> <p>Copy attributes from a Mini instance to matching other one.</p> <p>This function copies all attributes in the <code>source</code> Mini class instance to a compatible <code>target</code> instance.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>_AnyMini</code>)           \u2013            <p>The Mini instance to copy attributes from.</p> </li> <li> <code>target</code>               (<code>_AnyProto</code>)           \u2013            <p>Compatible target instance.</p> </li> <li> <code>update</code>               (<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Update or add attributes in the target instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>If the <code>target</code> instance does not contain all attributes in the <code>source</code> instance (unless they are provided with the <code>update</code> keyword argument).</p> </li> </ul> See Also <p><code>clone_to_mini</code>: Create a new instance of a Mini class from a matching other one.</p> Source code in <code>pysmo/functions/_utils.py</code> <pre><code>def copy_from_mini(\n    source: \"_AnyMini\", target: \"_AnyProto\", update: dict | None = None\n) -&gt; None:\n    \"\"\"Copy attributes from a Mini instance to matching other one.\n\n    This function [copies][copy.copy] all attributes in the `source` Mini class\n    instance to a compatible `target` instance.\n\n    Parameters:\n        source: The Mini instance to copy attributes from.\n        target: Compatible target instance.\n        update: Update or add attributes in the target instance.\n\n    Raises:\n        AttributeError: If the `target` instance does not contain all\n            attributes in the `source` instance (unless they are\n            provided with the `update` keyword argument).\n\n    Tip: See Also\n        [`clone_to_mini`][pysmo.functions.clone_to_mini]: Create a new\n        instance of a Mini class from a matching other one.\n    \"\"\"\n\n    update = update or dict()\n\n    attributes = unstructure(source).keys() | set()\n    attributes.update(update.keys())\n\n    if all(map(lambda x: hasattr(target, x), attributes)):\n        for attribute in attributes:\n            if attribute in update:\n                setattr(target, attribute, update[attribute])\n            else:\n                setattr(target, attribute, copy(getattr(source, attribute)))\n    else:\n        raise AttributeError(\n            f\"Unable to copy to target: {type(target)} not compatible with {type(source)}.\"\n        )\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.crop","title":"crop","text":"<pre><code>crop(\n    seismogram: crop[T],\n    begin_time: datetime,\n    end_time: datetime,\n    clone: bool = False,\n) -&gt; None | crop[T]\n</code></pre> <p>Shorten a seismogram by providing new begin and end times.</p> <p>This function calculates the indices corresponding to the provided new begin and end times using <code>time2index</code>, then slices the seismogram <code>data</code> array accordingly and updates the <code>begin_time</code>.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>crop[T]</code>)           \u2013            <p><code>Seismogram</code> object.</p> </li> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>New begin time.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>New end time.</p> </li> <li> <code>clone</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Operate on a clone of the input seismogram.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | crop[T]</code>           \u2013            <p>Cropped <code>Seismogram</code> object if called with <code>clone=True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If new begin time is after new end time.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.functions import crop\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; new_begin_time = sac_seis.begin_time + timedelta(seconds=10)\n&gt;&gt;&gt; new_end_time = sac_seis.end_time - timedelta(seconds=10)\n&gt;&gt;&gt; crop(sac_seis, new_begin_time, new_end_time)\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def crop[T: Seismogram](\n    seismogram: T, begin_time: datetime, end_time: datetime, clone: bool = False\n) -&gt; None | T:\n    \"\"\"Shorten a seismogram by providing new begin and end times.\n\n    This function calculates the indices corresponding to the provided new\n    begin and end times using [`time2index`][pysmo.functions.time2index], then\n    slices the seismogram `data` array accordingly and updates the\n    `begin_time`.\n\n    Parameters:\n        seismogram: [`Seismogram`][pysmo.Seismogram] object.\n        begin_time: New begin time.\n        end_time: New end time.\n        clone: Operate on a clone of the input seismogram.\n\n    Returns:\n        Cropped [`Seismogram`][pysmo.Seismogram] object if called with `clone=True`.\n\n    Raises:\n        ValueError: If new begin time is after new end time.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.functions import crop\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; new_begin_time = sac_seis.begin_time + timedelta(seconds=10)\n        &gt;&gt;&gt; new_end_time = sac_seis.end_time - timedelta(seconds=10)\n        &gt;&gt;&gt; crop(sac_seis, new_begin_time, new_end_time)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    if begin_time &gt; end_time:\n        raise ValueError(\"New begin_time cannot be after new end_time\")\n\n    start_index = time2index(seismogram, begin_time)\n    end_index = time2index(seismogram, end_time)\n\n    if clone is True:\n        seismogram = deepcopy(seismogram)\n\n    seismogram.data = seismogram.data[start_index : end_index + 1]\n    seismogram.begin_time += seismogram.delta * start_index\n\n    if clone is True:\n        return seismogram\n\n    return None\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.detrend","title":"detrend","text":"<pre><code>detrend(\n    seismogram: detrend[T], clone: bool = False\n) -&gt; None | detrend[T]\n</code></pre> <p>Remove linear and/or constant trends from a seismogram.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>detrend[T]</code>)           \u2013            <p>Seismogram object.</p> </li> <li> <code>clone</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Operate on a clone of the input seismogram.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | detrend[T]</code>           \u2013            <p>Detrended <code>Seismogram</code> object if called with <code>clone=True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import pytest\n&gt;&gt;&gt; from pysmo.functions import detrend\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; 0 == pytest.approx(np.mean(sac_seis.data), abs=1e-11)\nnp.False_\n&gt;&gt;&gt; detrend(sac_seis)\n&gt;&gt;&gt; 0 == pytest.approx(np.mean(sac_seis.data), abs=1e-11)\nnp.True_\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def detrend[T: Seismogram](seismogram: T, clone: bool = False) -&gt; None | T:\n    \"\"\"Remove linear and/or constant trends from a seismogram.\n\n    Parameters:\n        seismogram: Seismogram object.\n        clone: Operate on a clone of the input seismogram.\n\n    Returns:\n        Detrended [`Seismogram`][pysmo.Seismogram] object if called with `clone=True`.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; import pytest\n        &gt;&gt;&gt; from pysmo.functions import detrend\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; 0 == pytest.approx(np.mean(sac_seis.data), abs=1e-11)\n        np.False_\n        &gt;&gt;&gt; detrend(sac_seis)\n        &gt;&gt;&gt; 0 == pytest.approx(np.mean(sac_seis.data), abs=1e-11)\n        np.True_\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    if clone is True:\n        seismogram = deepcopy(seismogram)\n\n    seismogram.data = scipy.signal.detrend(seismogram.data)\n\n    if clone is True:\n        return seismogram\n\n    return None\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.normalize","title":"normalize","text":"<pre><code>normalize(\n    seismogram: normalize[T],\n    t1: datetime | None = None,\n    t2: datetime | None = None,\n    clone: bool = False,\n) -&gt; None | normalize[T]\n</code></pre> <p>Normalize a seismogram with its absolute max value.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>normalize[T]</code>)           \u2013            <p>Seismogram object.</p> </li> <li> <code>t1</code>               (<code>datetime | None</code>, default:                   <code>None</code> )           \u2013            <p>Optionally restrict searching of maximum to time after this time.</p> </li> <li> <code>t2</code>               (<code>datetime | None</code>, default:                   <code>None</code> )           \u2013            <p>Optionally restrict searching of maximum to time before this time.</p> </li> <li> <code>clone</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Operate on a clone of the input seismogram.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | normalize[T]</code>           \u2013            <p>Normalized <code>Seismogram</code> object if <code>clone=True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from pysmo.functions import normalize\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; normalize(sac_seis)\n&gt;&gt;&gt; -1 &lt;= np.max(sac_seis.data) &lt;= 1\nnp.True_\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def normalize[T: Seismogram](\n    seismogram: T,\n    t1: datetime | None = None,\n    t2: datetime | None = None,\n    clone: bool = False,\n) -&gt; None | T:\n    \"\"\"Normalize a seismogram with its absolute max value.\n\n    Parameters:\n        seismogram: Seismogram object.\n        t1: Optionally restrict searching of maximum to time after this time.\n        t2: Optionally restrict searching of maximum to time before this time.\n        clone: Operate on a clone of the input seismogram.\n\n    Returns:\n        Normalized [`Seismogram`][pysmo.Seismogram] object if `clone=True`.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from pysmo.functions import normalize\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; normalize(sac_seis)\n        &gt;&gt;&gt; -1 &lt;= np.max(sac_seis.data) &lt;= 1\n        np.True_\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    if clone is True:\n        seismogram = deepcopy(seismogram)\n\n    start_index, end_index = None, None\n\n    if t1 is not None:\n        start_index = time2index(seismogram, t1)\n\n    if t2 is not None:\n        end_index = time2index(seismogram, t2)\n\n    seismogram.data /= np.max(np.abs(seismogram.data[start_index:end_index]))\n\n    if clone is True:\n        return seismogram\n\n    return None\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.pad","title":"pad","text":"<pre><code>pad(\n    seismogram: pad[T],\n    begin_time: datetime,\n    end_time: datetime,\n    mode: _ModeKind | _ModeFunc = \"constant\",\n    clone: bool = False,\n    **kwargs: Any\n) -&gt; None | pad[T]\n</code></pre> <p>Pad seismogram data.</p> <p>This function calculates the indices corresponding to the provided new begin and end times using <code>time2index</code>, then pads the <code>data</code> array using <code>numpy.pad</code> and updates the <code>begin_time</code>. Note that the actual begin and end times are set by indexing, so they may be slightly different than the provided input begin and end times.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>pad[T]</code>)           \u2013            <p><code>Seismogram</code> object.</p> </li> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>New begin time.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>New end time.</p> </li> <li> <code>mode</code>               (<code>_ModeKind | _ModeFunc</code>, default:                   <code>'constant'</code> )           \u2013            <p>Pad mode to use (see <code>numpy.pad</code> for all modes).</p> </li> <li> <code>clone</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Operate on a clone of the input seismogram.</p> </li> <li> <code>kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Keyword arguments to pass to <code>numpy.pad</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | pad[T]</code>           \u2013            <p>Padded <code>Seismogram</code> object if called with <code>clone=True</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If new begin time is after new end time.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.functions import pad\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; original_length = len(sac_seis)\n&gt;&gt;&gt; sac_seis.data\narray([2302., 2313., 2345., ..., 2836., 2772., 2723.], shape=(180000,))\n&gt;&gt;&gt; new_begin_time = sac_seis.begin_time - timedelta(seconds=10)\n&gt;&gt;&gt; new_end_time = sac_seis.end_time + timedelta(seconds=10)\n&gt;&gt;&gt; pad(sac_seis, new_begin_time, new_end_time)\n&gt;&gt;&gt; len(sac_seis) == original_length + 20 * (1 / sac_seis.delta.total_seconds())\nTrue\n&gt;&gt;&gt; sac_seis.data\narray([0., 0., 0., ..., 0., 0., 0.], shape=(181000,))\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def pad[T: Seismogram](\n    seismogram: T,\n    begin_time: datetime,\n    end_time: datetime,\n    mode: \"_ModeKind | _ModeFunc\" = \"constant\",\n    clone: bool = False,\n    **kwargs: Any,\n) -&gt; None | T:\n    \"\"\"Pad seismogram data.\n\n    This function calculates the indices corresponding to the provided new\n    begin and end times using [`time2index`][pysmo.functions.time2index], then\n    pads the [`data`][pysmo.Seismogram.data] array using\n    [`numpy.pad`][numpy.pad] and updates the\n    [`begin_time`][pysmo.Seismogram.begin_time]. Note that the actual begin and\n    end times are set by indexing, so they may be slightly different than the\n    provided input begin and end times.\n\n    Parameters:\n        seismogram: [`Seismogram`][pysmo.Seismogram] object.\n        begin_time: New begin time.\n        end_time: New end time.\n        mode: Pad mode to use (see [`numpy.pad`][numpy.pad] for all modes).\n        clone: Operate on a clone of the input seismogram.\n        kwargs: Keyword arguments to pass to [`numpy.pad`][numpy.pad].\n\n    Returns:\n        Padded [`Seismogram`][pysmo.Seismogram] object if called with `clone=True`.\n\n    Raises:\n        ValueError: If new begin time is after new end time.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.functions import pad\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; original_length = len(sac_seis)\n        &gt;&gt;&gt; sac_seis.data\n        array([2302., 2313., 2345., ..., 2836., 2772., 2723.], shape=(180000,))\n        &gt;&gt;&gt; new_begin_time = sac_seis.begin_time - timedelta(seconds=10)\n        &gt;&gt;&gt; new_end_time = sac_seis.end_time + timedelta(seconds=10)\n        &gt;&gt;&gt; pad(sac_seis, new_begin_time, new_end_time)\n        &gt;&gt;&gt; len(sac_seis) == original_length + 20 * (1 / sac_seis.delta.total_seconds())\n        True\n        &gt;&gt;&gt; sac_seis.data\n        array([0., 0., 0., ..., 0., 0., 0.], shape=(181000,))\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    if begin_time &gt; end_time:\n        raise ValueError(\"New begin_time cannot be after new end_time\")\n\n    start_index = time2index(\n        seismogram, begin_time, method=\"floor\", allow_out_of_bounds=True\n    )\n    end_index = time2index(\n        seismogram, end_time, method=\"ceil\", allow_out_of_bounds=True\n    )\n\n    if clone is True:\n        seismogram = deepcopy(seismogram)\n\n    pad_before = max(0, -start_index)\n    pad_after = max(0, end_index - (len(seismogram) - 1))\n\n    if pad_before &gt; 0 or pad_after &gt; 0:\n        seismogram.data = np.pad(\n            seismogram.data,\n            pad_width=(pad_before, pad_after),\n            mode=mode,\n            **kwargs,\n        )\n        seismogram.begin_time += seismogram.delta * min(0, start_index)\n\n    if clone is True:\n        return seismogram\n\n    return None\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.resample","title":"resample","text":"<pre><code>resample(\n    seismogram: resample[T],\n    delta: timedelta,\n    clone: bool = False,\n) -&gt; None | resample[T]\n</code></pre> <p>Resample Seismogram data using the Fourier method.</p> <p>This function uses [<code>scipy.resample</code>][scipy.signal.resample] to resample the data to a new sampling interval. If the new sampling interval is identical to the current one, no action is taken.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>resample[T]</code>)           \u2013            <p>Seismogram object.</p> </li> <li> <code>delta</code>               (<code>timedelta</code>)           \u2013            <p>New sampling interval.</p> </li> <li> <code>clone</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Operate on a clone of the input seismogram.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | resample[T]</code>           \u2013            <p>Resampled <code>Seismogram</code> object if called with <code>clone=True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.functions import resample\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; len(sac_seis)\n180000\n&gt;&gt;&gt; original_delta = sac_seis.delta\n&gt;&gt;&gt; new_delta = original_delta * 2\n&gt;&gt;&gt; resample(sac_seis, new_delta)\n&gt;&gt;&gt; len(sac_seis)\n90000\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def resample[T: Seismogram](\n    seismogram: T, delta: timedelta, clone: bool = False\n) -&gt; None | T:\n    \"\"\"Resample Seismogram data using the Fourier method.\n\n    This function uses [`scipy.resample`][scipy.signal.resample] to resample\n    the data to a new sampling interval. If the new sampling interval is\n    identical to the current one, no action is taken.\n\n    Parameters:\n        seismogram: Seismogram object.\n        delta: New sampling interval.\n        clone: Operate on a clone of the input seismogram.\n\n    Returns:\n        Resampled [`Seismogram`][pysmo.Seismogram] object if called with `clone=True`.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.functions import resample\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; len(sac_seis)\n        180000\n        &gt;&gt;&gt; original_delta = sac_seis.delta\n        &gt;&gt;&gt; new_delta = original_delta * 2\n        &gt;&gt;&gt; resample(sac_seis, new_delta)\n        &gt;&gt;&gt; len(sac_seis)\n        90000\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    if clone is True:\n        seismogram = deepcopy(seismogram)\n\n    if delta != seismogram.delta:\n        npts = int(len(seismogram) * seismogram.delta / delta)\n        seismogram.data = scipy.signal.resample(seismogram.data, npts)\n        seismogram.delta = delta\n\n    if clone is True:\n        return seismogram\n\n    return None\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.taper","title":"taper","text":"<pre><code>taper(\n    seismogram: taper[T],\n    taper_width: timedelta | float,\n    taper_method: Literal[\n        \"bartlett\",\n        \"blackman\",\n        \"hamming\",\n        \"hanning\",\n        \"kaiser\",\n    ] = \"hanning\",\n    beta: float = 14.0,\n    left: bool = True,\n    right: bool = True,\n    clone: bool = False,\n) -&gt; None | taper[T]\n</code></pre> <p>Apply a symetric taper to the ends of a Seismogram.</p> <p>The <code>taper()</code> function applies a taper to the data at one or both ends of a <code>Seismogram</code> object. The width of this taper can be provided as either positive <code>timedelta</code> or as a fraction of the total seismogram length. In both cases the total width of the taper (i.e. left and right side combined) should not exceed the length of the seismogram.</p> <p>Different methods for calculating the shape of the taper may be specified. They are all derived from the corresponding <code>numpy</code> window functions:</p> <ul> <li><code>numpy.bartlett</code></li> <li><code>numpy.blackman</code></li> <li><code>numpy.hamming</code></li> <li><code>numpy.hanning</code></li> <li><code>numpy.kaiser</code></li> </ul> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>taper[T]</code>)           \u2013            <p>Seismogram object.</p> </li> <li> <code>taper_width</code>               (<code>timedelta | float</code>)           \u2013            <p>With of the taper to use.</p> </li> <li> <code>taper_method</code>               (<code>Literal['bartlett', 'blackman', 'hamming', 'hanning', 'kaiser']</code>, default:                   <code>'hanning'</code> )           \u2013            <p>Taper method to use.</p> </li> <li> <code>beta</code>               (<code>float</code>, default:                   <code>14.0</code> )           \u2013            <p>beta value for the Kaiser window function (ignored for other methods).</p> </li> <li> <code>left</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Apply taper to the left side of the seismogram.</p> </li> <li> <code>right</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Apply taper to the right side of the seismogram.</p> </li> <li> <code>clone</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Operate on a clone of the input seismogram.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None | taper[T]</code>           \u2013            <p>Tapered <code>Seismogram</code> object if called with <code>clone=True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.functions import taper, detrend\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; detrend(sac_seis)\n&gt;&gt;&gt; sac_seis.data\narray([ 95.59652208, 106.59521819, 138.59391429, ..., 394.90004126,\n       330.89873737, 281.89743348], shape=(180000,))\n&gt;&gt;&gt; taper(sac_seis, 0.1)\n&gt;&gt;&gt; sac_seis.data\narray([0.00000000e+00, 8.11814104e-07, 4.22204657e-06, ...,\n       1.20300114e-05, 2.52007798e-06, 0.00000000e+00], shape=(180000,))\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def taper[T: Seismogram](\n    seismogram: T,\n    taper_width: timedelta | float,\n    taper_method: Literal[\n        \"bartlett\", \"blackman\", \"hamming\", \"hanning\", \"kaiser\"\n    ] = \"hanning\",\n    beta: float = 14.0,\n    left: bool = True,\n    right: bool = True,\n    clone: bool = False,\n) -&gt; None | T:\n    \"\"\"Apply a symetric taper to the ends of a Seismogram.\n\n    The [`taper()`][pysmo.functions.taper] function applies a taper to the data\n    at one or both ends of a [`Seismogram`][pysmo.Seismogram] object. The width\n    of this taper can be provided as either positive\n    [`timedelta`][datetime.timedelta] or as a fraction of the total seismogram\n    length. In both cases the total width of the taper (i.e. left and right\n    side combined) should not exceed the length of the seismogram.\n\n    Different methods for calculating the shape of the taper may be specified.\n    They are all derived from the corresponding `numpy` window functions:\n\n    - [`numpy.bartlett`][numpy.bartlett]\n    - [`numpy.blackman`][numpy.blackman]\n    - [`numpy.hamming`][numpy.hamming]\n    - [`numpy.hanning`][numpy.hanning]\n    - [`numpy.kaiser`][numpy.kaiser]\n\n    Parameters:\n        seismogram: Seismogram object.\n        taper_width: With of the taper to use.\n        taper_method: Taper method to use.\n        beta: beta value for the Kaiser window function (ignored for other methods).\n        left: Apply taper to the left side of the seismogram.\n        right: Apply taper to the right side of the seismogram.\n        clone: Operate on a clone of the input seismogram.\n\n    Returns:\n        Tapered [`Seismogram`][pysmo.Seismogram] object if called with `clone=True`.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.functions import taper, detrend\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; sac_seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; detrend(sac_seis)\n        &gt;&gt;&gt; sac_seis.data\n        array([ 95.59652208, 106.59521819, 138.59391429, ..., 394.90004126,\n               330.89873737, 281.89743348], shape=(180000,))\n        &gt;&gt;&gt; taper(sac_seis, 0.1)\n        &gt;&gt;&gt; sac_seis.data\n        array([0.00000000e+00, 8.11814104e-07, 4.22204657e-06, ...,\n               1.20300114e-05, 2.52007798e-06, 0.00000000e+00], shape=(180000,))\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    def calc_window_data(window_length: int) -&gt; np.ndarray:\n        if taper_method == \"bartlett\":\n            return np.bartlett(window_length)\n        elif taper_method == \"blackman\":\n            return np.blackman(window_length)\n        elif taper_method == \"hamming\":\n            return np.hamming(window_length)\n        elif taper_method == \"hanning\":\n            return np.hanning(window_length)\n        elif taper_method == \"kaiser\":\n            return np.kaiser(window_length, beta)\n\n    @singledispatch\n    def calc_samples(taper_width: Any) -&gt; int:\n        raise TypeError(f\"Unsupported type for 'taper_width': {type(taper_width)}\")\n\n    @calc_samples.register(float)\n    def _(taper_width: float) -&gt; int:\n        return floor(len(seismogram) * taper_width)\n\n    @calc_samples.register(timedelta)\n    def _(taper_width: timedelta) -&gt; int:\n        return floor(taper_width / seismogram.delta) + 1\n\n    if clone is True:\n        seismogram = deepcopy(seismogram)\n\n    if left is False and right is False:\n        return seismogram if clone is True else None\n\n    nsamples = calc_samples(taper_width)\n\n    if nsamples * (left + right) &gt; len(seismogram):\n        raise ValueError(\n            \"'taper_width' is too large. Total taper width may exceed the length of the seismogram.\"\n        )\n\n    if nsamples &gt; 0:\n        taper_data = np.ones(len(seismogram))\n        window = calc_window_data(nsamples * 2)\n        if left is True:\n            taper_data[:nsamples] = window[:nsamples]\n        if right is True:\n            taper_data[-nsamples:] = window[-nsamples:]\n        seismogram.data *= taper_data\n\n    if clone is True:\n        return seismogram\n\n    return None\n</code></pre>"},{"location":"api/pysmo/functions/#pysmo.functions.time2index","title":"time2index","text":"<pre><code>time2index(\n    seismogram: Seismogram,\n    time: datetime,\n    method: Literal[\"ceil\", \"floor\", \"round\"] = \"round\",\n    allow_out_of_bounds: bool = False,\n) -&gt; int\n</code></pre> <p>Retuns data index corresponding to a given time.</p> <p>This function converts time to index of a seismogram's data array. In most cases the time will not have an exact match in the data array. This function allows choosing how to select the index to return when that is the case with the method parameter:</p> <ul> <li>round: round to nearest index.</li> <li>ceil: always round up to next higher index.</li> <li>floor: always round down to next lower index.</li> </ul> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>Seismogram</code>)           \u2013            <p>Seismogram object.</p> </li> <li> <code>time</code>               (<code>datetime</code>)           \u2013            <p>Time to convert to index.</p> </li> <li> <code>method</code>               (<code>Literal['ceil', 'floor', 'round']</code>, default:                   <code>'round'</code> )           \u2013            <p>Method to use for selecting the index to return.</p> </li> <li> <code>allow_out_of_bounds</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, allow returning an index that is outside has no corresponding data point in the seismogram.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Index of the sample corresponding to the given time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the calculated index is out of bounds and <code>allow_out_of_bounds</code> is not set to True.</p> </li> </ul> Source code in <code>pysmo/functions/_seismogram.py</code> <pre><code>def time2index(\n    seismogram: Seismogram,\n    time: datetime,\n    method: Literal[\"ceil\", \"floor\", \"round\"] = \"round\",\n    allow_out_of_bounds: bool = False,\n) -&gt; int:\n    \"\"\"Retuns data index corresponding to a given time.\n\n    This function converts time to index of a seismogram's data array. In most\n    cases the time will not have an exact match in the data array. This\n    function allows choosing how to select the index to return when that is\n    the case with the method parameter:\n\n    - round: round to nearest index.\n    - ceil: always round up to next higher index.\n    - floor: always round down to next lower index.\n\n    Parameters:\n        seismogram: Seismogram object.\n        time: Time to convert to index.\n        method: Method to use for selecting the index to return.\n        allow_out_of_bounds: If True, allow returning an index that is outside\n            has no corresponding data point in the seismogram.\n\n    Returns:\n        Index of the sample corresponding to the given time.\n\n    Raises:\n        ValueError: If the calculated index is out of bounds and\n            `allow_out_of_bounds` is not set to True.\n    \"\"\"\n\n    if method == \"ceil\":\n        index = np.ceil((time - seismogram.begin_time) / seismogram.delta)\n\n    elif method == \"floor\":\n        index = np.floor((time - seismogram.begin_time) / seismogram.delta)\n\n    elif method == \"round\":\n        index = np.round((time - seismogram.begin_time) / seismogram.delta)\n\n    else:\n        raise ValueError(\n            \"Invalid method provided. Valid options are 'ceil', 'floor', and 'round'.\"\n        )\n\n    if 0 &lt;= index &lt; len(seismogram) or allow_out_of_bounds is True:\n        return int(index)\n\n    raise ValueError(f\"Invalid time provided, calculated {index=} is out of bounds.\")\n</code></pre>"},{"location":"api/pysmo/lib/","title":"Index","text":""},{"location":"api/pysmo/lib/#pysmo.lib","title":"pysmo.lib","text":"<p>Pysmo library module.</p> <p>Modules:</p> <ul> <li> <code>decorators</code>           \u2013            <p>Decorators for pysmo.</p> </li> <li> <code>defaults</code>           \u2013            <p>Defaults for pysmo functions/classes.</p> </li> <li> <code>io</code>           \u2013            <p>I/O classes.</p> </li> <li> <code>typing</code>           \u2013            <p>Typing related items.</p> </li> <li> <code>validators</code>           \u2013            <p>Validators for pysmo classes using <code>attrs</code>.</p> </li> </ul>"},{"location":"api/pysmo/lib/#pysmo.lib.decorators","title":"decorators","text":"<p>Decorators for pysmo.</p> <p>Functions:</p> <ul> <li> <code>add_doc</code>             \u2013              <p>Decorator to add a docstring to a function via decorator.</p> </li> <li> <code>value_not_none</code>             \u2013              <p>Decorator to ensure the value in Class properties is not None.</p> </li> </ul>"},{"location":"api/pysmo/lib/#pysmo.lib.decorators.add_doc","title":"add_doc","text":"<pre><code>add_doc(docstring: str) -&gt; Callable\n</code></pre> <p>Decorator to add a docstring to a function via decorator.</p> <p>Useful to use e.g. f-strings in the docstring.</p> <p>Attributes:</p> <ul> <li> <code>docstring</code>           \u2013            <p>The docstring to add.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>Function with docstring applied.</p> </li> </ul> Source code in <code>pysmo/lib/decorators.py</code> <pre><code>def add_doc(docstring: str) -&gt; Callable:\n    \"\"\"Decorator to add a docstring to a function via decorator.\n\n    Useful to use e.g. f-strings in the docstring.\n\n    Attributes:\n        docstring: The docstring to add.\n\n    Returns:\n        Function with docstring applied.\n    \"\"\"\n\n    def decorator(function: Callable) -&gt; Callable:\n        function.__doc__ = docstring\n        return function\n\n    return decorator\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.decorators.value_not_none","title":"value_not_none","text":"<pre><code>value_not_none(\n    function: Callable[..., Any],\n) -&gt; Callable[..., Any]\n</code></pre> <p>Decorator to ensure the value in Class properties is not None.</p> <p>Parameters:</p> <ul> <li> <code>function</code>               (<code>Callable[..., Any]</code>)           \u2013            <p>The function to decorate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[..., Any]</code>           \u2013            <p>Function with value not None check applied.</p> </li> </ul> Source code in <code>pysmo/lib/decorators.py</code> <pre><code>def value_not_none(function: Callable[..., Any]) -&gt; Callable[..., Any]:\n    \"\"\"Decorator to ensure the value in Class properties is not None.\n\n    Parameters:\n        function: The function to decorate.\n\n    Returns:\n        Function with value not None check applied.\n    \"\"\"\n\n    @wraps(function)\n    def decorator(*args: Any, **kwargs: Any) -&gt; Any:\n        instance, value, *_ = args\n        if value is None:\n            raise TypeError(\n                f\"{instance.__class__.__name__}.{function.__name__} may not be of None type.\"\n            )\n        return function(*args, **kwargs)\n\n    return decorator\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.defaults","title":"defaults","text":"<p>Defaults for pysmo functions/classes.</p> <p>Classes:</p> <ul> <li> <code>SEISMOGRAM_DEFAULTS</code>           \u2013            <p>Defaults for classes related to <code>Seismogram</code>.</p> </li> </ul>"},{"location":"api/pysmo/lib/#pysmo.lib.defaults.SEISMOGRAM_DEFAULTS","title":"SEISMOGRAM_DEFAULTS","text":"<p>               Bases: <code>Enum</code></p> <p>Defaults for classes related to <code>Seismogram</code>.</p> <p>Attributes:</p> <ul> <li> <code>begin_time</code>           \u2013            <p>Seismogram begin time.</p> </li> <li> <code>delta</code>           \u2013            <p>Sampling interval.</p> </li> </ul> Source code in <code>pysmo/lib/defaults.py</code> <pre><code>class SEISMOGRAM_DEFAULTS(Enum):\n    \"\"\"Defaults for classes related to [`Seismogram`][pysmo.Seismogram].\"\"\"\n\n    begin_time = datetime.fromtimestamp(0, tz=timezone.utc)\n    \"Seismogram begin time.\"\n    delta = timedelta(seconds=1)\n    \"Sampling interval.\"\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.defaults.SEISMOGRAM_DEFAULTS.begin_time","title":"begin_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>begin_time = fromtimestamp(0, tz=utc)\n</code></pre> <p>Seismogram begin time.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.defaults.SEISMOGRAM_DEFAULTS.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta = timedelta(seconds=1)\n</code></pre> <p>Sampling interval.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io","title":"io","text":"<p>I/O classes.</p> <p>This module contains classes that are not compatible with pysmo types, but serve as bases for classes that are. This means all functionality in this modules is available elsewhere, and these classes should not be used directly by users.</p> <p>Classes:</p> <ul> <li> <code>SacIO</code>           \u2013            <p>Access SAC files in Python.</p> </li> </ul>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO","title":"SacIO","text":"<p>               Bases: <code>SacIOBase</code></p> <p>Access SAC files in Python.</p> <p>The <code>SacIO</code> class reads and writes data and header values to and from a SAC file. Instances of <code>SacIO</code> provide attributes named identially to header names in the SAC file format. Additonal attributes may be set, but are not written to a SAC file (because there is no space reserved for them there). Class attributes with corresponding header fields in a SAC file (for example the begin time <code>b</code>) are checked for a valid format before being saved in the <code>SacIO</code> instance.</p> Warning <p>This class should typically never be used directly. Instead please use the <code>SAC</code> class, which inherits all attributes and methods from here.</p> <p>Examples:</p> <p>Create a new instance from a file and print seismogram data:</p> <pre><code>&gt;&gt;&gt; from pysmo.lib.io import SacIO\n&gt;&gt;&gt; sac = SacIO.from_file(\"example.sac\")\n&gt;&gt;&gt; data = sac.data\n&gt;&gt;&gt; data\narray([2302., 2313., 2345., ..., 2836., 2772., 2723.], shape=(180000,))\n&gt;&gt;&gt;\n</code></pre> <p>Read the sampling rate:</p> <pre><code>&gt;&gt;&gt; delta = sac.delta\n&gt;&gt;&gt; delta\n0.019999999552965164\n&gt;&gt;&gt;\n</code></pre> <p>Change the sampling rate:</p> <pre><code>&gt;&gt;&gt; newdelta = 0.05\n&gt;&gt;&gt; sac.delta = newdelta\n&gt;&gt;&gt; sac.delta\n0.05\n&gt;&gt;&gt;\n</code></pre> <p>Create a new instance from IRIS services:</p> <pre><code>&gt;&gt;&gt; from pysmo.lib.io import SacIO\n&gt;&gt;&gt; sac = SacIO.from_iris(net=\"C1\",\n... sta=\"VA01\",\n... cha=\"BHZ\",\n... loc=\"--\",\n... start=\"2021-03-22T13:00:00\",\n... duration=1 * 60 * 60,\n... scale=\"AUTO\",\n... demean=\"true\",\n... force_single_result=True)\n&gt;&gt;&gt; sac.npts\n144001\n&gt;&gt;&gt;\n</code></pre> <p>For each SAC(file) header field there is a corresponding attribute in this class. There are a lot of header fields in a SAC file, which are all called the same way when using <code>SacIO</code>.</p> <p>Methods:</p> <ul> <li> <code>change_all_times</code>             \u2013              <p>Change all time headers by the same amount.</p> </li> <li> <code>from_buffer</code>             \u2013              <p>Create a new SAC instance from a SAC data buffer.</p> </li> <li> <code>from_file</code>             \u2013              <p>Create a new SAC instance from a SAC file.</p> </li> <li> <code>from_iris</code>             \u2013              <p>Create a list of SAC instances from a single IRIS</p> </li> <li> <code>read</code>             \u2013              <p>Read data and headers from a SAC file into an existing SAC instance.</p> </li> <li> <code>read_buffer</code>             \u2013              <p>Read data and headers from a SAC byte buffer into an existing SAC instance.</p> </li> <li> <code>write</code>             \u2013              <p>Writes data and header values to a SAC file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>a</code>               (<code>float | None</code>)           \u2013            <p>First arrival time (seconds relative to reference time).</p> </li> <li> <code>az</code>               (<code>float</code>)           \u2013            <p>Event to station azimuth (degrees).</p> </li> <li> <code>b</code>               (<code>float</code>)           \u2013            <p>Beginning value of the independent variable.</p> </li> <li> <code>baz</code>               (<code>float</code>)           \u2013            <p>Station to event azimuth (degrees).</p> </li> <li> <code>cmpaz</code>               (<code>float | None</code>)           \u2013            <p>Component azimuth (degrees clockwise from north).</p> </li> <li> <code>cmpinc</code>               (<code>float | None</code>)           \u2013            <p>Component incident angle (degrees from upward vertical; SEED/MINISEED uses dip: degrees from horizontal down).</p> </li> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Seismogram data.</p> </li> <li> <code>delta</code>               (<code>float</code>)           \u2013            <p>Increment between evenly spaced samples (nominal value).</p> </li> <li> <code>depmax</code>               (<code>float | None</code>)           \u2013            <p>Maximum value of dependent variable.</p> </li> <li> <code>depmen</code>               (<code>float | None</code>)           \u2013            <p>Mean value of dependent variable.</p> </li> <li> <code>depmin</code>               (<code>float | None</code>)           \u2013            <p>Minimum value of dependent variable.</p> </li> <li> <code>dist</code>               (<code>float</code>)           \u2013            <p>Station to event distance (km).</p> </li> <li> <code>e</code>               (<code>float</code>)           \u2013            <p>Ending value of the independent variable.</p> </li> <li> <code>evdp</code>               (<code>float | None</code>)           \u2013            <p>Event depth below surface (kilometers -- previously meters).</p> </li> <li> <code>evel</code>               (<code>float | None</code>)           \u2013            <p>Event elevation (meters).</p> </li> <li> <code>evla</code>               (<code>float | None</code>)           \u2013            <p>Event latitude (degrees, north positive).</p> </li> <li> <code>evlo</code>               (<code>float | None</code>)           \u2013            <p>Event longitude (degrees, east positive).</p> </li> <li> <code>f</code>               (<code>float | None</code>)           \u2013            <p>Fini or end of event time (seconds relative to reference time).</p> </li> <li> <code>gcarc</code>               (<code>float</code>)           \u2013            <p>Station to event great circle arc length (degrees).</p> </li> <li> <code>ibody</code>               (<code>str | None</code>)           \u2013            <p>Body / Spheroid definition used in Distance Calculations.</p> </li> <li> <code>idep</code>               (<code>str</code>)           \u2013            <p>Type of dependent variable.</p> </li> <li> <code>ievreg</code>               (<code>str | None</code>)           \u2013            <p>Event geographic region.</p> </li> <li> <code>ievtyp</code>               (<code>str</code>)           \u2013            <p>Type of event.</p> </li> <li> <code>iftype</code>               (<code>str</code>)           \u2013            <p>Type of file.</p> </li> <li> <code>iinst</code>               (<code>str | None</code>)           \u2013            <p>Type of recording instrument.</p> </li> <li> <code>imagsrc</code>               (<code>str | None</code>)           \u2013            <p>Source of magnitude information.</p> </li> <li> <code>imagtyp</code>               (<code>str | None</code>)           \u2013            <p>Magnitude type.</p> </li> <li> <code>iqual</code>               (<code>str | None</code>)           \u2013            <p>Quality of data.</p> </li> <li> <code>istreg</code>               (<code>str | None</code>)           \u2013            <p>Station geographic region.</p> </li> <li> <code>isynth</code>               (<code>str | None</code>)           \u2013            <p>Synthetic data flag.</p> </li> <li> <code>iztype</code>               (<code>str</code>)           \u2013            <p>Reference time equivalence.</p> </li> <li> <code>ka</code>               (<code>str | None</code>)           \u2013            <p>First arrival time identification.</p> </li> <li> <code>kcmpnm</code>               (<code>str | None</code>)           \u2013            <p>Channel name. SEED volumes use three character names, and the third is the component/orientation. For horizontals, the current trend is to use 1 and 2 instead of N and E.</p> </li> <li> <code>kdatrd</code>               (<code>str | None</code>)           \u2013            <p>Date data was read onto computer.</p> </li> <li> <code>kevnm</code>               (<code>str | None</code>)           \u2013            <p>Event name.</p> </li> <li> <code>kf</code>               (<code>str | None</code>)           \u2013            <p>Fini identification.</p> </li> <li> <code>khole</code>               (<code>str | None</code>)           \u2013            <p>Nuclear: hole identifier; Other: location identifier (LOCID).</p> </li> <li> <code>kinst</code>               (<code>str | None</code>)           \u2013            <p>Generic name of recording instrument.</p> </li> <li> <code>knetwk</code>               (<code>str | None</code>)           \u2013            <p>Name of seismic network.</p> </li> <li> <code>ko</code>               (<code>str | None</code>)           \u2013            <p>Event origin time identification.</p> </li> <li> <code>kstnm</code>               (<code>str | None</code>)           \u2013            <p>Station name.</p> </li> <li> <code>kt0</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt1</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt2</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt3</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt4</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt5</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt6</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt7</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt8</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kt9</code>               (<code>str | None</code>)           \u2013            <p>User defined time pick identification.</p> </li> <li> <code>kuser0</code>               (<code>str | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>kuser1</code>               (<code>str | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>kuser2</code>               (<code>str | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>kzdate</code>               (<code>str | None</code>)           \u2013            <p>ISO 8601 format of GMT reference date.</p> </li> <li> <code>kztime</code>               (<code>str | None</code>)           \u2013            <p>Alphanumeric form of GMT reference time.</p> </li> <li> <code>lcalda</code>               (<code>Literal[True]</code>)           \u2013            <p>TRUE if DIST, AZ, BAZ, and GCARC are to be calculated from station and event coordinates.</p> </li> <li> <code>leven</code>               (<code>bool</code>)           \u2013            <p>TRUE if data is evenly spaced.</p> </li> <li> <code>lovrok</code>               (<code>bool | None</code>)           \u2013            <p>TRUE if it is okay to overwrite this file on disk.</p> </li> <li> <code>lpspol</code>               (<code>bool | None</code>)           \u2013            <p>TRUE if station components have a positive polarity (left-hand rule).</p> </li> <li> <code>mag</code>               (<code>float | None</code>)           \u2013            <p>Event magnitude.</p> </li> <li> <code>nevid</code>               (<code>int | None</code>)           \u2013            <p>Event ID (CSS 3.0).</p> </li> <li> <code>norid</code>               (<code>int | None</code>)           \u2013            <p>Origin ID (CSS 3.0).</p> </li> <li> <code>npts</code>               (<code>int</code>)           \u2013            <p>Number of points per data component.</p> </li> <li> <code>nvhdr</code>               (<code>int</code>)           \u2013            <p>Header version number.</p> </li> <li> <code>nwfid</code>               (<code>int | None</code>)           \u2013            <p>Waveform ID (CSS 3.0).</p> </li> <li> <code>nxsize</code>               (<code>int | None</code>)           \u2013            <p>Spectral Length (Spectral files only).</p> </li> <li> <code>nysize</code>               (<code>int | None</code>)           \u2013            <p>Spectral Width (Spectral files only).</p> </li> <li> <code>nzhour</code>               (<code>int | None</code>)           \u2013            <p>GMT hour.</p> </li> <li> <code>nzjday</code>               (<code>int | None</code>)           \u2013            <p>GMT julian day.</p> </li> <li> <code>nzmin</code>               (<code>int | None</code>)           \u2013            <p>GMT minute.</p> </li> <li> <code>nzmsec</code>               (<code>int | None</code>)           \u2013            <p>GMT millisecond.</p> </li> <li> <code>nzsec</code>               (<code>int | None</code>)           \u2013            <p>GMT second.</p> </li> <li> <code>nzyear</code>               (<code>int | None</code>)           \u2013            <p>GMT year corresponding to reference (zero) time in file.</p> </li> <li> <code>o</code>               (<code>float | None</code>)           \u2013            <p>Event origin time (seconds relative to reference time).</p> </li> <li> <code>odelta</code>               (<code>float | None</code>)           \u2013            <p>Observed increment if different from nominal value.</p> </li> <li> <code>ref_datetime</code>               (<code>datetime | None</code>)           \u2013            <p>Return Python datetime object of GMT reference time and date.</p> </li> <li> <code>resp0</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 0 (not currently used).</p> </li> <li> <code>resp1</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 1 (not currently used).</p> </li> <li> <code>resp2</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 2 (not currently used).</p> </li> <li> <code>resp3</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 3 (not currently used).</p> </li> <li> <code>resp4</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 4 (not currently used).</p> </li> <li> <code>resp5</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 5 (not currently used).</p> </li> <li> <code>resp6</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 6 (not currently used).</p> </li> <li> <code>resp7</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 7 (not currently used).</p> </li> <li> <code>resp8</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 8 (not currently used).</p> </li> <li> <code>resp9</code>               (<code>float | None</code>)           \u2013            <p>Instrument response parameter 9 (not currently used).</p> </li> <li> <code>stdp</code>               (<code>float | None</code>)           \u2013            <p>Station depth below surface (meters).</p> </li> <li> <code>stel</code>               (<code>float | None</code>)           \u2013            <p>Station elevation above sea level (meters).</p> </li> <li> <code>stla</code>               (<code>float | None</code>)           \u2013            <p>Station latitude (degrees, north positive).</p> </li> <li> <code>stlo</code>               (<code>float | None</code>)           \u2013            <p>Station longitude (degrees, east positive).</p> </li> <li> <code>t0</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 0 (seconds relative to reference time).</p> </li> <li> <code>t1</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 1 (seconds relative to reference time).</p> </li> <li> <code>t2</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 2 (seconds relative to reference time).</p> </li> <li> <code>t3</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 3 (seconds relative to reference time).</p> </li> <li> <code>t4</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 4 (seconds relative to reference time).</p> </li> <li> <code>t5</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 5 (seconds relative to reference time).</p> </li> <li> <code>t6</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 6 (seconds relative to reference time).</p> </li> <li> <code>t7</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 7 (seconds relative to reference time).</p> </li> <li> <code>t8</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 8 (seconds relative to reference time).</p> </li> <li> <code>t9</code>               (<code>float | None</code>)           \u2013            <p>User defined time pick or marker 9 (seconds relative to reference time).</p> </li> <li> <code>user0</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user1</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user2</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user3</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user4</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user5</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user6</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user7</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user8</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>user9</code>               (<code>float | None</code>)           \u2013            <p>User defined variable storage area.</p> </li> <li> <code>xmaximum</code>               (<code>float | None</code>)           \u2013            <p>Maximum value of X (Spectral files only).</p> </li> <li> <code>xminimum</code>               (<code>float | None</code>)           \u2013            <p>Minimum value of X (Spectral files only).</p> </li> <li> <code>ymaximum</code>               (<code>float | None</code>)           \u2013            <p>Maximum value of Y (Spectral files only).</p> </li> <li> <code>yminimum</code>               (<code>float | None</code>)           \u2013            <p>Minimum value of Y (Spectral files only).</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>@define(kw_only=True)\nclass SacIO(SacIOBase):\n    \"\"\"\n    Access SAC files in Python.\n\n    The `SacIO` class reads and writes data and header values to and from a\n    SAC file. Instances of `SacIO` provide attributes named identially to\n    header names in the SAC file format. Additonal attributes may be set, but\n    are not written to a SAC file (because there is no space reserved for them\n    there). Class attributes with corresponding header fields in a SAC file\n    (for example the begin time [`b`][pysmo.lib.io.SacIO.b]) are checked for a\n    valid format before being saved in the `SacIO` instance.\n\n    Warning:\n        This class should typically never be used directly. Instead please\n        use the [`SAC`][pysmo.classes.SAC] class, which inherits all attributes\n        and methods from here.\n\n    Examples:\n        Create a new instance from a file and print seismogram data:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.lib.io import SacIO\n        &gt;&gt;&gt; sac = SacIO.from_file(\"example.sac\")\n        &gt;&gt;&gt; data = sac.data\n        &gt;&gt;&gt; data\n        array([2302., 2313., 2345., ..., 2836., 2772., 2723.], shape=(180000,))\n        &gt;&gt;&gt;\n        ```\n\n        Read the sampling rate:\n\n        ```python\n        &gt;&gt;&gt; delta = sac.delta\n        &gt;&gt;&gt; delta\n        0.019999999552965164\n        &gt;&gt;&gt;\n        ```\n\n        Change the sampling rate:\n\n        ```python\n        &gt;&gt;&gt; newdelta = 0.05\n        &gt;&gt;&gt; sac.delta = newdelta\n        &gt;&gt;&gt; sac.delta\n        0.05\n        &gt;&gt;&gt;\n        ```\n\n        Create a new instance from IRIS services:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.lib.io import SacIO\n        &gt;&gt;&gt; sac = SacIO.from_iris(net=\"C1\",\n        ... sta=\"VA01\",\n        ... cha=\"BHZ\",\n        ... loc=\"--\",\n        ... start=\"2021-03-22T13:00:00\",\n        ... duration=1 * 60 * 60,\n        ... scale=\"AUTO\",\n        ... demean=\"true\",\n        ... force_single_result=True)\n        &gt;&gt;&gt; sac.npts\n        144001\n        &gt;&gt;&gt;\n        ```\n\n    For each SAC(file) header field there is a corresponding attribute in this\n    class. There are a lot of header fields in a SAC file, which are all called\n    the same way when using `SacIO`.\n    \"\"\"\n\n    @property\n    def depmin(self) -&gt; float | None:\n        \"\"\"Minimum value of dependent variable.\"\"\"\n        if self.npts == 0:\n            return None\n        return np.min(self.data).item()\n\n    @property\n    def depmax(self) -&gt; float | None:\n        \"\"\"Maximum value of dependent variable.\"\"\"\n        if self.npts == 0:\n            return None\n        return np.max(self.data).item()\n\n    @property\n    def depmen(self) -&gt; float | None:\n        \"\"\"Mean value of dependent variable.\"\"\"\n        if self.npts == 0:\n            return None\n        return np.mean(self.data).item()\n\n    @property\n    def e(self) -&gt; float:\n        \"\"\"Ending value of the independent variable.\"\"\"\n        if self.npts == 0:\n            return self.b\n        return self.b + (self.npts - 1) * self.delta\n\n    @property\n    def dist(self) -&gt; float:\n        \"\"\"Station to event distance (km).\"\"\"\n        if self.stla and self.stlo and self.evla and self.evlo:\n            station_location = MiniLocation(latitude=self.stla, longitude=self.stlo)\n            event_location = MiniLocation(latitude=self.evla, longitude=self.evlo)\n            return (\n                distance(location_1=station_location, location_2=event_location) / 1000\n            )\n        raise TypeError(\"One or more coordinates are None.\")\n\n    @property\n    def az(self) -&gt; float:\n        \"\"\"Event to station azimuth (degrees).\"\"\"\n        if self.stla and self.stlo and self.evla and self.evlo:\n            station_location = MiniLocation(latitude=self.stla, longitude=self.stlo)\n            event_location = MiniLocation(latitude=self.evla, longitude=self.evlo)\n            return azimuth(location_1=station_location, location_2=event_location)\n        raise TypeError(\"One or more coordinates are None.\")\n\n    @property\n    def baz(self) -&gt; float:\n        \"\"\"Station to event azimuth (degrees).\"\"\"\n        if self.stla and self.stlo and self.evla and self.evlo:\n            station_location = MiniLocation(latitude=self.stla, longitude=self.stlo)\n            event_location = MiniLocation(latitude=self.evla, longitude=self.evlo)\n            return backazimuth(location_1=station_location, location_2=event_location)\n        raise TypeError(\"One or more coordinates are None.\")\n\n    @property\n    def gcarc(self) -&gt; float:\n        \"\"\"Station to event great circle arc length (degrees).\"\"\"\n        if self.stla and self.stlo and self.evla and self.evlo:\n            lat1, lon1 = np.deg2rad(self.stla), np.deg2rad(self.stlo)\n            lat2, lon2 = np.deg2rad(self.evla), np.deg2rad(self.evlo)\n            return np.rad2deg(\n                np.arccos(\n                    np.sin(lat1) * np.sin(lat2)\n                    + np.cos(lat1) * np.cos(lat2) * np.cos(np.abs(lon1 - lon2))\n                )\n            )\n        raise TypeError(\"One or more coordinates are None.\")\n\n    @property\n    def xminimum(self) -&gt; float | None:\n        \"\"\"Minimum value of X (Spectral files only).\"\"\"\n        if self.nxsize == 0 or not self.nxsize:\n            return None\n        return np.min(self.x).item()\n\n    @property\n    def xmaximum(self) -&gt; float | None:\n        \"\"\"Maximum value of X (Spectral files only).\"\"\"\n        if self.nxsize == 0 or not self.nxsize:\n            return None\n        return np.max(self.x).item()\n\n    @property\n    def yminimum(self) -&gt; float | None:\n        \"\"\"Minimum value of Y (Spectral files only).\"\"\"\n        if self.nysize == 0 or not self.nysize:\n            return None\n        return np.min(self.y).item()\n\n    @property\n    def ymaximum(self) -&gt; float | None:\n        \"\"\"Maximum value of Y (Spectral files only).\"\"\"\n        if self.nysize == 0 or not self.nysize:\n            return None\n        return np.max(self.y).item()\n\n    @property\n    def npts(self) -&gt; int:\n        \"\"\"Number of points per data component.\"\"\"\n        return np.size(self.data)\n\n    @property\n    def nxsize(self) -&gt; int | None:\n        \"\"\"Spectral Length (Spectral files only).\"\"\"\n        if np.size(self.x) == 0:\n            return None\n        return np.size(self.x)\n\n    @property\n    def nysize(self) -&gt; int | None:\n        \"\"\"Spectral Width (Spectral files only).\"\"\"\n        if np.size(self.y) == 0:\n            return None\n        return np.size(self.y)\n\n    @property\n    def lcalda(self) -&gt; Literal[True]:\n        \"\"\"TRUE if DIST, AZ, BAZ, and GCARC are to be calculated from station and event coordinates.\n\n        Note:\n            Above fields are all read only properties in this class, so\n            they are always calculated.\n        \"\"\"\n        return True\n\n    @property\n    def ref_datetime(self) -&gt; datetime | None:\n        \"\"\"Return Python datetime object of GMT reference time and date.\"\"\"\n        if (\n            self.nzyear is None\n            or self.nzjday is None\n            or self.nzhour is None\n            or self.nzmin is None\n            or self.nzsec is None\n            or self.nzmsec is None\n        ):\n            return None\n        return datetime(\n            year=self.nzyear,\n            month=1,\n            day=1,\n            hour=self.nzhour,\n            minute=self.nzmin,\n            second=self.nzsec,\n            microsecond=self.nzmsec * 1000,\n            tzinfo=timezone.utc,\n        ) + timedelta(days=self.nzjday - 1)\n\n    @ref_datetime.setter\n    def ref_datetime(self, value: datetime) -&gt; None:\n        timedelta_for_rounding = timedelta(microseconds=500)\n        value += timedelta_for_rounding\n        self.nzyear = value.year\n        self.nzjday = value.timetuple().tm_yday\n        self.nzhour = value.hour\n        self.nzmin = value.minute\n        self.nzsec = value.second\n        self.nzmsec = int(value.microsecond / 1000)\n\n    @property\n    def kzdate(self) -&gt; str | None:\n        \"\"\"ISO 8601 format of GMT reference date.\"\"\"\n        if self.ref_datetime is None:\n            return None\n        return self.ref_datetime.date().isoformat()\n\n    @property\n    def kztime(self) -&gt; str | None:\n        \"\"\"Alphanumeric form of GMT reference time.\"\"\"\n        if self.ref_datetime is None:\n            return None\n        return self.ref_datetime.time().isoformat(timespec=\"milliseconds\")\n\n    def read(self, filename: str | PathLike) -&gt; None:\n        \"\"\"Read data and headers from a SAC file into an existing SAC instance.\n\n        Parameters:\n            filename: Name of the sac file to read.\n        \"\"\"\n\n        filename = Path(filename).resolve()\n\n        self.read_buffer(filename.read_bytes())\n\n    def write(self, filename: str | PathLike) -&gt; None:\n        \"\"\"Writes data and header values to a SAC file.\n\n        Parameters:\n            filename: Name of the sacfile to write to.\n        \"\"\"\n        with open(filename, \"wb\") as file_handle:\n            # loop over all valid header fields and write them to the file\n            for header, header_metadata in SAC_HEADERS.items():\n                header_type = header_metadata.type\n                header_format = header_metadata.format\n                start = header_metadata.start\n                header_undefined = HEADER_TYPES[header_type].undefined\n\n                value = None\n                try:\n                    if hasattr(self, header):\n                        value = getattr(self, header)\n                except TypeError:\n                    value = None\n\n                # convert enumerated header to integer if it is not None\n                if header_type == \"i\" and value is not None:\n                    value = SAC_ENUMS_DICT[header][value]\n\n                # set None to -12345\n                if value is None:\n                    value = header_undefined\n\n                # Encode strings to bytes\n                if isinstance(value, str):\n                    value = value.encode()\n\n                # write to file\n                file_handle.seek(start)\n                file_handle.write(struct.pack(header_format, value))\n\n            # write data (if npts &gt; 0)\n            data_1_start = 632\n            data_1_end = data_1_start + self.npts * 4\n            file_handle.truncate(data_1_start)\n            if self.npts &gt; 0:\n                file_handle.seek(data_1_start)\n                for x in self.data:\n                    file_handle.write(struct.pack(\"f\", x))\n\n            if self.nvhdr == 7:\n                for footer, footer_metadata in SAC_FOOTERS.items():\n                    undefined = -12345.0\n                    start = footer_metadata.start + data_1_end\n                    value = None\n                    try:\n                        if hasattr(self, footer):\n                            value = getattr(self, footer)\n                    except AttributeError:\n                        value = None\n\n                    # set None to -12345\n                    if value is None:\n                        value = undefined\n\n                    # write to file\n                    file_handle.seek(start)\n                    file_handle.write(struct.pack(\"d\", value))\n\n    @classmethod\n    def from_file(cls, filename: str | PathLike) -&gt; Self:\n        \"\"\"Create a new SAC instance from a SAC file.\n\n        Parameters:\n            filename: Name of the SAC file to read.\n\n        Returns:\n            A new SacIO instance.\n        \"\"\"\n        newinstance = cls()\n        newinstance.read(filename)\n        return newinstance\n\n    @classmethod\n    def from_buffer(cls, buffer: bytes) -&gt; Self:\n        \"\"\"Create a new SAC instance from a SAC data buffer.\n\n        Parameters:\n            buffer: Buffer containing SAC file content.\n\n        Returns:\n            A new SacIO instance.\n        \"\"\"\n        newinstance = cls()\n        newinstance.read_buffer(buffer)\n        return newinstance\n\n    @classmethod\n    def from_iris(\n        cls,\n        net: str,\n        sta: str,\n        cha: str,\n        loc: str,\n        force_single_result: bool = False,\n        **kwargs: Any,\n    ) -&gt; Self | dict[str, Self] | None:\n        \"\"\"Create a list of SAC instances from a single IRIS\n        request using the output format as \"sac.zip\".\n\n        Parameters:\n            net: Network code (e.g. \"US\")\n            sta: Station code (e.g. \"BSS\")\n            cha: Channel code (e.g. \"BHZ\")\n            loc: Location code (e.g. \"00\")\n            force_single_result: If true, the function will return a single SAC\n                                object or None if the requests returns nothing.\n\n        Returns:\n            A new SacIO instance.\n        \"\"\"\n        kwargs[\"net\"] = net\n        kwargs[\"sta\"] = sta\n        kwargs[\"cha\"] = cha\n        kwargs[\"loc\"] = loc\n        kwargs[\"output\"] = \"sac.zip\"\n\n        if isinstance(kwargs[\"start\"], datetime):\n            kwargs[\"start\"] = kwargs[\"start\"].isoformat()\n\n        end = kwargs.get(\"end\", None)\n        if end is not None and isinstance(end, datetime):\n            kwargs[\"end\"] = end.isoformat()\n\n        response = httpx.get(\n            IRIS_BASE_URL,\n            params=kwargs,\n            follow_redirects=False,\n            timeout=IRIS_TIMOUT_SECONDS,\n        )\n        response.raise_for_status()\n\n        zip = ZipFile(BytesIO(response.content))\n\n        result = {}\n        for name in zip.namelist():\n            buffer = zip.read(name)\n            sac = cls.from_buffer(buffer)\n            if force_single_result:\n                return sac\n            result[name] = sac\n        return None if force_single_result else result\n\n    def read_buffer(self, buffer: bytes) -&gt; None:\n        \"\"\"Read data and headers from a SAC byte buffer into an existing SAC instance.\n\n        Parameters:\n            buffer: Buffer containing SAC file content.\n        \"\"\"\n\n        if len(buffer) &lt; 632:\n            raise EOFError()\n\n        # Guess the file endianness first using the unused12 header field.\n        # It is located at position 276 and its value should be -12345.0.\n        # Try reading with little endianness\n        if struct.unpack(\"&lt;f\", buffer[276:280])[-1] == -12345.0:\n            file_byteorder = \"&lt;\"\n        # otherwise assume big endianness.\n        else:\n            file_byteorder = \"&gt;\"\n\n        # Loop over all header fields and store them in the SAC object under their\n        # respective private names.\n        npts = 0\n        for header, header_metadata in SAC_HEADERS.items():\n            header_type = header_metadata.type\n            header_required = header_metadata.required\n            header_undefined = HEADER_TYPES[header_type].undefined\n            start = header_metadata.start\n            length = header_metadata.length\n            end = start + length\n            if end &gt;= len(buffer):\n                continue\n            content = buffer[start:end]\n            value = struct.unpack(file_byteorder + header_metadata.format, content)[0]\n            if isinstance(value, bytes):\n                # strip spaces and \"\\x00\" chars\n                value = value.decode().rstrip(\" \\x00\")\n\n            # npts is read only property in this class, but is needed for reading data\n            if header == \"npts\":\n                npts = int(value)\n\n            # raise error if header is undefined AND required\n            if value == header_undefined and header_required:\n                raise RuntimeError(\n                    f\"Required {header=} is undefined - invalid SAC file!\"\n                )\n\n            # skip if undefined (value == -12345...) and not required\n            if value == header_undefined and not header_required:\n                continue\n\n            # convert enumerated header to string and format others\n            if header_type == \"i\":\n                value = SAC_ENUMS_DICT[header](value).name\n\n            # SAC file has headers fields which are read only attributes in this\n            # class. We skip them with this try/except.\n            # TODO: This is a bit crude, should maybe be a bit more specific.\n            try:\n                setattr(self, header, value)\n            except AttributeError as e:\n                if \"object has no setter\" in str(e):\n                    pass\n\n        # Only accept IFTYPE = ITIME SAC files. Other IFTYPE use two data blocks,\n        # which is something we don't support for now.\n        if self.iftype.lower() != \"time\":\n            raise NotImplementedError(\n                f\"Reading SAC files with IFTYPE=(I){self.iftype.upper()} is not supported.\"  # noqa: E501\n            )\n\n        # Read first data block\n        start = 632\n        length = npts * 4\n        data_end = start + length\n        self.data = np.array([])\n        if length &gt; 0:\n            data_end = start + length\n            data_format = file_byteorder + str(npts) + \"f\"\n            if data_end &gt; len(buffer):\n                raise EOFError()\n            content = buffer[start:data_end]\n            data = struct.unpack(data_format, content)\n            self.data = np.array(data)\n\n        if self.nvhdr == 7:\n            for footer, footer_metadata in SAC_FOOTERS.items():\n                undefined = -12345.0\n                length = 8\n                start = footer_metadata.start + data_end\n                end = start + length\n\n                if end &gt; len(buffer):\n                    raise EOFError()\n                content = buffer[start:end]\n\n                value = struct.unpack(file_byteorder + \"d\", content)[0]\n\n                # skip if undefined (value == -12345...)\n                if value == undefined:\n                    continue\n\n                # SAC file has headers fields which are read only attributes in this\n                # class. We skip them with this try/except.\n                # TODO: This is a bit crude, should maybe be a bit more specific.\n                try:\n                    setattr(self, footer, value)\n                except AttributeError as e:\n                    if \"object has no setter\" in str(e):\n                        pass\n\n    def change_all_times(self, dtime: float) -&gt; None:\n        \"\"\"Change all time headers by the same amount.\n\n        Attributes:\n            dtime: Time offset to apply.\n\n        Warning:\n            This method also changes the value for the current zero time header.\n            Typically it should only be used when changing\n            [`SacIO.iztype`][pysmo.lib.io.SacIO.iztype].\n        \"\"\"\n        try:\n            self._zero_time_can_be_none_zero = True\n            for time_header in SAC_TIME_HEADERS:\n                try:\n                    setattr(self, time_header, getattr(self, time_header) + dtime)\n                except AttributeError as e:\n                    if \"object has no setter\" in str(e):\n                        continue\n                except TypeError as e:\n                    if \"unsupported operand type(s) for\" in str(e):\n                        continue\n\n        finally:\n            self._zero_time_can_be_none_zero = False\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>First arrival time (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.az","title":"az  <code>property</code>","text":"<pre><code>az: float\n</code></pre> <p>Event to station azimuth (degrees).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.b","title":"b  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>b: float = field(\n    default=b,\n    converter=float,\n    validator=[type_validator(), validate_with_iztype],\n)\n</code></pre> <p>Beginning value of the independent variable.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.baz","title":"baz  <code>property</code>","text":"<pre><code>baz: float\n</code></pre> <p>Station to event azimuth (degrees).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.cmpaz","title":"cmpaz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cmpaz: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Component azimuth (degrees clockwise from north).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.cmpinc","title":"cmpinc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cmpinc: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Component incident angle (degrees from upward vertical; SEED/MINISEED uses dip: degrees from horizontal down).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: ndarray = field(\n    factory=lambda: array([]), validator=type_validator()\n)\n</code></pre> <p>Seismogram data.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: float = field(\n    default=delta,\n    converter=float,\n    validator=type_validator(),\n)\n</code></pre> <p>Increment between evenly spaced samples (nominal value).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.depmax","title":"depmax  <code>property</code>","text":"<pre><code>depmax: float | None\n</code></pre> <p>Maximum value of dependent variable.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.depmen","title":"depmen  <code>property</code>","text":"<pre><code>depmen: float | None\n</code></pre> <p>Mean value of dependent variable.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.depmin","title":"depmin  <code>property</code>","text":"<pre><code>depmin: float | None\n</code></pre> <p>Minimum value of dependent variable.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.dist","title":"dist  <code>property</code>","text":"<pre><code>dist: float\n</code></pre> <p>Station to event distance (km).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.e","title":"e  <code>property</code>","text":"<pre><code>e: float\n</code></pre> <p>Ending value of the independent variable.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.evdp","title":"evdp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>evdp: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Event depth below surface (kilometers -- previously meters).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.evel","title":"evel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>evel: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Event elevation (meters).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.evla","title":"evla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>evla: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional([type_validator(), ge(-90), le(90)]),\n)\n</code></pre> <p>Event latitude (degrees, north positive).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.evlo","title":"evlo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>evlo: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), ge(-180), le(180)]\n    ),\n)\n</code></pre> <p>Event longitude (degrees, east positive).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.f","title":"f  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>f: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>Fini or end of event time (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.gcarc","title":"gcarc  <code>property</code>","text":"<pre><code>gcarc: float\n</code></pre> <p>Station to event great circle arc length (degrees).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ibody","title":"ibody  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ibody: str | None = field(\n    default=None, validator=optional(validate_sacenum)\n)\n</code></pre> <p>Body / Spheroid definition used in Distance Calculations.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.idep","title":"idep  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idep: str = field(default=idep, validator=validate_sacenum)\n</code></pre> <p>Type of dependent variable.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ievreg","title":"ievreg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ievreg: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(4)]),\n)\n</code></pre> <p>Event geographic region.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ievtyp","title":"ievtyp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ievtyp: str = field(\n    default=ievtyp, validator=validate_sacenum\n)\n</code></pre> <p>Type of event.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.iftype","title":"iftype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iftype: str = field(\n    default=iftype, validator=validate_sacenum\n)\n</code></pre> <p>Type of file.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.iinst","title":"iinst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iinst: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(4)]),\n)\n</code></pre> <p>Type of recording instrument.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.imagsrc","title":"imagsrc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imagsrc: str | None = field(\n    default=None, validator=optional(validate_sacenum)\n)\n</code></pre> <p>Source of magnitude information.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.imagtyp","title":"imagtyp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>imagtyp: str | None = field(\n    default=None, validator=optional(validate_sacenum)\n)\n</code></pre> <p>Magnitude type.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.iqual","title":"iqual  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iqual: str | None = field(\n    default=None, validator=optional(validate_sacenum)\n)\n</code></pre> <p>Quality of data.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.istreg","title":"istreg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>istreg: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(4)]),\n)\n</code></pre> <p>Station geographic region.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.isynth","title":"isynth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>isynth: str | None = field(\n    default=None, validator=optional(validate_sacenum)\n)\n</code></pre> <p>Synthetic data flag.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.iztype","title":"iztype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>iztype: str = field(\n    default=iztype, validator=validate_sacenum\n)\n</code></pre> <p>Reference time equivalence.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ka","title":"ka  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ka: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>First arrival time identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kcmpnm","title":"kcmpnm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kcmpnm: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Channel name. SEED volumes use three character names, and the third is the component/orientation. For horizontals, the current trend is to use 1 and 2 instead of N and E.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kdatrd","title":"kdatrd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kdatrd: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Date data was read onto computer.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kevnm","title":"kevnm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kevnm: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(16)]),\n)\n</code></pre> <p>Event name.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kf","title":"kf  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kf: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Fini identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.khole","title":"khole  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>khole: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Nuclear: hole identifier; Other: location identifier (LOCID).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kinst","title":"kinst  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kinst: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Generic name of recording instrument.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.knetwk","title":"knetwk  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>knetwk: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Name of seismic network.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ko","title":"ko  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ko: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Event origin time identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kstnm","title":"kstnm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kstnm: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>Station name.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt0","title":"kt0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt0: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt1","title":"kt1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt1: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt2","title":"kt2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt2: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt3","title":"kt3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt3: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt4","title":"kt4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt4: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt5","title":"kt5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt5: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt6","title":"kt6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt6: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt7","title":"kt7  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt7: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt8","title":"kt8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt8: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kt9","title":"kt9  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kt9: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined time pick identification.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kuser0","title":"kuser0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kuser0: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kuser1","title":"kuser1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kuser1: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kuser2","title":"kuser2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kuser2: str | None = field(\n    default=None,\n    validator=optional([type_validator(), max_len(8)]),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kzdate","title":"kzdate  <code>property</code>","text":"<pre><code>kzdate: str | None\n</code></pre> <p>ISO 8601 format of GMT reference date.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.kztime","title":"kztime  <code>property</code>","text":"<pre><code>kztime: str | None\n</code></pre> <p>Alphanumeric form of GMT reference time.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.lcalda","title":"lcalda  <code>property</code>","text":"<pre><code>lcalda: Literal[True]\n</code></pre> <p>TRUE if DIST, AZ, BAZ, and GCARC are to be calculated from station and event coordinates.</p> Note <p>Above fields are all read only properties in this class, so they are always calculated.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.leven","title":"leven  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>leven: bool = field(\n    default=leven, validator=type_validator()\n)\n</code></pre> <p>TRUE if data is evenly spaced.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.lovrok","title":"lovrok  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lovrok: bool | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>TRUE if it is okay to overwrite this file on disk.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.lpspol","title":"lpspol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lpspol: bool | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>TRUE if station components have a positive polarity (left-hand rule).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.mag","title":"mag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mag: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Event magnitude.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nevid","title":"nevid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nevid: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>Event ID (CSS 3.0).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.norid","title":"norid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>norid: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>Origin ID (CSS 3.0).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.npts","title":"npts  <code>property</code>","text":"<pre><code>npts: int\n</code></pre> <p>Number of points per data component.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nvhdr","title":"nvhdr  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nvhdr: int = field(\n    default=nvhdr, validator=type_validator()\n)\n</code></pre> <p>Header version number.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nwfid","title":"nwfid  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nwfid: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>Waveform ID (CSS 3.0).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nxsize","title":"nxsize  <code>property</code>","text":"<pre><code>nxsize: int | None\n</code></pre> <p>Spectral Length (Spectral files only).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nysize","title":"nysize  <code>property</code>","text":"<pre><code>nysize: int | None\n</code></pre> <p>Spectral Width (Spectral files only).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nzhour","title":"nzhour  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzhour: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>GMT hour.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nzjday","title":"nzjday  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzjday: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>GMT julian day.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nzmin","title":"nzmin  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzmin: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>GMT minute.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nzmsec","title":"nzmsec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzmsec: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>GMT millisecond.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nzsec","title":"nzsec  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzsec: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>GMT second.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.nzyear","title":"nzyear  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>nzyear: int | None = field(\n    default=None, validator=optional(type_validator())\n)\n</code></pre> <p>GMT year corresponding to reference (zero) time in file.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.o","title":"o  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>o: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>Event origin time (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.odelta","title":"odelta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>odelta: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Observed increment if different from nominal value.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ref_datetime","title":"ref_datetime  <code>property</code> <code>writable</code>","text":"<pre><code>ref_datetime: datetime | None\n</code></pre> <p>Return Python datetime object of GMT reference time and date.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp0","title":"resp0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp0: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 0 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp1","title":"resp1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp1: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 1 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp2","title":"resp2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp2: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 2 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp3","title":"resp3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp3: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 3 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp4","title":"resp4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp4: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 4 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp5","title":"resp5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp5: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 5 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp6","title":"resp6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp6: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 6 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp7","title":"resp7  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp7: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 7 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp8","title":"resp8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp8: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 8 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.resp9","title":"resp9  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resp9: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Instrument response parameter 9 (not currently used).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.stdp","title":"stdp  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stdp: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Station depth below surface (meters).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.stel","title":"stel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stel: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>Station elevation above sea level (meters).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.stla","title":"stla  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stla: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional([type_validator(), ge(-90), le(90)]),\n)\n</code></pre> <p>Station latitude (degrees, north positive).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.stlo","title":"stlo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stlo: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), ge(-180), le(180)]\n    ),\n)\n</code></pre> <p>Station longitude (degrees, east positive).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t0","title":"t0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t0: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 0 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t1","title":"t1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t1: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 1 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t2","title":"t2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t2: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 2 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t3","title":"t3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t3: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 3 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t4","title":"t4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t4: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 4 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t5","title":"t5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t5: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 5 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t6","title":"t6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t6: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 6 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t7","title":"t7  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t7: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 7 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t8","title":"t8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t8: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 8 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.t9","title":"t9  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t9: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(\n        [type_validator(), validate_with_iztype]\n    ),\n)\n</code></pre> <p>User defined time pick or marker 9 (seconds relative to reference time).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user0","title":"user0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user0: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user1","title":"user1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user1: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user2","title":"user2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user2: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user3","title":"user3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user3: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user4","title":"user4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user4: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user5","title":"user5  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user5: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user6","title":"user6  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user6: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user7","title":"user7  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user7: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user8","title":"user8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user8: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.user9","title":"user9  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user9: float | None = field(\n    default=None,\n    converter=optional(float),\n    validator=optional(type_validator()),\n)\n</code></pre> <p>User defined variable storage area.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.xmaximum","title":"xmaximum  <code>property</code>","text":"<pre><code>xmaximum: float | None\n</code></pre> <p>Maximum value of X (Spectral files only).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.xminimum","title":"xminimum  <code>property</code>","text":"<pre><code>xminimum: float | None\n</code></pre> <p>Minimum value of X (Spectral files only).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.ymaximum","title":"ymaximum  <code>property</code>","text":"<pre><code>ymaximum: float | None\n</code></pre> <p>Maximum value of Y (Spectral files only).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.yminimum","title":"yminimum  <code>property</code>","text":"<pre><code>yminimum: float | None\n</code></pre> <p>Minimum value of Y (Spectral files only).</p>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.change_all_times","title":"change_all_times","text":"<pre><code>change_all_times(dtime: float) -&gt; None\n</code></pre> <p>Change all time headers by the same amount.</p> <p>Attributes:</p> <ul> <li> <code>dtime</code>           \u2013            <p>Time offset to apply.</p> </li> </ul> Warning <p>This method also changes the value for the current zero time header. Typically it should only be used when changing <code>SacIO.iztype</code>.</p> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>def change_all_times(self, dtime: float) -&gt; None:\n    \"\"\"Change all time headers by the same amount.\n\n    Attributes:\n        dtime: Time offset to apply.\n\n    Warning:\n        This method also changes the value for the current zero time header.\n        Typically it should only be used when changing\n        [`SacIO.iztype`][pysmo.lib.io.SacIO.iztype].\n    \"\"\"\n    try:\n        self._zero_time_can_be_none_zero = True\n        for time_header in SAC_TIME_HEADERS:\n            try:\n                setattr(self, time_header, getattr(self, time_header) + dtime)\n            except AttributeError as e:\n                if \"object has no setter\" in str(e):\n                    continue\n            except TypeError as e:\n                if \"unsupported operand type(s) for\" in str(e):\n                    continue\n\n    finally:\n        self._zero_time_can_be_none_zero = False\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.from_buffer","title":"from_buffer  <code>classmethod</code>","text":"<pre><code>from_buffer(buffer: bytes) -&gt; Self\n</code></pre> <p>Create a new SAC instance from a SAC data buffer.</p> <p>Parameters:</p> <ul> <li> <code>buffer</code>               (<code>bytes</code>)           \u2013            <p>Buffer containing SAC file content.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A new SacIO instance.</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>@classmethod\ndef from_buffer(cls, buffer: bytes) -&gt; Self:\n    \"\"\"Create a new SAC instance from a SAC data buffer.\n\n    Parameters:\n        buffer: Buffer containing SAC file content.\n\n    Returns:\n        A new SacIO instance.\n    \"\"\"\n    newinstance = cls()\n    newinstance.read_buffer(buffer)\n    return newinstance\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filename: str | PathLike) -&gt; Self\n</code></pre> <p>Create a new SAC instance from a SAC file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | PathLike</code>)           \u2013            <p>Name of the SAC file to read.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>A new SacIO instance.</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str | PathLike) -&gt; Self:\n    \"\"\"Create a new SAC instance from a SAC file.\n\n    Parameters:\n        filename: Name of the SAC file to read.\n\n    Returns:\n        A new SacIO instance.\n    \"\"\"\n    newinstance = cls()\n    newinstance.read(filename)\n    return newinstance\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.from_iris","title":"from_iris  <code>classmethod</code>","text":"<pre><code>from_iris(\n    net: str,\n    sta: str,\n    cha: str,\n    loc: str,\n    force_single_result: bool = False,\n    **kwargs: Any\n) -&gt; Self | dict[str, Self] | None\n</code></pre> <p>Create a list of SAC instances from a single IRIS request using the output format as \"sac.zip\".</p> <p>Parameters:</p> <ul> <li> <code>net</code>               (<code>str</code>)           \u2013            <p>Network code (e.g. \"US\")</p> </li> <li> <code>sta</code>               (<code>str</code>)           \u2013            <p>Station code (e.g. \"BSS\")</p> </li> <li> <code>cha</code>               (<code>str</code>)           \u2013            <p>Channel code (e.g. \"BHZ\")</p> </li> <li> <code>loc</code>               (<code>str</code>)           \u2013            <p>Location code (e.g. \"00\")</p> </li> <li> <code>force_single_result</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, the function will return a single SAC                 object or None if the requests returns nothing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self | dict[str, Self] | None</code>           \u2013            <p>A new SacIO instance.</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>@classmethod\ndef from_iris(\n    cls,\n    net: str,\n    sta: str,\n    cha: str,\n    loc: str,\n    force_single_result: bool = False,\n    **kwargs: Any,\n) -&gt; Self | dict[str, Self] | None:\n    \"\"\"Create a list of SAC instances from a single IRIS\n    request using the output format as \"sac.zip\".\n\n    Parameters:\n        net: Network code (e.g. \"US\")\n        sta: Station code (e.g. \"BSS\")\n        cha: Channel code (e.g. \"BHZ\")\n        loc: Location code (e.g. \"00\")\n        force_single_result: If true, the function will return a single SAC\n                            object or None if the requests returns nothing.\n\n    Returns:\n        A new SacIO instance.\n    \"\"\"\n    kwargs[\"net\"] = net\n    kwargs[\"sta\"] = sta\n    kwargs[\"cha\"] = cha\n    kwargs[\"loc\"] = loc\n    kwargs[\"output\"] = \"sac.zip\"\n\n    if isinstance(kwargs[\"start\"], datetime):\n        kwargs[\"start\"] = kwargs[\"start\"].isoformat()\n\n    end = kwargs.get(\"end\", None)\n    if end is not None and isinstance(end, datetime):\n        kwargs[\"end\"] = end.isoformat()\n\n    response = httpx.get(\n        IRIS_BASE_URL,\n        params=kwargs,\n        follow_redirects=False,\n        timeout=IRIS_TIMOUT_SECONDS,\n    )\n    response.raise_for_status()\n\n    zip = ZipFile(BytesIO(response.content))\n\n    result = {}\n    for name in zip.namelist():\n        buffer = zip.read(name)\n        sac = cls.from_buffer(buffer)\n        if force_single_result:\n            return sac\n        result[name] = sac\n    return None if force_single_result else result\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.read","title":"read","text":"<pre><code>read(filename: str | PathLike) -&gt; None\n</code></pre> <p>Read data and headers from a SAC file into an existing SAC instance.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | PathLike</code>)           \u2013            <p>Name of the sac file to read.</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>def read(self, filename: str | PathLike) -&gt; None:\n    \"\"\"Read data and headers from a SAC file into an existing SAC instance.\n\n    Parameters:\n        filename: Name of the sac file to read.\n    \"\"\"\n\n    filename = Path(filename).resolve()\n\n    self.read_buffer(filename.read_bytes())\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.read_buffer","title":"read_buffer","text":"<pre><code>read_buffer(buffer: bytes) -&gt; None\n</code></pre> <p>Read data and headers from a SAC byte buffer into an existing SAC instance.</p> <p>Parameters:</p> <ul> <li> <code>buffer</code>               (<code>bytes</code>)           \u2013            <p>Buffer containing SAC file content.</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>def read_buffer(self, buffer: bytes) -&gt; None:\n    \"\"\"Read data and headers from a SAC byte buffer into an existing SAC instance.\n\n    Parameters:\n        buffer: Buffer containing SAC file content.\n    \"\"\"\n\n    if len(buffer) &lt; 632:\n        raise EOFError()\n\n    # Guess the file endianness first using the unused12 header field.\n    # It is located at position 276 and its value should be -12345.0.\n    # Try reading with little endianness\n    if struct.unpack(\"&lt;f\", buffer[276:280])[-1] == -12345.0:\n        file_byteorder = \"&lt;\"\n    # otherwise assume big endianness.\n    else:\n        file_byteorder = \"&gt;\"\n\n    # Loop over all header fields and store them in the SAC object under their\n    # respective private names.\n    npts = 0\n    for header, header_metadata in SAC_HEADERS.items():\n        header_type = header_metadata.type\n        header_required = header_metadata.required\n        header_undefined = HEADER_TYPES[header_type].undefined\n        start = header_metadata.start\n        length = header_metadata.length\n        end = start + length\n        if end &gt;= len(buffer):\n            continue\n        content = buffer[start:end]\n        value = struct.unpack(file_byteorder + header_metadata.format, content)[0]\n        if isinstance(value, bytes):\n            # strip spaces and \"\\x00\" chars\n            value = value.decode().rstrip(\" \\x00\")\n\n        # npts is read only property in this class, but is needed for reading data\n        if header == \"npts\":\n            npts = int(value)\n\n        # raise error if header is undefined AND required\n        if value == header_undefined and header_required:\n            raise RuntimeError(\n                f\"Required {header=} is undefined - invalid SAC file!\"\n            )\n\n        # skip if undefined (value == -12345...) and not required\n        if value == header_undefined and not header_required:\n            continue\n\n        # convert enumerated header to string and format others\n        if header_type == \"i\":\n            value = SAC_ENUMS_DICT[header](value).name\n\n        # SAC file has headers fields which are read only attributes in this\n        # class. We skip them with this try/except.\n        # TODO: This is a bit crude, should maybe be a bit more specific.\n        try:\n            setattr(self, header, value)\n        except AttributeError as e:\n            if \"object has no setter\" in str(e):\n                pass\n\n    # Only accept IFTYPE = ITIME SAC files. Other IFTYPE use two data blocks,\n    # which is something we don't support for now.\n    if self.iftype.lower() != \"time\":\n        raise NotImplementedError(\n            f\"Reading SAC files with IFTYPE=(I){self.iftype.upper()} is not supported.\"  # noqa: E501\n        )\n\n    # Read first data block\n    start = 632\n    length = npts * 4\n    data_end = start + length\n    self.data = np.array([])\n    if length &gt; 0:\n        data_end = start + length\n        data_format = file_byteorder + str(npts) + \"f\"\n        if data_end &gt; len(buffer):\n            raise EOFError()\n        content = buffer[start:data_end]\n        data = struct.unpack(data_format, content)\n        self.data = np.array(data)\n\n    if self.nvhdr == 7:\n        for footer, footer_metadata in SAC_FOOTERS.items():\n            undefined = -12345.0\n            length = 8\n            start = footer_metadata.start + data_end\n            end = start + length\n\n            if end &gt; len(buffer):\n                raise EOFError()\n            content = buffer[start:end]\n\n            value = struct.unpack(file_byteorder + \"d\", content)[0]\n\n            # skip if undefined (value == -12345...)\n            if value == undefined:\n                continue\n\n            # SAC file has headers fields which are read only attributes in this\n            # class. We skip them with this try/except.\n            # TODO: This is a bit crude, should maybe be a bit more specific.\n            try:\n                setattr(self, footer, value)\n            except AttributeError as e:\n                if \"object has no setter\" in str(e):\n                    pass\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.io.SacIO.write","title":"write","text":"<pre><code>write(filename: str | PathLike) -&gt; None\n</code></pre> <p>Writes data and header values to a SAC file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | PathLike</code>)           \u2013            <p>Name of the sacfile to write to.</p> </li> </ul> Source code in <code>pysmo/lib/io/_sacio/sacio.py</code> <pre><code>def write(self, filename: str | PathLike) -&gt; None:\n    \"\"\"Writes data and header values to a SAC file.\n\n    Parameters:\n        filename: Name of the sacfile to write to.\n    \"\"\"\n    with open(filename, \"wb\") as file_handle:\n        # loop over all valid header fields and write them to the file\n        for header, header_metadata in SAC_HEADERS.items():\n            header_type = header_metadata.type\n            header_format = header_metadata.format\n            start = header_metadata.start\n            header_undefined = HEADER_TYPES[header_type].undefined\n\n            value = None\n            try:\n                if hasattr(self, header):\n                    value = getattr(self, header)\n            except TypeError:\n                value = None\n\n            # convert enumerated header to integer if it is not None\n            if header_type == \"i\" and value is not None:\n                value = SAC_ENUMS_DICT[header][value]\n\n            # set None to -12345\n            if value is None:\n                value = header_undefined\n\n            # Encode strings to bytes\n            if isinstance(value, str):\n                value = value.encode()\n\n            # write to file\n            file_handle.seek(start)\n            file_handle.write(struct.pack(header_format, value))\n\n        # write data (if npts &gt; 0)\n        data_1_start = 632\n        data_1_end = data_1_start + self.npts * 4\n        file_handle.truncate(data_1_start)\n        if self.npts &gt; 0:\n            file_handle.seek(data_1_start)\n            for x in self.data:\n                file_handle.write(struct.pack(\"f\", x))\n\n        if self.nvhdr == 7:\n            for footer, footer_metadata in SAC_FOOTERS.items():\n                undefined = -12345.0\n                start = footer_metadata.start + data_1_end\n                value = None\n                try:\n                    if hasattr(self, footer):\n                        value = getattr(self, footer)\n                except AttributeError:\n                    value = None\n\n                # set None to -12345\n                if value is None:\n                    value = undefined\n\n                # write to file\n                file_handle.seek(start)\n                file_handle.write(struct.pack(\"d\", value))\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.typing","title":"typing","text":"<p>Typing related items.</p> <p>Functions:</p> <ul> <li> <code>matching_pysmo_types</code>             \u2013              <p>Returns pysmo types that objects may be an instance of.</p> </li> <li> <code>proto2mini</code>             \u2013              <p>Returns valid Mini classes for a given pysmo type.</p> </li> </ul>"},{"location":"api/pysmo/lib/#pysmo.lib.typing._AnyMini","title":"_AnyMini  <code>module-attribute</code>","text":"<pre><code>_AnyMini: TypeAlias = (\n    MiniEvent\n    | MiniLocation\n    | MiniLocationWithDepth\n    | MiniSeismogram\n    | MiniStation\n    | MiniICCSSeismogram\n)\n</code></pre> <p>Type alias for any pysmo Mini class.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.typing._AnyProto","title":"_AnyProto  <code>module-attribute</code>","text":"<pre><code>_AnyProto: TypeAlias = (\n    Event\n    | Location\n    | LocationWithDepth\n    | Seismogram\n    | Station\n    | ICCSSeismogram\n)\n</code></pre> <p>Type alias for any pysmo Protocol class.</p>"},{"location":"api/pysmo/lib/#pysmo.lib.typing.matching_pysmo_types","title":"matching_pysmo_types","text":"<pre><code>matching_pysmo_types(obj: object) -&gt; tuple[_AnyProto, ...]\n</code></pre> <p>Returns pysmo types that objects may be an instance of.</p> <p>Parameters:</p> <ul> <li> <code>obj</code>               (<code>object</code>)           \u2013            <p>Name of the object to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[_AnyProto, ...]</code>           \u2013            <p>Pysmo types for which <code>obj</code> is an instance of.</p> </li> </ul> <p>Examples:</p> <p>Pysmo types matching instances of <code>MiniLocationWithDepth</code> or the class itself:</p> <pre><code>&gt;&gt;&gt; from pysmo.lib.typing import matching_pysmo_types\n&gt;&gt;&gt; from pysmo import MiniLocationWithDepth\n&gt;&gt;&gt;\n&gt;&gt;&gt; mini = MiniLocationWithDepth(latitude=12, longitude=34, depth=56)\n&gt;&gt;&gt; matching_pysmo_types(mini)\n(&lt;class 'pysmo._types._location.Location'&gt;, &lt;class 'pysmo._types._location_with_depth.LocationWithDepth'&gt;)\n&gt;&gt;&gt;\n&gt;&gt;&gt; matching_pysmo_types(MiniLocationWithDepth)\n(&lt;class 'pysmo._types._location.Location'&gt;, &lt;class 'pysmo._types._location_with_depth.LocationWithDepth'&gt;)\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/lib/typing.py</code> <pre><code>def matching_pysmo_types(obj: object) -&gt; tuple[_AnyProto, ...]:\n    \"\"\"Returns pysmo types that objects may be an instance of.\n\n    Parameters:\n        obj: Name of the object to check.\n\n    Returns:\n        Pysmo types for which `obj` is an instance of.\n\n    Examples:\n        Pysmo types matching instances of\n        [`MiniLocationWithDepth`][pysmo.MiniLocationWithDepth] or the class\n        itself:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.lib.typing import matching_pysmo_types\n        &gt;&gt;&gt; from pysmo import MiniLocationWithDepth\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; mini = MiniLocationWithDepth(latitude=12, longitude=34, depth=56)\n        &gt;&gt;&gt; matching_pysmo_types(mini)\n        (&lt;class 'pysmo._types._location.Location'&gt;, &lt;class 'pysmo._types._location_with_depth.LocationWithDepth'&gt;)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; matching_pysmo_types(MiniLocationWithDepth)\n        (&lt;class 'pysmo._types._location.Location'&gt;, &lt;class 'pysmo._types._location_with_depth.LocationWithDepth'&gt;)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    return tuple(proto for proto in get_args(_AnyProto) if isinstance(obj, proto))\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.typing.proto2mini","title":"proto2mini","text":"<pre><code>proto2mini(proto: type[_AnyProto]) -&gt; tuple[_AnyMini, ...]\n</code></pre> <p>Returns valid Mini classes for a given pysmo type.</p> Source code in <code>pysmo/lib/typing.py</code> <pre><code>def proto2mini(proto: type[_AnyProto]) -&gt; tuple[_AnyMini, ...]:\n    \"\"\"Returns valid Mini classes for a given pysmo type.\"\"\"\n    return tuple(\n        mini for mini in get_args(_AnyMini) if proto in matching_pysmo_types(mini)\n    )\n</code></pre>"},{"location":"api/pysmo/lib/#pysmo.lib.validators","title":"validators","text":"<p>Validators for pysmo classes using <code>attrs</code>.</p> <p>Functions:</p> <ul> <li> <code>datetime_is_utc</code>             \u2013              <p>Ensure <code>datetime</code> datetime objects have <code>tzdata=timezone.utc</code> set.</p> </li> </ul>"},{"location":"api/pysmo/lib/#pysmo.lib.validators.datetime_is_utc","title":"datetime_is_utc","text":"<pre><code>datetime_is_utc(\n    _: Any, attribute: Attribute, value: datetime | None\n) -&gt; None\n</code></pre> <p>Ensure <code>datetime</code> datetime objects have <code>tzdata=timezone.utc</code> set.</p> Source code in <code>pysmo/lib/validators.py</code> <pre><code>def datetime_is_utc(_: Any, attribute: Attribute, value: datetime | None) -&gt; None:\n    \"\"\"Ensure [`datetime`][datetime.datetime] datetime objects have `#!py tzdata=timezone.utc` set.\"\"\"\n    if value is None:\n        return\n    if value.tzinfo != timezone.utc:\n        raise TypeError(f\"datetime object {attribute} doesn't have tzdata=timezone.utc\")\n</code></pre>"},{"location":"api/pysmo/tools/","title":"Index","text":""},{"location":"api/pysmo/tools/#pysmo.tools","title":"pysmo.tools","text":"<p>Extra tools or topics that use pysmo types.</p> <p>Modules:</p> <ul> <li> <code>azdist</code>           \u2013            <p>Common distance and azimuth calculations using <code>pyproj.Geod</code>.</p> </li> <li> <code>iccs</code>           \u2013            <p>Iterative Cross-Correlation and Stack (ICCS).</p> </li> <li> <code>noise</code>           \u2013            <p>Generate realistic synthetic noise.</p> </li> <li> <code>plotutils</code>           \u2013            <p>Utilities for plotting with pysmo types.</p> </li> <li> <code>signal</code>           \u2013            <p>Functions used in signal processing.</p> </li> <li> <code>utils</code>           \u2013            <p>Pysmo's little helpers.</p> </li> </ul>"},{"location":"api/pysmo/tools/azdist/","title":"azdist","text":""},{"location":"api/pysmo/tools/azdist/#pysmo.tools.azdist","title":"pysmo.tools.azdist","text":"<p>Common distance and azimuth calculations using <code>pyproj.Geod</code>.</p> <p>Functions:</p> <ul> <li> <code>azimuth</code>             \u2013              <p>Calculate azimuth between two points.</p> </li> <li> <code>backazimuth</code>             \u2013              <p>Calculate backazimuth (in DEG) between two points.</p> </li> <li> <code>distance</code>             \u2013              <p>Calculate the great circle distance (in metres) between two locations.</p> </li> </ul>"},{"location":"api/pysmo/tools/azdist/#pysmo.tools.azdist.DEFAULT_ELLPS","title":"DEFAULT_ELLPS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_ELLPS = 'WGS84'\n</code></pre> <p>Default model for distance and azimuth calculations.</p>"},{"location":"api/pysmo/tools/azdist/#pysmo.tools.azdist.azimuth","title":"azimuth","text":"<pre><code>azimuth(\n    location_1: Location,\n    location_2: Location,\n    ellps: str = DEFAULT_ELLPS,\n) -&gt; float\n</code></pre> <p>Calculate azimuth between two points.</p> <p>Parameters:</p> <ul> <li> <code>location_1</code>               (<code>Location</code>)           \u2013            <p>Name of the event object providing coordinates of the origin location.</p> </li> <li> <code>location_2</code>               (<code>Location</code>)           \u2013            <p>Name of the station object providing coordinates of the target location.</p> </li> <li> <code>ellps</code>               (<code>str</code>, default:                   <code>DEFAULT_ELLPS</code> )           \u2013            <p>Ellipsoid to use for azimuth calculation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Azimuth in degrees from location 1 to location 2.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.azdist import azimuth\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; # the SAC class provides both event and station\n&gt;&gt;&gt; azimuth(sac.event, sac.station)\n181.91993\n&gt;&gt;&gt; # Use Clarke 1966 instead of default\n&gt;&gt;&gt; azimuth(sac.event, sac.station, ellps='clrk66')\n181.92002\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/azdist.py</code> <pre><code>def azimuth(\n    location_1: Location, location_2: Location, ellps: str = DEFAULT_ELLPS\n) -&gt; float:\n    \"\"\"Calculate azimuth between two points.\n\n\n    Parameters:\n        location_1: Name of the event object providing coordinates of the origin location.\n        location_2: Name of the station object providing coordinates of the target location.\n        ellps: Ellipsoid to use for azimuth calculation\n\n    Returns:\n        Azimuth in degrees from location 1 to location 2.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.azdist import azimuth\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; # the SAC class provides both event and station\n        &gt;&gt;&gt; azimuth(sac.event, sac.station)\n        181.91993\n        &gt;&gt;&gt; # Use Clarke 1966 instead of default\n        &gt;&gt;&gt; azimuth(sac.event, sac.station, ellps='clrk66')\n        181.92002\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    return _azdist(location_1=location_1, location_2=location_2, ellps=ellps)[0]\n</code></pre>"},{"location":"api/pysmo/tools/azdist/#pysmo.tools.azdist.backazimuth","title":"backazimuth","text":"<pre><code>backazimuth(\n    location_1: Location,\n    location_2: Location,\n    ellps: str = DEFAULT_ELLPS,\n) -&gt; float\n</code></pre> <p>Calculate backazimuth (in DEG) between two points.</p> <p>Parameters:</p> <ul> <li> <code>location_1</code>               (<code>Location</code>)           \u2013            <p>Name of the event object providing coordinates of the origin location.</p> </li> <li> <code>location_2</code>               (<code>Location</code>)           \u2013            <p>Name of the station object providing coordinates of the target location.</p> </li> <li> <code>ellps</code>               (<code>str</code>, default:                   <code>DEFAULT_ELLPS</code> )           \u2013            <p>Ellipsoid to use for azimuth calculation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Backzimuth in degrees from point 2 to point 1</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.azdist import backazimuth\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; # the SAC class provides both event and station\n&gt;&gt;&gt; backazimuth(sac.event, sac.station)\n2.467753\n&gt;&gt;&gt; # Use Clarke 1966 instead of default\n&gt;&gt;&gt; backazimuth(sac.event, sac.station, ellps='clrk66')\n2.467847\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/azdist.py</code> <pre><code>def backazimuth(\n    location_1: Location, location_2: Location, ellps: str = DEFAULT_ELLPS\n) -&gt; float:\n    \"\"\"Calculate backazimuth (in DEG) between two points.\n\n    Parameters:\n        location_1: Name of the event object providing coordinates of the origin location.\n        location_2: Name of the station object providing coordinates of the target location.\n        ellps: Ellipsoid to use for azimuth calculation\n\n    Returns:\n        Backzimuth in degrees from point 2 to point 1\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.azdist import backazimuth\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; # the SAC class provides both event and station\n        &gt;&gt;&gt; backazimuth(sac.event, sac.station)\n        2.467753\n        &gt;&gt;&gt; # Use Clarke 1966 instead of default\n        &gt;&gt;&gt; backazimuth(sac.event, sac.station, ellps='clrk66')\n        2.467847\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    return _azdist(location_1=location_1, location_2=location_2, ellps=ellps)[1]\n</code></pre>"},{"location":"api/pysmo/tools/azdist/#pysmo.tools.azdist.distance","title":"distance","text":"<pre><code>distance(\n    location_1: Location,\n    location_2: Location,\n    ellps: str = DEFAULT_ELLPS,\n) -&gt; float\n</code></pre> <p>Calculate the great circle distance (in metres) between two locations.</p> <p>Parameters:</p> <ul> <li> <code>location_1</code>               (<code>Location</code>)           \u2013            <p>Name of the event object providing coordinates of the origin location.</p> </li> <li> <code>location_2</code>               (<code>Location</code>)           \u2013            <p>Name of the station object providing coordinates of the target location.</p> </li> <li> <code>ellps</code>               (<code>str</code>, default:                   <code>DEFAULT_ELLPS</code> )           \u2013            <p>Ellipsoid to use for distance calculation</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Great Circle Distance in metres.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.azdist import distance\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; # the SAC class provides both event and station\n&gt;&gt;&gt; distance(sac.event, sac.station)\n1889154.994\n&gt;&gt;&gt; # Use Clarke 1966 instead of default\n&gt;&gt;&gt; distance(sac.event, sac.station, ellps='clrk66')\n1889121.778\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/azdist.py</code> <pre><code>def distance(\n    location_1: Location, location_2: Location, ellps: str = DEFAULT_ELLPS\n) -&gt; float:\n    \"\"\"Calculate the great circle distance (in metres) between two locations.\n\n    Parameters:\n        location_1: Name of the event object providing coordinates of the origin location.\n        location_2: Name of the station object providing coordinates of the target location.\n        ellps: Ellipsoid to use for distance calculation\n\n    Returns:\n        Great Circle Distance in metres.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.azdist import distance\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; # the SAC class provides both event and station\n        &gt;&gt;&gt; distance(sac.event, sac.station)\n        1889154.994\n        &gt;&gt;&gt; # Use Clarke 1966 instead of default\n        &gt;&gt;&gt; distance(sac.event, sac.station, ellps='clrk66')\n        1889121.778\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    return _azdist(location_1=location_1, location_2=location_2, ellps=ellps)[2]\n</code></pre>"},{"location":"api/pysmo/tools/iccs/","title":"iccs","text":""},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs","title":"pysmo.tools.iccs","text":"<p>Iterative Cross-Correlation and Stack (ICCS).</p> Warning <p>This module is being developed alongside a complete rewrite of AIMBAT. Expect major changes until the rewrite is complete.</p> <p>The ICCS<sup>1</sup> method is an iterative algorithm to rapidly determine the best fitting delay times between an arbitrary number of seismograms with minimal involvement by a human operator. Instead of looking at individual seismograms, parameters are set that control the algorithm, which then iteratively aligns seismograms, or discards them from futher consideration if they are of poor quality.</p> <p>The basic idea of ICCS, is that stacking all seismograms (aligned with respect to an initial, and later improved, phase arrival pick) will lead to the targeted phase arrival becoming visible in the stack. As the stack is generated from all input seismograms, the phase arrival in the stack may be considered a representation of the \"best\" mean arrival time. Each individual seismogram can then be cross-correlated with the stack to determine a time shift that best alligns them with the stack and thus each other.</p> <p>The results of ICCS are are similar to those of the the MCCC<sup>2</sup> method, while also requiring fewer cross-correlations to be computed (each individual seismogram is only cross-correlated with the stack, whereas in MCCC all seismograms are cross-correlated with each other). ICCS is therefore particularly useful to perepare data for a successful MCCC run (e.g. if the initial picks are calculated rather than hand picked).</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs--data-requirements","title":"Data requirements","text":"<p>The <code>iccs</code> module requires seismograms containing extra attributes specific to the ICCS method. Hence it provides a protocol class (<code>ICCSSeismogram</code>) and corresponding Mini class (<code>MiniICCSSeismogram</code>) for that purpose. In addition to the common attributes of a <code>Seismogram</code> in pysmo, the following parameters are required:</p> Attribute Description <code>t0</code> Initial pick (typically     computed). Serves as input only when <code>t1</code> is not set. <code>t1</code> Improved pick.     Serves as both input (if not <code>None</code>) and output (always) when     running the ICCS algorithm. It should     be set to <code>None</code> initially. <code>select</code> Determines if a      seismogram is used for the stack, and should therefore be <code>True</code>     initially. It is set to <code>False</code> for poor quality seismograms     automatically during a run if <code>autoselect</code> is <code>True</code>. Note that     this flag does not exclude a seismogram from being cross-correlated with     the stack. Recovery is therefore possible and previously de-selected     seismograms may be selected again for the next iteration. <code>flip</code> Determines if the     seismogram data should be flipped (i.e. multiplied with -1) before using     it in the stack and cross-correlation. Can be automatically toggled when     <code>autoflip</code>is <code>True</code> during a run. <p>Two things worth mentioning:</p> <ul> <li>Because <code>ICCSSeismogram</code> is a subclass of   <code>Seismogram</code>, it can be used anywhere a basic   <code>Seismogram</code> is expected.</li> <li>All actions performed only effect the attributes listed above. The orignal   <code>data</code>,   <code>begin_time</code>, etc. are   never modified.</li> </ul>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs--execution-flow","title":"Execution flow","text":"<p>The diagram below shows execution flow, and how the above parameters are used when the ICCS algorithm is executed (see here for parameters and default values)':</p> <pre><code>flowchart TD\nStart([\"ICCSSeismograms with initial parameters.\"])\nStack0[\"Generate windowed seismograms and create stack from them.\"]\nC[\"Cross-correlate windowed seismograms with stack to obtain updated picks and normalised correlation coefficients.\"]\nFlipQ{\"Is **autoflip**\nTrue?\"}\nFlip[\"Toggle **flip** attribute of seismograms with negative correlation coefficients.\"]\nQualQ{\"Is **autoselect**\nTrue?\"}\nQual1[\"Toggle **select** attribute of seismograms based on correlation coefficient.\"]\nStack1[\"Recompute windowed seismograms and stack with updated parameters.\"]\nH{\"Convergence\ncriteria met?\"}\nI{\"Maximum\niterations\nreached?\"}\nEnd([\"ICCSSeismograms with updated **t1**, **flip**, and **select** parameters.\"])\nStart --&gt; Stack0 --&gt; C --&gt; FlipQ --&gt;|No| QualQ --&gt;|No| Stack1 --&gt; H --&gt;|No| I --&gt;|No| C\nFlipQ --&gt;|Yes| Flip --&gt; QualQ\nQualQ --&gt;|Yes| Qual1 --&gt;  Stack1\nH --&gt;|Yes| End\nI --&gt;|Yes| End</code></pre> <p>Convergence is reached when the stack iself is not changing significantly anymore between iteration. Typically this happens within a few iterations.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs--operator-involvement","title":"Operator involvement","text":"<p>The ICCS algorithm relies on a few parameters that need to be adjusted by the user. This module provides functions to visualise the stack and individual seismograms (all at the same time), and to update the parameters based on visual inspection.</p> <ol> <li> <p>Lou, X., et al. \u201cAIMBAT: A Python/Matplotlib Tool for Measuring Teleseismic Arrival Times.\u201d Seismological Research Letters, vol. 84, no. 1, Jan. 2013, pp. 85\u201393, https://doi.org/10.1785/0220120033.\u00a0\u21a9</p> </li> <li> <p>VanDecar, J. C., and R. S. Crosson. \u201cDetermination of Teleseismic Relative Phase Arrival Times Using Multi-Channel Cross-Correlation and Least Squares.\u201d Bulletin of the Seismological Society of America, vol. 80, no. 1, Feb. 1990, pp. 150\u201369, https://doi.org/10.1785/BSSA0800010150.\u00a0\u21a9</p> </li> </ol> <p>Classes:</p> <ul> <li> <code>ICCS</code>           \u2013            <p>Class to store a list of <code>ICCSSeismograms</code> and run the ICCS algorithm.</p> </li> <li> <code>ICCSSeismogram</code>           \u2013            <p>Protocol class to define the <code>ICCSSeismogram</code> type.</p> </li> <li> <code>MiniICCSSeismogram</code>           \u2013            <p>Minimal implementation of the <code>ICCSSeismogram</code> type.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>plot_seismograms</code>             \u2013              <p>Plot the selected ICCS seismograms as an image.</p> </li> <li> <code>plot_stack</code>             \u2013              <p>Plot the ICCS stack.</p> </li> <li> <code>update_all_picks</code>             \u2013              <p>Update <code>t1</code> in all seismograms by the same amount.</p> </li> <li> <code>update_min_ccnorm</code>             \u2013              <p>Interactively pick a new <code>min_ccnorm</code>.</p> </li> <li> <code>update_pick</code>             \u2013              <p>Manually pick <code>t1</code> and apply it to all seismograms.</p> </li> <li> <code>update_timewindow</code>             \u2013              <p>Pick new time window limits.</p> </li> </ul>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS","title":"ICCS","text":"<p>Class to store a list of <code>ICCSSeismograms</code> and run the ICCS algorithm.</p> <p>The <code>ICCS</code> class serves as a container to store a list of seismograms (typically recordings of the same event at different stations), and to then run the ICCS algorithm when an instance of this class is called. Processing parameters that are common to all seismograms are stored as attributes (e.g. time window limits).</p> <p>Examples:</p> <p>We begin with a set of SAC files of the same event, recorded at different stations. All files have a preliminary phase arrival estimate saved in the <code>T0</code> SAC header, so we can use these files to create instances of the <code>MiniICCSSeismogram</code> class for use with the <code>ICCS</code> class:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.functions import clone_to_mini\n&gt;&gt;&gt; from pysmo.tools.iccs import MiniICCSSeismogram\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt;\n&gt;&gt;&gt; sacfiles = sorted(Path(\"iccs-example/\").glob(\"*.bhz\"))\n&gt;&gt;&gt;\n&gt;&gt;&gt; seismograms = []\n&gt;&gt;&gt; for sacfile in sacfiles:\n...     sac = SAC.from_file(sacfile)\n...     update = {\"t0\": sac.timestamps.t0}\n...     iccs_seismogram = clone_to_mini(MiniICCSSeismogram, sac.seismogram, update=update)\n...     seismograms.append(iccs_seismogram)\n...\n&gt;&gt;&gt;\n</code></pre> <p>To better illustrate the different modes of running the ICCS algorithm, we modify the data and picks in the seismograms to make them worse than they actually are:</p> <pre><code>&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; from copy import deepcopy\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt;\n&gt;&gt;&gt; # change the sign of the data in the first seismogram\n&gt;&gt;&gt; seismograms[0].data *= -1\n&gt;&gt;&gt;\n&gt;&gt;&gt; # move the initial pick 2 seconds earlier in second seismogram\n&gt;&gt;&gt; seismograms[1].t0 += timedelta(seconds=-2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # move the initial pick 2 seconds later in third seismogram\n&gt;&gt;&gt; seismograms[2].t0 += timedelta(seconds=2)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # create a seismogram with completely random data\n&gt;&gt;&gt; iccs_random: MiniICCSSeismogram = deepcopy(seismograms[-1])\n&gt;&gt;&gt; np.random.seed(42)  # set this for consistent results during testing\n&gt;&gt;&gt; iccs_random.data = np.random.rand(len(iccs_random))\n&gt;&gt;&gt; seismograms.append(iccs_random)\n&gt;&gt;&gt;\n</code></pre> <p>We can now create an instance of the <code>ICCS</code> class and plot the initial stack together with the input seismograms:</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.iccs import ICCS, plot_stack\n&gt;&gt;&gt; iccs = ICCS(seismograms)\n&gt;&gt;&gt; plot_stack(iccs, padded=False)\n&gt;&gt;&gt;\n</code></pre> <p> </p> <p>The phase emergance is not visible in the stack, and the (absolute) correlation coefficents of the the seismograms are not very high. This shows the initial picks are not very good and/or that the data are of low quality. To run the ICCS algorithm, we simply call (execute) the ICCS instance:</p> <pre><code>&gt;&gt;&gt; convergence_list = iccs()  # this runs the ICCS algorithm and returns\n&gt;&gt;&gt;                            # a list of the convergence value after each\n&gt;&gt;&gt;                            # iteration.\n&gt;&gt;&gt; plot_stack(iccs, padded=False)\n&gt;&gt;&gt;\n</code></pre> <p> </p> <p>Despite of the random noise seismogram, the phase arrival is now visible in the stack. Seismograms with low correlation coefficients can automatically be deselected from the calculations by running ICCS again with <code>autoselect=True</code>:</p> <pre><code>&gt;&gt;&gt; _ = iccs(autoselect=True)\n&gt;&gt;&gt; plot_stack(iccs, padded=False)\n&gt;&gt;&gt;\n</code></pre> <p> </p> <p>Seismograms that fit better with their polarity reversed can be flipped automatically by setting <code>autoflip=True</code>:</p> <pre><code>&gt;&gt;&gt; _ = iccs(autoflip=True)\n&gt;&gt;&gt; plot_stack(iccs, padded=False)\n&gt;&gt;&gt;\n</code></pre> <p> </p> <p>To further improve results, you can interactively update the picks, time window, and minimum correlation coefficient using <code>update_pick</code>, <code>update_timewindow</code>, and <code>update_min_ccnorm</code>, respectively, and then run the ICCS algorithm again.</p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              <p>Run the iccs algorithm.</p> </li> <li> <code>validate_pick</code>             \u2013              <p>Check if a new pick is valid.</p> </li> <li> <code>validate_time_window</code>             \u2013              <p>Check if a new time window (relative to pick) is valid.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>cc_seismograms</code>               (<code>list[MiniSeismogram]</code>)           \u2013            <p>Returns the seismograms as used for the cross-correlation.</p> </li> <li> <code>ccnorms</code>               (<code>ndarray</code>)           \u2013            <p>Returns an array of the normalised cross-correlation coefficients.</p> </li> <li> <code>min_ccnorm</code>               (<code>floating | float</code>)           \u2013            <p>Minimum normalised cross-correlation coefficient for seismograms.</p> </li> <li> <code>padded_seismograms</code>               (<code>list[MiniSeismogram]</code>)           \u2013            <p>Returns the seismograms with extra padding for plotting.</p> </li> <li> <code>padded_stack</code>               (<code>MiniSeismogram</code>)           \u2013            <p>Returns the stacked <code>padded_seismograms</code>.</p> </li> <li> <code>plot_padding</code>               (<code>timedelta</code>)           \u2013            <p>Padding to apply before and after the time window.</p> </li> <li> <code>seismograms</code>               (<code>Sequence[ICCSSeismogram]</code>)           \u2013            <p>Input seismograms.</p> </li> <li> <code>stack</code>               (<code>MiniSeismogram</code>)           \u2013            <p>Returns the stacked <code>cc_seismograms</code>).</p> </li> <li> <code>taper_width</code>               (<code>timedelta | float</code>)           \u2013            <p>Taper width.</p> </li> <li> <code>window_post</code>               (<code>timedelta</code>)           \u2013            <p>End of the time window relative to the pick.</p> </li> <li> <code>window_pre</code>               (<code>timedelta</code>)           \u2013            <p>Begining of the time window relative to the pick.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_iccs.py</code> <pre><code>@define(slots=True)\nclass ICCS:\n    \"\"\"Class to store a list of [`ICCSSeismograms`][pysmo.tools.iccs.ICCSSeismogram] and run the ICCS algorithm.\n\n    The [`ICCS`][pysmo.tools.iccs.ICCS] class serves as a container to store a\n    list of seismograms (typically recordings of the same event at different\n    stations), and to then run the ICCS algorithm when an instance of this\n    class is called. Processing parameters that are common to all seismograms\n    are stored as attributes (e.g. time window limits).\n\n    Examples:\n        We begin with a set of SAC files of the same event, recorded at different\n        stations. All files have a preliminary phase arrival estimate saved in the\n        `T0` SAC header, so we can use these files to create instances of the\n        [`MiniICCSSeismogram`][pysmo.tools.iccs.MiniICCSSeismogram] class for use\n        with the [`ICCS`][pysmo.tools.iccs.ICCS] class:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.functions import clone_to_mini\n        &gt;&gt;&gt; from pysmo.tools.iccs import MiniICCSSeismogram\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; sacfiles = sorted(Path(\"iccs-example/\").glob(\"*.bhz\"))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; seismograms = []\n        &gt;&gt;&gt; for sacfile in sacfiles:\n        ...     sac = SAC.from_file(sacfile)\n        ...     update = {\"t0\": sac.timestamps.t0}\n        ...     iccs_seismogram = clone_to_mini(MiniICCSSeismogram, sac.seismogram, update=update)\n        ...     seismograms.append(iccs_seismogram)\n        ...\n        &gt;&gt;&gt;\n        ```\n\n        To better illustrate the different modes of running the ICCS algorithm, we\n        modify the data and picks in the seismograms to make them **worse** than\n        they actually are:\n\n        ```python\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; from copy import deepcopy\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # change the sign of the data in the first seismogram\n        &gt;&gt;&gt; seismograms[0].data *= -1\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # move the initial pick 2 seconds earlier in second seismogram\n        &gt;&gt;&gt; seismograms[1].t0 += timedelta(seconds=-2)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # move the initial pick 2 seconds later in third seismogram\n        &gt;&gt;&gt; seismograms[2].t0 += timedelta(seconds=2)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # create a seismogram with completely random data\n        &gt;&gt;&gt; iccs_random: MiniICCSSeismogram = deepcopy(seismograms[-1])\n        &gt;&gt;&gt; np.random.seed(42)  # set this for consistent results during testing\n        &gt;&gt;&gt; iccs_random.data = np.random.rand(len(iccs_random))\n        &gt;&gt;&gt; seismograms.append(iccs_random)\n        &gt;&gt;&gt;\n        ```\n\n        We can now create an instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class\n        and plot the initial stack together with the input seismograms:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.iccs import ICCS, plot_stack\n        &gt;&gt;&gt; iccs = ICCS(seismograms)\n        &gt;&gt;&gt; plot_stack(iccs, padded=False)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_initial-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_initial.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Initial stack](../../../examples/figures/iccs_stack_initial.png#only-light){ loading=lazy }\n        ![Initial stack](../../../examples/figures/iccs_stack_initial-dark.png#only-dark){ loading=lazy }\n\n        The phase emergance is not visible in the stack, and the (absolute)\n        correlation coefficents of the the seismograms are not very high. This\n        shows the initial picks are not very good and/or that the data are of low\n        quality. To run the ICCS algorithm, we simply call (execute) the ICCS\n        instance:\n\n        ```python\n        &gt;&gt;&gt; convergence_list = iccs()  # this runs the ICCS algorithm and returns\n        &gt;&gt;&gt;                            # a list of the convergence value after each\n        &gt;&gt;&gt;                            # iteration.\n        &gt;&gt;&gt; plot_stack(iccs, padded=False)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_first_run-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_first_run.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Stack after first run](../../../examples/figures/iccs_stack_first_run.png#only-light){ loading=lazy }\n        ![Stack after first run](../../../examples/figures/iccs_stack_first_run-dark.png#only-dark){ loading=lazy }\n\n        Despite of the random noise seismogram, the phase arrival is now visible in\n        the stack. Seismograms with low correlation coefficients can automatically\n        be deselected from the calculations by running ICCS again with\n        `autoselect=True`:\n\n\n        ```python\n        &gt;&gt;&gt; _ = iccs(autoselect=True)\n        &gt;&gt;&gt; plot_stack(iccs, padded=False)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_autoselect-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_autoselect.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Stack after run with autoselect](../../../examples/figures/iccs_stack_autoselect.png#only-light){ loading=lazy }\n        ![Stack after run with autoselect](../../../examples/figures/iccs_stack_autoselect-dark.png#only-dark){ loading=lazy }\n\n\n        Seismograms that fit better with their polarity reversed can be flipped\n        automatically by setting `autoflip=True`:\n\n        ```python\n        &gt;&gt;&gt; _ = iccs(autoflip=True)\n        &gt;&gt;&gt; plot_stack(iccs, padded=False)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_autoflip-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_stack_autoflip.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Stack after run with autoflip](../../../examples/figures/iccs_stack_autoflip.png#only-light){ loading=lazy }\n        ![Stack after run with autoflip](../../../examples/figures/iccs_stack_autoflip-dark.png#only-dark){ loading=lazy }\n\n\n        To further improve results, you can interactively update the picks,\n        time window, and minimum correlation coefficient using\n        [`update_pick`][pysmo.tools.iccs.update_pick],\n        [`update_timewindow`][pysmo.tools.iccs.update_timewindow], and\n        [`update_min_ccnorm`][pysmo.tools.iccs.update_min_ccnorm],\n        respectively, and then run the ICCS algorithm again.\n    \"\"\"\n\n    seismograms: Sequence[ICCSSeismogram] = field(\n        factory=lambda: list[ICCSSeismogram](), validator=_clear_cache_on_update\n    )\n    \"\"\"Input seismograms.\n\n    These seismograms provide the input data for ICCS. They are used to store\n    processing parameters and create shorter seismograms (based on pick and\n    time window) that are then used for cross-correlation. The shorter\n    seismograms are created on the fly and then cached within an [`ICCS`]\n    [pysmo.tools.iccs.ICCS] instance.\n    \"\"\"\n\n    window_pre: timedelta = field(\n        default=ICCS_DEFAULTS.WINDOW_PRE,\n        validator=[\n            validators.lt(timedelta(seconds=0)),\n            _validate_window_pre,\n            _clear_cache_on_update,\n        ],\n    )\n    \"\"\"Begining of the time window relative to the pick.\"\"\"\n\n    window_post: timedelta = field(\n        default=ICCS_DEFAULTS.WINDOW_POST,\n        validator=[\n            validators.gt(timedelta(seconds=0)),\n            _validate_window_post,\n            _clear_cache_on_update,\n        ],\n    )\n    \"\"\"End of the time window relative to the pick.\"\"\"\n\n    plot_padding: timedelta = field(\n        default=ICCS_DEFAULTS.PLOT_PADDING,\n        validator=[validators.gt(timedelta(seconds=0)), _clear_cache_on_update],\n    )\n    \"\"\"Padding to apply before and after the time window.\n\n    This padding is *not* used for the cross-correlation.\"\"\"\n\n    taper_width: timedelta | float = field(\n        default=ICCS_DEFAULTS.TAPER_WIDTH, validator=_clear_cache_on_update\n    )\n    \"\"\"Taper width.\n\n    Can be either a timedelta or a float - see [`pysmo.functions.taper()`][pysmo.functions.taper]\n    for details.\n    \"\"\"\n\n    min_ccnorm: np.floating | float = ICCS_DEFAULTS.MIN_CCNORM\n    \"\"\"Minimum normalised cross-correlation coefficient for seismograms.\n\n    When the ICCS algorithm is [executed][pysmo.tools.iccs.ICCS.__call__],\n    the cross-correlation coefficient for each seismogram is calculated after\n    each iteration. If `autoselect` is set to `True`, the\n    [`select`][pysmo.tools.iccs.ICCSSeismogram.select] attribute of seismograms\n    with with correlation coefficients below this value is set to `False`, and\n    they are no longer used for the [`stack`][pysmo.tools.iccs.ICCS.stack].\n    \"\"\"\n\n    # The following attributes are cached to prevent unnecessary processing.\n    # Setting the caches to None will force a new calculation when they are\n    # requested.\n    _cc_seismograms: list[MiniSeismogram] | None = field(init=False)\n    _padded_seismograms: list[MiniSeismogram] | None = field(init=False)\n    _ccnorms: np.ndarray | None = field(init=False)\n    _cc_stack: MiniSeismogram | None = field(init=False)\n    _padded_stack: MiniSeismogram | None = field(init=False)\n    _valid_pick_range: tuple[timedelta, timedelta] | None = field(init=False)\n    _valid_time_window_range: tuple[timedelta, timedelta] | None = field(init=False)\n\n    def __attrs_post_init__(self) -&gt; None:\n        self._clear_caches()\n\n    def _clear_caches(self) -&gt; None:\n        \"\"\"Clear all cached attributes.\"\"\"\n        self._cc_seismograms = None\n        self._padded_seismograms = None\n        self._ccnorms = None\n        self._cc_stack = None\n        self._padded_stack = None\n        self._valid_pick_range = None\n        self._valid_time_window_range = None\n\n    @property\n    def cc_seismograms(self) -&gt; list[MiniSeismogram]:\n        \"\"\"Returns the seismograms as used for the cross-correlation.\"\"\"\n\n        if self._cc_seismograms is None:\n            self._cc_seismograms = _prepare_seismograms(\n                self.seismograms,\n                self.window_pre,\n                self.window_post,\n                self.taper_width,\n            )\n\n        return self._cc_seismograms\n\n    @property\n    def padded_seismograms(self) -&gt; list[MiniSeismogram]:\n        \"\"\"Returns the seismograms with extra padding for plotting.\"\"\"\n\n        if self._padded_seismograms is None:\n            self._padded_seismograms = _prepare_seismograms(\n                self.seismograms,\n                self.window_pre,\n                self.window_post,\n                self.taper_width,\n                True,\n                self.plot_padding,\n            )\n\n        return self._padded_seismograms\n\n    @property\n    def ccnorms(self) -&gt; np.ndarray:\n        \"\"\"Returns an array of the normalised cross-correlation coefficients.\"\"\"\n\n        if self._ccnorms is None:\n            self._ccnorms = _calc_ccnorms(self.cc_seismograms, self.stack)\n\n        return self._ccnorms\n\n    @property\n    def stack(self) -&gt; MiniSeismogram:\n        \"\"\"Returns the stacked [`cc_seismograms`][pysmo.tools.iccs.ICCS.cc_seismograms]).\n\n        The stack is calculated as the average of all seismograms with the\n        attribute [`select`][pysmo.tools.iccs.ICCSSeismogram.select] set to\n        [`True`][True]. The [`begin_time`][pysmo.MiniSeismogram.begin_time] of\n        the returned stack is the average of the [`begin_time`]\n        [pysmo.tools.iccs.ICCSSeismogram.begin_time] of the input seismograms.\n\n        Returns:\n            Stacked input seismograms.\n        \"\"\"\n        if self._cc_stack is not None:\n            return self._cc_stack\n\n        self._cc_stack = _create_stack(self.cc_seismograms, self.seismograms)\n        return self._cc_stack\n\n    @property\n    def padded_stack(self) -&gt; MiniSeismogram:\n        \"\"\"Returns the stacked [`padded_seismograms`][pysmo.tools.iccs.ICCS.padded_seismograms].\n\n        Returns:\n            Stacked input seismograms.\n        \"\"\"\n        if self._padded_stack is not None:\n            return self._padded_stack\n\n        self._padded_stack = _create_stack(self.padded_seismograms, self.seismograms)\n        return self._padded_stack\n\n    def validate_pick(self, pick: timedelta) -&gt; bool:\n        \"\"\"Check if a new pick is valid.\n\n        This checks if a new manual pick is valid for all selected seismograms.\n\n        Parameters:\n            pick: New pick to validate.\n\n        Returns:\n            Whether the new pick is valid.\n        \"\"\"\n\n        # first calculate valid pick range if not done yet\n        if self._valid_pick_range is None:\n            self._valid_pick_range = _calc_valid_pick_range(self)\n\n        if self._valid_pick_range[0] &lt;= pick &lt;= self._valid_pick_range[1]:\n            return True\n        return False\n\n    def validate_time_window(\n        self, window_pre: timedelta, window_post: timedelta\n    ) -&gt; bool:\n        \"\"\"Check if a new time window (relative to pick) is valid.\n\n        Parameters:\n            window_pre: New window start time to validate.\n            window_post: New window end time to validate.\n\n        Returns:\n            Whether the new time window is valid.\n        \"\"\"\n\n        if window_pre &gt;= window_post:\n            return False\n\n        if window_pre &gt; -self.stack.delta:\n            return False\n\n        if window_post &lt; self.stack.delta:\n            return False\n\n        # Calculate valid time window range if not done yet\n        if self._valid_time_window_range is None:\n            self._valid_time_window_range = _calc_valid_time_window_range(self)\n\n        if (\n            self._valid_time_window_range[0] &lt;= window_pre\n            and window_post &lt;= self._valid_time_window_range[1]\n        ):\n            return True\n        return False\n\n    def __call__(\n        self,\n        autoflip: bool = False,\n        autoselect: bool = False,\n        convergence_limit: float = ICCS_DEFAULTS.CONVERGENCE_LIMIT,\n        convergence_method: CONVERGENCE_METHOD = ICCS_DEFAULTS.CONVERGENCE_METHOD,\n        max_iter: int = ICCS_DEFAULTS.MAX_ITER,\n        max_shift: timedelta | None = None,\n        parallel: bool = False,\n    ) -&gt; np.ndarray:\n        \"\"\"Run the iccs algorithm.\n\n        Parameters:\n            autoflip: Automatically toggle [`flip`][pysmo.tools.iccs.ICCSSeismogram.flip] attribute of seismograms.\n            autoselect: Automatically set `select` attribute to `False` for poor quality seismograms.\n            convergence_limit: Convergence limit at which the algorithm stops.\n            convergence_method: Method to calculate convergence criterion.\n            max_iter: Maximum number of iterations.\n            max_shift: Maximum shift in seconds (see [`delay()`][pysmo.tools.signal.delay]).\n            parallel: Whether to use parallel processing. Setting this to `True`\n                will perform the cross-correlation calculations in parallel\n                using [`ProcessPoolExecutor`][concurrent.futures.ProcessPoolExecutor].\n                In most cases this will *not* be faster.\n\n        Returns:\n            convergence: Array of convergence criterion values.\n        \"\"\"\n        convergence_list = []\n\n        for _ in range(max_iter):\n            prev_stack = clone_to_mini(MiniSeismogram, self.stack)\n\n            if parallel:\n                with ProcessPoolExecutor() as executor:\n                    for prepared_seismogram, seismogram in zip(\n                        self.cc_seismograms, self.seismograms\n                    ):\n                        future = executor.submit(\n                            delay,\n                            self.stack,\n                            prepared_seismogram,\n                            max_shift=max_shift,\n                            abs_max=autoflip,\n                        )\n                        future.add_done_callback(\n                            partial(\n                                _update_seismogram_fn,\n                                seismogram,\n                                autoflip,\n                                autoselect,\n                                self.min_ccnorm,\n                                (self.window_pre, self.window_post),\n                            )\n                        )\n            else:\n                for prepared_seismogram, seismogram in zip(\n                    self.cc_seismograms, self.seismograms\n                ):\n                    _delay, _ccnorm = delay(\n                        self.stack,\n                        prepared_seismogram,\n                        max_shift=max_shift,\n                        abs_max=autoflip,\n                    )\n\n                    _update_seismogram(\n                        _delay,\n                        _ccnorm,\n                        seismogram,\n                        autoflip,\n                        autoselect,\n                        self.min_ccnorm,\n                        (self.window_pre, self.window_post),\n                    )\n\n            self._clear_caches()\n\n            convergence = _calc_convergence(self.stack, prev_stack, convergence_method)\n            convergence_list.append(convergence)\n            if convergence &lt;= convergence_limit:\n                break\n\n        return np.array(convergence_list)\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.cc_seismograms","title":"cc_seismograms  <code>property</code>","text":"<pre><code>cc_seismograms: list[MiniSeismogram]\n</code></pre> <p>Returns the seismograms as used for the cross-correlation.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.ccnorms","title":"ccnorms  <code>property</code>","text":"<pre><code>ccnorms: ndarray\n</code></pre> <p>Returns an array of the normalised cross-correlation coefficients.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.min_ccnorm","title":"min_ccnorm  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_ccnorm: floating | float = MIN_CCNORM\n</code></pre> <p>Minimum normalised cross-correlation coefficient for seismograms.</p> <p>When the ICCS algorithm is executed, the cross-correlation coefficient for each seismogram is calculated after each iteration. If <code>autoselect</code> is set to <code>True</code>, the <code>select</code> attribute of seismograms with with correlation coefficients below this value is set to <code>False</code>, and they are no longer used for the <code>stack</code>.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.padded_seismograms","title":"padded_seismograms  <code>property</code>","text":"<pre><code>padded_seismograms: list[MiniSeismogram]\n</code></pre> <p>Returns the seismograms with extra padding for plotting.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.padded_stack","title":"padded_stack  <code>property</code>","text":"<pre><code>padded_stack: MiniSeismogram\n</code></pre> <p>Returns the stacked <code>padded_seismograms</code>.</p> <p>Returns:</p> <ul> <li> <code>MiniSeismogram</code>           \u2013            <p>Stacked input seismograms.</p> </li> </ul>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.plot_padding","title":"plot_padding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plot_padding: timedelta = field(\n    default=PLOT_PADDING,\n    validator=[\n        gt(timedelta(seconds=0)),\n        _clear_cache_on_update,\n    ],\n)\n</code></pre> <p>Padding to apply before and after the time window.</p> <p>This padding is not used for the cross-correlation.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.seismograms","title":"seismograms  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>seismograms: Sequence[ICCSSeismogram] = field(\n    factory=lambda: list[ICCSSeismogram](),\n    validator=_clear_cache_on_update,\n)\n</code></pre> <p>Input seismograms.</p> <p>These seismograms provide the input data for ICCS. They are used to store processing parameters and create shorter seismograms (based on pick and time window) that are then used for cross-correlation. The shorter seismograms are created on the fly and then cached within an <code>ICCS</code> instance.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.stack","title":"stack  <code>property</code>","text":"<pre><code>stack: MiniSeismogram\n</code></pre> <p>Returns the stacked <code>cc_seismograms</code>).</p> <p>The stack is calculated as the average of all seismograms with the attribute <code>select</code> set to <code>True</code>. The <code>begin_time</code> of the returned stack is the average of the <code>begin_time</code> of the input seismograms.</p> <p>Returns:</p> <ul> <li> <code>MiniSeismogram</code>           \u2013            <p>Stacked input seismograms.</p> </li> </ul>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.taper_width","title":"taper_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>taper_width: timedelta | float = field(\n    default=TAPER_WIDTH, validator=_clear_cache_on_update\n)\n</code></pre> <p>Taper width.</p> <p>Can be either a timedelta or a float - see <code>pysmo.functions.taper()</code> for details.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.window_post","title":"window_post  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>window_post: timedelta = field(\n    default=WINDOW_POST,\n    validator=[\n        gt(timedelta(seconds=0)),\n        _validate_window_post,\n        _clear_cache_on_update,\n    ],\n)\n</code></pre> <p>End of the time window relative to the pick.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.window_pre","title":"window_pre  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>window_pre: timedelta = field(\n    default=WINDOW_PRE,\n    validator=[\n        lt(timedelta(seconds=0)),\n        _validate_window_pre,\n        _clear_cache_on_update,\n    ],\n)\n</code></pre> <p>Begining of the time window relative to the pick.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.__call__","title":"__call__","text":"<pre><code>__call__(\n    autoflip: bool = False,\n    autoselect: bool = False,\n    convergence_limit: float = CONVERGENCE_LIMIT,\n    convergence_method: CONVERGENCE_METHOD = CONVERGENCE_METHOD,\n    max_iter: int = MAX_ITER,\n    max_shift: timedelta | None = None,\n    parallel: bool = False,\n) -&gt; ndarray\n</code></pre> <p>Run the iccs algorithm.</p> <p>Parameters:</p> <ul> <li> <code>autoflip</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Automatically toggle <code>flip</code> attribute of seismograms.</p> </li> <li> <code>autoselect</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Automatically set <code>select</code> attribute to <code>False</code> for poor quality seismograms.</p> </li> <li> <code>convergence_limit</code>               (<code>float</code>, default:                   <code>CONVERGENCE_LIMIT</code> )           \u2013            <p>Convergence limit at which the algorithm stops.</p> </li> <li> <code>convergence_method</code>               (<code>CONVERGENCE_METHOD</code>, default:                   <code>CONVERGENCE_METHOD</code> )           \u2013            <p>Method to calculate convergence criterion.</p> </li> <li> <code>max_iter</code>               (<code>int</code>, default:                   <code>MAX_ITER</code> )           \u2013            <p>Maximum number of iterations.</p> </li> <li> <code>max_shift</code>               (<code>timedelta | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum shift in seconds (see <code>delay()</code>).</p> </li> <li> <code>parallel</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use parallel processing. Setting this to <code>True</code> will perform the cross-correlation calculations in parallel using <code>ProcessPoolExecutor</code>. In most cases this will not be faster.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>convergence</code> (              <code>ndarray</code> )          \u2013            <p>Array of convergence criterion values.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_iccs.py</code> <pre><code>def __call__(\n    self,\n    autoflip: bool = False,\n    autoselect: bool = False,\n    convergence_limit: float = ICCS_DEFAULTS.CONVERGENCE_LIMIT,\n    convergence_method: CONVERGENCE_METHOD = ICCS_DEFAULTS.CONVERGENCE_METHOD,\n    max_iter: int = ICCS_DEFAULTS.MAX_ITER,\n    max_shift: timedelta | None = None,\n    parallel: bool = False,\n) -&gt; np.ndarray:\n    \"\"\"Run the iccs algorithm.\n\n    Parameters:\n        autoflip: Automatically toggle [`flip`][pysmo.tools.iccs.ICCSSeismogram.flip] attribute of seismograms.\n        autoselect: Automatically set `select` attribute to `False` for poor quality seismograms.\n        convergence_limit: Convergence limit at which the algorithm stops.\n        convergence_method: Method to calculate convergence criterion.\n        max_iter: Maximum number of iterations.\n        max_shift: Maximum shift in seconds (see [`delay()`][pysmo.tools.signal.delay]).\n        parallel: Whether to use parallel processing. Setting this to `True`\n            will perform the cross-correlation calculations in parallel\n            using [`ProcessPoolExecutor`][concurrent.futures.ProcessPoolExecutor].\n            In most cases this will *not* be faster.\n\n    Returns:\n        convergence: Array of convergence criterion values.\n    \"\"\"\n    convergence_list = []\n\n    for _ in range(max_iter):\n        prev_stack = clone_to_mini(MiniSeismogram, self.stack)\n\n        if parallel:\n            with ProcessPoolExecutor() as executor:\n                for prepared_seismogram, seismogram in zip(\n                    self.cc_seismograms, self.seismograms\n                ):\n                    future = executor.submit(\n                        delay,\n                        self.stack,\n                        prepared_seismogram,\n                        max_shift=max_shift,\n                        abs_max=autoflip,\n                    )\n                    future.add_done_callback(\n                        partial(\n                            _update_seismogram_fn,\n                            seismogram,\n                            autoflip,\n                            autoselect,\n                            self.min_ccnorm,\n                            (self.window_pre, self.window_post),\n                        )\n                    )\n        else:\n            for prepared_seismogram, seismogram in zip(\n                self.cc_seismograms, self.seismograms\n            ):\n                _delay, _ccnorm = delay(\n                    self.stack,\n                    prepared_seismogram,\n                    max_shift=max_shift,\n                    abs_max=autoflip,\n                )\n\n                _update_seismogram(\n                    _delay,\n                    _ccnorm,\n                    seismogram,\n                    autoflip,\n                    autoselect,\n                    self.min_ccnorm,\n                    (self.window_pre, self.window_post),\n                )\n\n        self._clear_caches()\n\n        convergence = _calc_convergence(self.stack, prev_stack, convergence_method)\n        convergence_list.append(convergence)\n        if convergence &lt;= convergence_limit:\n            break\n\n    return np.array(convergence_list)\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.validate_pick","title":"validate_pick","text":"<pre><code>validate_pick(pick: timedelta) -&gt; bool\n</code></pre> <p>Check if a new pick is valid.</p> <p>This checks if a new manual pick is valid for all selected seismograms.</p> <p>Parameters:</p> <ul> <li> <code>pick</code>               (<code>timedelta</code>)           \u2013            <p>New pick to validate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the new pick is valid.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_iccs.py</code> <pre><code>def validate_pick(self, pick: timedelta) -&gt; bool:\n    \"\"\"Check if a new pick is valid.\n\n    This checks if a new manual pick is valid for all selected seismograms.\n\n    Parameters:\n        pick: New pick to validate.\n\n    Returns:\n        Whether the new pick is valid.\n    \"\"\"\n\n    # first calculate valid pick range if not done yet\n    if self._valid_pick_range is None:\n        self._valid_pick_range = _calc_valid_pick_range(self)\n\n    if self._valid_pick_range[0] &lt;= pick &lt;= self._valid_pick_range[1]:\n        return True\n    return False\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCS.validate_time_window","title":"validate_time_window","text":"<pre><code>validate_time_window(\n    window_pre: timedelta, window_post: timedelta\n) -&gt; bool\n</code></pre> <p>Check if a new time window (relative to pick) is valid.</p> <p>Parameters:</p> <ul> <li> <code>window_pre</code>               (<code>timedelta</code>)           \u2013            <p>New window start time to validate.</p> </li> <li> <code>window_post</code>               (<code>timedelta</code>)           \u2013            <p>New window end time to validate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the new time window is valid.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_iccs.py</code> <pre><code>def validate_time_window(\n    self, window_pre: timedelta, window_post: timedelta\n) -&gt; bool:\n    \"\"\"Check if a new time window (relative to pick) is valid.\n\n    Parameters:\n        window_pre: New window start time to validate.\n        window_post: New window end time to validate.\n\n    Returns:\n        Whether the new time window is valid.\n    \"\"\"\n\n    if window_pre &gt;= window_post:\n        return False\n\n    if window_pre &gt; -self.stack.delta:\n        return False\n\n    if window_post &lt; self.stack.delta:\n        return False\n\n    # Calculate valid time window range if not done yet\n    if self._valid_time_window_range is None:\n        self._valid_time_window_range = _calc_valid_time_window_range(self)\n\n    if (\n        self._valid_time_window_range[0] &lt;= window_pre\n        and window_post &lt;= self._valid_time_window_range[1]\n    ):\n        return True\n    return False\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram","title":"ICCSSeismogram","text":"<p>               Bases: <code>Seismogram</code>, <code>Protocol</code></p> <p>Protocol class to define the <code>ICCSSeismogram</code> type.</p> <p>The <code>ICCSSeismogram</code> type extends the <code>Seismogram</code> type with the addition of parameters that are required for ICCS.</p> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              <p>The length of the Seismogram.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram begin time.</p> </li> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Seismogram data.</p> </li> <li> <code>delta</code>               (<code>timedelta</code>)           \u2013            <p>The sampling interval.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram end time.</p> </li> <li> <code>flip</code>               (<code>bool</code>)           \u2013            <p>Data in seismogram should be flipped for ICCS.</p> </li> <li> <code>select</code>               (<code>bool</code>)           \u2013            <p>Use seismogram to create stack.</p> </li> <li> <code>t0</code>               (<code>datetime</code>)           \u2013            <p>Initial pick.</p> </li> <li> <code>t1</code>               (<code>datetime | None</code>)           \u2013            <p>Updated pick.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_types.py</code> <pre><code>@runtime_checkable\nclass ICCSSeismogram(Seismogram, Protocol):\n    \"\"\"Protocol class to define the `ICCSSeismogram` type.\n\n    The `ICCSSeismogram` type extends the [`Seismogram`][pysmo.Seismogram] type\n    with the addition of parameters that are required for ICCS.\n    \"\"\"\n\n    @property\n    def flip(self) -&gt; bool:\n        \"\"\"Data in seismogram should be flipped for ICCS.\"\"\"\n        ...\n\n    @flip.setter\n    def flip(self, value: bool) -&gt; None: ...\n\n    @property\n    def select(self) -&gt; bool:\n        \"\"\"Use seismogram to create stack.\"\"\"\n        ...\n\n    @select.setter\n    def select(self, value: bool) -&gt; None: ...\n\n    @property\n    def t0(self) -&gt; datetime:\n        \"\"\"Initial pick.\"\"\"\n        ...\n\n    @t0.setter\n    def t0(self, value: datetime) -&gt; None: ...\n\n    @property\n    def t1(self) -&gt; datetime | None:\n        \"\"\"Updated pick.\"\"\"\n        ...\n\n    @t1.setter\n    def t1(self, value: datetime | None) -&gt; None: ...\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.begin_time","title":"begin_time  <code>property</code> <code>writable</code>","text":"<pre><code>begin_time: datetime\n</code></pre> <p>Seismogram begin time.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.data","title":"data  <code>property</code> <code>writable</code>","text":"<pre><code>data: ndarray\n</code></pre> <p>Seismogram data.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.delta","title":"delta  <code>property</code> <code>writable</code>","text":"<pre><code>delta: timedelta\n</code></pre> <p>The sampling interval.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.end_time","title":"end_time  <code>property</code>","text":"<pre><code>end_time: datetime\n</code></pre> <p>Seismogram end time.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.flip","title":"flip  <code>property</code> <code>writable</code>","text":"<pre><code>flip: bool\n</code></pre> <p>Data in seismogram should be flipped for ICCS.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.select","title":"select  <code>property</code> <code>writable</code>","text":"<pre><code>select: bool\n</code></pre> <p>Use seismogram to create stack.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.t0","title":"t0  <code>property</code> <code>writable</code>","text":"<pre><code>t0: datetime\n</code></pre> <p>Initial pick.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.t1","title":"t1  <code>property</code> <code>writable</code>","text":"<pre><code>t1: datetime | None\n</code></pre> <p>Updated pick.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.ICCSSeismogram.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The length of the Seismogram.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of samples in the data array.</p> </li> </ul> Source code in <code>pysmo/_types/_seismogram.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"The length of the Seismogram.\n\n    Returns:\n        Number of samples in the data array.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram","title":"MiniICCSSeismogram","text":"<p>Minimal implementation of the <code>ICCSSeismogram</code> type.</p> <p>The <code>MiniICCSSeismogram</code> class provides a minimal implementation of class that is compatible with the <code>ICCSSeismogram</code>.</p> <p>Examples:</p> <p>Because <code>ICCSSeismogram</code> inherits from <code>Seismogram</code>, we can easily create <code>MiniICCSSeismogram</code> instances from exisiting seismograms using the <code>clone_to_mini()</code> function, whereby the <code>update</code> parameter is used to provide the extra information needed:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.functions import clone_to_mini\n&gt;&gt;&gt; from pysmo.tools.iccs import MiniICCSSeismogram\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; sac_seis = sac.seismogram\n&gt;&gt;&gt; update = {\"t0\": sac.timestamps.t0}\n&gt;&gt;&gt; mini_iccs_seis = clone_to_mini(MiniICCSSeismogram, sac_seis, update=update)\n&gt;&gt;&gt;\n</code></pre> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              <p>The length of the Seismogram.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>begin_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram begin time.</p> </li> <li> <code>data</code>               (<code>ndarray</code>)           \u2013            <p>Seismogram data.</p> </li> <li> <code>delta</code>               (<code>timedelta</code>)           \u2013            <p>Seismogram sampling interval.</p> </li> <li> <code>end_time</code>               (<code>datetime</code>)           \u2013            <p>Seismogram end time.</p> </li> <li> <code>flip</code>               (<code>bool</code>)           \u2013            <p>Data in seismogram should be flipped for ICCS.</p> </li> <li> <code>select</code>               (<code>bool</code>)           \u2013            <p>Use seismogram to create stack.</p> </li> <li> <code>t0</code>               (<code>datetime</code>)           \u2013            <p>Initial pick.</p> </li> <li> <code>t1</code>               (<code>datetime | None</code>)           \u2013            <p>Updated pick.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_types.py</code> <pre><code>@define(kw_only=True, slots=True)\nclass MiniICCSSeismogram:\n    \"\"\"Minimal implementation of the [`ICCSSeismogram`][pysmo.tools.iccs.ICCSSeismogram] type.\n\n    The [`MiniICCSSeismogram`][pysmo.tools.iccs.ICCSSeismogram] class provides\n    a minimal implementation of class that is compatible with the\n    [`ICCSSeismogram`][pysmo.tools.iccs.ICCSSeismogram].\n\n    Examples:\n        Because [`ICCSSeismogram`][pysmo.tools.iccs.ICCSSeismogram] inherits\n        from [`Seismogram`][pysmo.Seismogram], we can easily create\n        [`MiniICCSSeismogram`][pysmo.tools.iccs.MiniICCSSeismogram] instances\n        from exisiting seismograms using the\n        [`clone_to_mini()`][pysmo.functions.clone_to_mini] function, whereby\n        the `update` parameter is used to provide the extra information needed:\n\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.functions import clone_to_mini\n        &gt;&gt;&gt; from pysmo.tools.iccs import MiniICCSSeismogram\n        &gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n        &gt;&gt;&gt; sac_seis = sac.seismogram\n        &gt;&gt;&gt; update = {\"t0\": sac.timestamps.t0}\n        &gt;&gt;&gt; mini_iccs_seis = clone_to_mini(MiniICCSSeismogram, sac_seis, update=update)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    begin_time: datetime = field(\n        default=SEISMOGRAM_DEFAULTS.begin_time.value, validator=datetime_is_utc\n    )\n    \"\"\"Seismogram begin time.\"\"\"\n\n    delta: timedelta = SEISMOGRAM_DEFAULTS.delta.value\n    \"\"\"Seismogram sampling interval.\"\"\"\n\n    data: np.ndarray = field(factory=lambda: np.array([]))\n    \"\"\"Seismogram data.\"\"\"\n\n    t0: datetime = field(validator=datetime_is_utc)\n    \"\"\"Initial pick.\"\"\"\n\n    t1: datetime | None = field(\n        default=None, validator=validators.optional(datetime_is_utc)\n    )\n    \"\"\"Updated pick.\"\"\"\n\n    flip: bool = False\n    \"\"\"Data in seismogram should be flipped for ICCS.\"\"\"\n\n    select: bool = True\n    \"\"\"Use seismogram to create stack.\"\"\"\n\n    def __len__(self) -&gt; int:\n        \"\"\"The length of the Seismogram.\n\n        Returns:\n            Number of samples in the data array.\n        \"\"\"\n        return np.size(self.data)\n\n    @property\n    def end_time(self) -&gt; datetime:\n        \"\"\"Seismogram end time.\"\"\"\n        if len(self) == 0:\n            return self.begin_time\n        return self.begin_time + self.delta * (len(self) - 1)\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.begin_time","title":"begin_time  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>begin_time: datetime = field(\n    default=begin_time.value, validator=datetime_is_utc\n)\n</code></pre> <p>Seismogram begin time.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: ndarray = field(factory=lambda: array([]))\n</code></pre> <p>Seismogram data.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.delta","title":"delta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>delta: timedelta = delta.value\n</code></pre> <p>Seismogram sampling interval.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.end_time","title":"end_time  <code>property</code>","text":"<pre><code>end_time: datetime\n</code></pre> <p>Seismogram end time.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.flip","title":"flip  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flip: bool = False\n</code></pre> <p>Data in seismogram should be flipped for ICCS.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.select","title":"select  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>select: bool = True\n</code></pre> <p>Use seismogram to create stack.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.t0","title":"t0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t0: datetime = field(validator=datetime_is_utc)\n</code></pre> <p>Initial pick.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.t1","title":"t1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>t1: datetime | None = field(\n    default=None, validator=optional(datetime_is_utc)\n)\n</code></pre> <p>Updated pick.</p>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.MiniICCSSeismogram.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>The length of the Seismogram.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of samples in the data array.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_types.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"The length of the Seismogram.\n\n    Returns:\n        Number of samples in the data array.\n    \"\"\"\n    return np.size(self.data)\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.plot_seismograms","title":"plot_seismograms","text":"<pre><code>plot_seismograms(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None\n</code></pre> <p>Plot the selected ICCS seismograms as an image.</p> <p>Parameters:</p> <ul> <li> <code>iccs</code>               (<code>ICCS</code>)           \u2013            <p>Instance of the <code>ICCS</code> class.</p> </li> <li> <code>padded</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the plot is padded on both sides of the time window by the amount defined in <code>ICCS.plot_padding</code>.</p> </li> <li> <code>all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, all seismograms are shown in the plot instead of the selected ones only.</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the <code>Figure</code> and <code>Axes</code> objects are returned instead of shown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Figure, Axes] | None</code>           \u2013            <p>Figure of the selected seismograms as an image if <code>return_fig</code> is <code>True</code>.</p> </li> </ul> <p>Examples:</p> <p>The default plotting mode is to pad the seismgorams beyond the time window used for the cross-correlations. This is particularly useful for narrow time windows.</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.iccs import ICCS, plot_seismograms\n&gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n&gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; plot_seismograms(iccs)\n&gt;&gt;&gt;\n</code></pre> <p> </p> <p>To view the seismograms exactly as they are used in the cross-correlations, set the <code>padded</code> argument to <code>False</code>:</p> <pre><code>&gt;&gt;&gt; plot_seismograms(iccs, padded=False)\n&gt;&gt;&gt;\n</code></pre> <p> </p> Source code in <code>pysmo/tools/iccs/_functions.py</code> <pre><code>def plot_seismograms(\n    iccs: ICCS, padded: bool = True, all: bool = False, return_fig: bool = False\n) -&gt; tuple[Figure, Axes] | None:\n    \"\"\"Plot the selected ICCS seismograms as an image.\n\n    Parameters:\n        iccs: Instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class.\n        padded: If True, the plot is padded on both sides of the\n            time window by the amount defined in\n            [`ICCS.plot_padding`][pysmo.tools.iccs.ICCS.plot_padding].\n        all: If `True`, all seismograms are shown in the plot instead of the\n            selected ones only.\n        return_fig: If `True`, the [`Figure`][matplotlib.figure.Figure] and\n            [`Axes`][matplotlib.axes.Axes] objects are returned instead of\n            shown.\n\n    Returns:\n        Figure of the selected seismograms as an image if `return_fig` is `True`.\n\n    Examples:\n        The default plotting mode is to pad the seismgorams beyond the time\n        window used for the cross-correlations. This is particularly useful\n        for narrow time windows.\n\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.iccs import ICCS, plot_seismograms\n        &gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n        &gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; plot_seismograms(iccs)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_seismograms(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_plot_seismograms_padded-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_seismograms(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_plot_seismograms_padded.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![View the seismograms with padding](../../../examples/figures/iccs_plot_seismograms_padded.png#only-light){ loading=lazy }\n        ![View the seismograms with padding](../../../examples/figures/iccs_plot_seismograms_padded-dark.png#only-dark){ loading=lazy }\n\n        To view the seismograms exactly as they are used in the\n        cross-correlations, set the `padded` argument to `False`:\n\n        ```python\n        &gt;&gt;&gt; plot_seismograms(iccs, padded=False)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_seismograms(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_plot_seismograms-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_seismograms(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_plot_seismograms.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![View the seismograms with padding](../../../examples/figures/iccs_plot_seismograms.png#only-light){ loading=lazy }\n        ![View the seismograms with padding](../../../examples/figures/iccs_plot_seismograms-dark.png#only-dark){ loading=lazy }\n    \"\"\"\n\n    fig, ax, _ = _plot_common_image(iccs, padded, all)\n    if return_fig:\n        return fig, ax\n\n    plt.show()\n    return None\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.plot_stack","title":"plot_stack","text":"<pre><code>plot_stack(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None\n</code></pre> <p>Plot the ICCS stack.</p> <p>Parameters:</p> <ul> <li> <code>iccs</code>               (<code>ICCS</code>)           \u2013            <p>Instance of the <code>ICCS</code> class.</p> </li> <li> <code>padded</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the plot is padded on both sides of the time window by the amount defined in <code>ICCS.plot_padding</code>.</p> </li> <li> <code>all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, all seismograms are shown in the plot instead of the selected ones only.</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the <code>Figure</code> and <code>Axes</code> objects are returned instead of shown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Figure, Axes] | None</code>           \u2013            <p>Figure of the stack with the seismograms if <code>return_fig</code> is <code>True</code>.</p> </li> </ul> <p>Examples:</p> <p>The default plotting mode is to pad the stack beyond the time window used for the cross-correlations (highlighted in light green). This is useful particularly useful for narrow time windows. Note that because of the padding, the displayed stack isn't exactly what is used for the cross-correlations.</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.iccs import ICCS, plot_stack\n&gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n&gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; plot_stack(iccs)\n&gt;&gt;&gt;\n</code></pre> <p> </p> <p>To view the stack exactly as it is used in the cross-correlations, set the <code>padded</code> argument to <code>False</code>:</p> <pre><code>&gt;&gt;&gt; plot_stack(iccs, padded=False)\n&gt;&gt;&gt;\n</code></pre> <p> </p> Source code in <code>pysmo/tools/iccs/_functions.py</code> <pre><code>def plot_stack(\n    iccs: ICCS, padded: bool = True, all: bool = False, return_fig: bool = False\n) -&gt; tuple[Figure, Axes] | None:\n    \"\"\"Plot the ICCS stack.\n\n    Parameters:\n        iccs: Instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class.\n        padded: If True, the plot is padded on both sides of the\n            time window by the amount defined in\n            [`ICCS.plot_padding`][pysmo.tools.iccs.ICCS.plot_padding].\n        all: If `True`, all seismograms are shown in the plot instead of the\n            selected ones only.\n        return_fig: If `True`, the [`Figure`][matplotlib.figure.Figure] and\n            [`Axes`][matplotlib.axes.Axes] objects are returned instead of\n            shown.\n\n    Returns:\n        Figure of the stack with the seismograms if `return_fig` is `True`.\n\n    Examples:\n        The default plotting mode is to pad the stack beyond the time window\n        used for the cross-correlations (highlighted in light green). This is\n        useful particularly useful for narrow time windows. Note that because\n        of the padding, the displayed stack isn't exactly what is used for the\n        cross-correlations.\n\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.iccs import ICCS, plot_stack\n        &gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n        &gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; plot_stack(iccs)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_stack(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_view_stack_padded-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_stack(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_view_stack_padded.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![View the stack with padding](../../../examples/figures/iccs_view_stack_padded.png#only-light){ loading=lazy }\n        ![View the stack with padding](../../../examples/figures/iccs_view_stack_padded-dark.png#only-dark){ loading=lazy }\n\n        To view the stack exactly as it is used in the cross-correlations, set\n        the `padded` argument to `False`:\n\n        ```python\n        &gt;&gt;&gt; plot_stack(iccs, padded=False)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_view_stack-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = plot_stack(iccs, padded=False, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_view_stack.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![View the stack with padding](../../../examples/figures/iccs_view_stack.png#only-light){ loading=lazy }\n        ![View the stack with padding](../../../examples/figures/iccs_view_stack-dark.png#only-dark){ loading=lazy }\n    \"\"\"\n\n    fig, ax = _plot_common_stack(iccs, padded, all)\n    if return_fig:\n        return fig, ax\n    plt.show()\n    return None\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.update_all_picks","title":"update_all_picks","text":"<pre><code>update_all_picks(iccs: ICCS, pickdelta: timedelta) -&gt; None\n</code></pre> <p>Update <code>t1</code> in all seismograms by the same amount.</p> <p>Parameters:</p> <ul> <li> <code>iccs</code>               (<code>ICCS</code>)           \u2013            <p>Instance of the <code>ICCS</code> class.</p> </li> <li> <code>pickdelta</code>               (<code>timedelta</code>)           \u2013            <p>delta applied to all picks.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the new t1 is outside the valid range.</p> </li> </ul> Source code in <code>pysmo/tools/iccs/_functions.py</code> <pre><code>def update_all_picks(iccs: ICCS, pickdelta: timedelta) -&gt; None:\n    \"\"\"Update [`t1`][pysmo.tools.iccs.ICCSSeismogram.t1] in all seismograms by the same amount.\n\n    Parameters:\n        iccs: Instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class.\n        pickdelta: delta applied to all picks.\n\n    Raises:\n        ValueError: If the new t1 is outside the valid range.\n    \"\"\"\n\n    if not iccs.validate_pick(pickdelta):\n        raise ValueError(\n            \"New t1 is outside the valid range. Consider reducing the time window.\"\n        )\n\n    for seismogram in iccs.seismograms:\n        current_pick = seismogram.t1 or seismogram.t0\n        seismogram.t1 = current_pick + pickdelta\n    iccs._clear_caches()  # seismograms and stack need to be refreshed\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.update_min_ccnorm","title":"update_min_ccnorm","text":"<pre><code>update_min_ccnorm(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None\n</code></pre> <p>Interactively pick a new <code>min_ccnorm</code>.</p> <p>This function launches an interactive figure to manually pick a new <code>min_ccnorm</code>, which is used when running the ICCS algorithm with <code>autoselect</code> set to <code>True</code>.</p> <p>Parameters:</p> <ul> <li> <code>iccs</code>               (<code>ICCS</code>)           \u2013            <p>Instance of the <code>ICCS</code> class.</p> </li> <li> <code>padded</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the plot is padded on both sides of the time window by the amount defined in <code>ICCS.plot_padding</code>.</p> </li> <li> <code>all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, all seismograms are shown in the plot instead of the selected ones only.</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the <code>Figure</code> and <code>Axes</code> objects are returned instead of shown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Figure, Axes] | None</code>           \u2013            <p>Figure with the selector if <code>return_fig</code> is <code>True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.iccs import ICCS, update_min_ccnorm\n&gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n&gt;&gt;&gt; _ = iccs()\n&gt;&gt;&gt; update_min_ccnorm(iccs)\n&gt;&gt;&gt;\n</code></pre> <p> </p> Source code in <code>pysmo/tools/iccs/_functions.py</code> <pre><code>def update_min_ccnorm(\n    iccs: ICCS, padded: bool = True, all: bool = False, return_fig: bool = False\n) -&gt; tuple[Figure, Axes] | None:\n    \"\"\"Interactively pick a new [`min_ccnorm`][pysmo.tools.iccs.ICCS.min_ccnorm].\n\n    This function launches an interactive figure to manually pick a new\n    [`min_ccnorm`][pysmo.tools.iccs.ICCS.min_ccnorm], which is used when\n    [running][pysmo.tools.iccs.ICCS.__call__] the ICCS algorithm with\n    `autoselect` set to `True`.\n\n    Parameters:\n        iccs: Instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class.\n        padded: If True, the plot is padded on both sides of the\n            time window by the amount defined in\n            [`ICCS.plot_padding`][pysmo.tools.iccs.ICCS.plot_padding].\n        all: If `True`, all seismograms are shown in the plot instead of the\n            selected ones only.\n        return_fig: If `True`, the [`Figure`][matplotlib.figure.Figure] and\n            [`Axes`][matplotlib.axes.Axes] objects are returned instead of\n            shown.\n\n    Returns:\n        Figure with the selector if `return_fig` is `True`.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.iccs import ICCS, update_min_ccnorm\n        &gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n        &gt;&gt;&gt; _ = iccs()\n        &gt;&gt;&gt; update_min_ccnorm(iccs)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = update_min_ccnorm(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_update_min_ccnorm-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = update_min_ccnorm(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_update_min_ccnorm.png\", transparent=True)\n        ...     plt.close()\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Picking a new time window in stack](../../../examples/figures/iccs_update_min_ccnorm.png#only-light){ loading=lazy }\n        ![Picking a new time window in stack](../../../examples/figures/iccs_update_min_ccnorm-dark.png#only-dark){ loading=lazy }\n    \"\"\"\n\n    # If the lowest index is chosen in the gui, set the new min_ccnorm to\n    # the lowest value of all seismograms multiplied by a multiplier\n    _INDEX_ZERO_MULTIPLIER = 0.9\n\n    current_ccnorms = sorted(\n        i for i, _ in zip(iccs.ccnorms, iccs.seismograms) if _.select or all\n    )\n\n    fig, ax, selected_seismogram_matrix = _plot_common_image(\n        iccs, padded, all, figsize=(10, 6), constrained=False\n    )\n    fig.subplots_adjust(bottom=0.2, left=0.05, right=0.95, top=0.93)\n    ax.set_title(\"Pick a new minimal cross-correlation coefficient.\")\n\n    start_index = int(np.searchsorted(current_ccnorms, iccs.min_ccnorm))\n    max_index = len(selected_seismogram_matrix) - 1\n\n    pick_line = ax.axhline(start_index, color=\"g\", linewidth=2)\n    pick_line_cursor = ax.axhline(start_index, color=\"g\", linewidth=2, linestyle=\"--\")\n\n    def snap_ydata(ydata: float) -&gt; int:\n        return max(0, round(min(ydata, max_index)))\n\n    def calc_ccnorm(pick_line: Line2D) -&gt; float | np.floating:\n        # NOTE: the pick_line ydata should already be a round number, but\n        # mypy complains without it.\n        index = round(pick_line.get_ydata()[0], 0)  # type: ignore\n        if index == 0:\n            return _INDEX_ZERO_MULTIPLIER * current_ccnorms[0]\n        return np.mean(current_ccnorms[index - 1 : index + 1])\n\n    def onclick(event: MouseEvent) -&gt; Any:\n        if event.inaxes is ax and event.ydata is not None:\n            ydata = snap_ydata(event.ydata)\n            pick_line.set_ydata((ydata, ydata))\n            pick_line.set_visible(True)\n            fig.canvas.draw()\n            fig.canvas.flush_events()\n            ax.set_title(\n                f\"Click save to set min_ccnorm to {calc_ccnorm(pick_line):.4f}\"\n            )\n            fig.canvas.draw_idle()\n\n    def on_mouse_move(event: MouseEvent) -&gt; Any:\n        if event.inaxes is ax and event.ydata is not None:\n            ydata = snap_ydata(event.ydata)\n            pick_line_cursor.set_ydata((ydata, ydata))\n            pick_line_cursor.set_visible(True)\n            fig.canvas.draw_idle()\n        else:\n            pick_line_cursor.set_visible(False)\n            fig.canvas.draw_idle()\n\n    class ScrollIndexTracker:\n        def __init__(self, ax: Axes) -&gt; None:\n            self.scroll_index = ax.get_ylim()[1]\n            self.max_scroll_index = ax.get_ylim()[1]\n            self.ax = ax\n            self.update()\n\n        def on_scroll(self, event: MouseEvent) -&gt; None:\n            if event.inaxes is ax:\n                increment = (\n                    np.ceil(self.scroll_index / 10)\n                    if event.button == \"up\"\n                    else -np.ceil(self.scroll_index / 10)\n                )\n                self.scroll_index = max(\n                    1, min(self.max_scroll_index, self.scroll_index + increment)\n                )\n                self.update()\n\n        def update(self) -&gt; None:\n            self.ax.set_ylim(0, self.scroll_index)\n            fig.canvas.draw_idle()\n\n    class SaveOrCancel:\n        def save(self, _: Event) -&gt; None:\n            iccs.min_ccnorm = calc_ccnorm(pick_line)\n            iccs._clear_caches()\n            plt.close()\n\n        def cancel(self, _: Event) -&gt; None:\n            plt.close()\n\n    _ = Cursor(\n        ax,\n        useblit=True,\n        vertOn=False,\n        horizOn=False,\n    )\n\n    callback = SaveOrCancel()\n    ax_save = fig.add_axes((0.7, 0.05, 0.1, 0.075))\n    ax_cancel = fig.add_axes((0.81, 0.05, 0.1, 0.075))\n    b_save = Button(ax_save, \"Save\", color=\"darkgreen\", hovercolor=\"green\")\n    b_save.on_clicked(callback.save)\n    b_abort = Button(ax_cancel, \"Cancel\", color=\"darkred\", hovercolor=\"red\")\n    b_abort.on_clicked(callback.cancel)\n    tracker = ScrollIndexTracker(ax)\n\n    _ = fig.canvas.mpl_connect(\"scroll_event\", tracker.on_scroll)  # type: ignore\n    _ = fig.canvas.mpl_connect(\"button_press_event\", onclick)  # type: ignore\n    _ = fig.canvas.mpl_connect(\"motion_notify_event\", on_mouse_move)  # type: ignore\n\n    if return_fig:\n        return fig, ax\n    plt.show()\n    return None\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.update_pick","title":"update_pick","text":"<pre><code>update_pick(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    use_seismogram_image: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None\n</code></pre> <p>Manually pick <code>t1</code> and apply it to all seismograms.</p> <p>This function launches an interactive figure to manually pick a new phase arrival, and then apply it to all seismograms.</p> <p>Parameters:</p> <ul> <li> <code>iccs</code>               (<code>ICCS</code>)           \u2013            <p>Instance of the <code>ICCS</code> class.</p> </li> <li> <code>padded</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the plot is padded on both sides of the time window by the amount defined in <code>ICCS.plot_padding</code>.</p> </li> <li> <code>all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, all seismograms are shown in the plot instead of the selected ones only.</p> </li> <li> <code>use_seismogram_image</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use the seismogram image instead of the stack).</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the <code>Figure</code> and <code>Axes</code> objects are returned instead of shown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Figure, Axes] | None</code>           \u2013            <p>Figure of the stack with the picker if <code>return_fig</code> is <code>True</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.iccs import ICCS, update_pick\n&gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n&gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; update_pick(iccs)\n&gt;&gt;&gt;\n</code></pre> <p> </p> Source code in <code>pysmo/tools/iccs/_functions.py</code> <pre><code>def update_pick(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    use_seismogram_image: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None:\n    \"\"\"Manually pick [`t1`][pysmo.tools.iccs.ICCSSeismogram.t1] and apply it to all seismograms.\n\n    This function launches an interactive figure to manually pick a new phase\n    arrival, and then apply it to all seismograms.\n\n    Parameters:\n        iccs: Instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class.\n        padded: If True, the plot is padded on both sides of the\n            time window by the amount defined in\n            [`ICCS.plot_padding`][pysmo.tools.iccs.ICCS.plot_padding].\n        all: If `True`, all seismograms are shown in the plot instead of the\n            selected ones only.\n        use_seismogram_image: Use the\n            [seismogram image][pysmo.tools.iccs.plot_seismograms]\n            instead of the [stack][pysmo.tools.iccs.plot_stack]).\n        return_fig: If `True`, the [`Figure`][matplotlib.figure.Figure] and\n            [`Axes`][matplotlib.axes.Axes] objects are returned instead of\n            shown.\n\n    Returns:\n        Figure of the stack with the picker if `return_fig` is `True`.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.iccs import ICCS, update_pick\n        &gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n        &gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; update_pick(iccs)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = update_pick(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_update_pick-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = update_pick(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_update_pick.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Picking a new T1](../../../examples/figures/iccs_update_pick.png#only-light){ loading=lazy }\n        ![Picking a new T1](../../../examples/figures/iccs_update_pick-dark.png#only-dark){ loading=lazy }\n    \"\"\"\n\n    if use_seismogram_image:\n        fig, ax, _ = _plot_common_image(\n            iccs, padded, all, figsize=(10, 6), constrained=False\n        )\n        fig.subplots_adjust(bottom=0.2, left=0.05, right=0.95, top=0.93)\n    else:\n        fig, ax = _plot_common_stack(\n            iccs, padded, all, figsize=(10, 6), constrained=False\n        )\n        fig.subplots_adjust(bottom=0.2, left=0.09, right=1.05, top=0.93)\n\n    ax.set_title(\"Update t1 for all seismograms.\")\n\n    pick_line = ax.axvline(0, color=\"g\", linewidth=2)\n\n    cursor = Cursor(  # noqa: F841\n        ax, useblit=True, color=\"g\", linewidth=2, horizOn=False, linestyle=\"--\"\n    )\n\n    def onclick(event: MouseEvent) -&gt; Any:\n        if (\n            event.inaxes is ax\n            and event.xdata is not None\n            and iccs.validate_pick(timedelta(seconds=event.xdata))\n        ):\n            pick_line.set_xdata(np.array((event.xdata, event.xdata)))\n            ax.set_title(f\"Click save to adjust t1 by {event.xdata:.3f} seconds.\")\n            fig.canvas.draw()\n            fig.canvas.flush_events()\n\n    def on_mouse_move(event: MouseEvent) -&gt; Any:\n        if event.inaxes == ax and event.xdata is not None:\n            if iccs.validate_pick(timedelta(seconds=event.xdata)):\n                cursor.linev.set_color(\"g\")\n            else:\n                cursor.linev.set_color(\"r\")\n\n    class SaveOrCancel:\n        def save(self, _: Event) -&gt; None:\n            pickdelta = timedelta(seconds=pick_line.get_xdata(orig=True)[0])  # type: ignore\n            plt.close()\n            update_all_picks(iccs, pickdelta)\n\n        def cancel(self, _: Event) -&gt; None:\n            plt.close()\n\n    callback = SaveOrCancel()\n    ax_save = fig.add_axes((0.7, 0.05, 0.1, 0.075))\n    ax_cancel = fig.add_axes((0.81, 0.05, 0.1, 0.075))\n    b_save = Button(ax_save, \"Save\", color=\"darkgreen\", hovercolor=\"green\")\n    b_save.on_clicked(callback.save)\n    b_abort = Button(ax_cancel, \"Cancel\", color=\"darkred\", hovercolor=\"red\")\n    b_abort.on_clicked(callback.cancel)\n\n    _ = fig.canvas.mpl_connect(\"button_press_event\", onclick)  # type: ignore\n\n    _ = fig.canvas.mpl_connect(\"motion_notify_event\", on_mouse_move)  # type: ignore\n\n    if return_fig:\n        return fig, ax\n    plt.show()\n    return None\n</code></pre>"},{"location":"api/pysmo/tools/iccs/#pysmo.tools.iccs.update_timewindow","title":"update_timewindow","text":"<pre><code>update_timewindow(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    use_seismogram_image: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None\n</code></pre> <p>Pick new time window limits.</p> <p>This function launches an interactive figure to pick new values for <code>window_pre</code> and <code>window_post</code>.</p> <p>Parameters:</p> <ul> <li> <code>iccs</code>               (<code>ICCS</code>)           \u2013            <p>Instance of the <code>ICCS</code> class.</p> </li> <li> <code>padded</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the plot is padded on both sides of the time window by the amount defined in <code>ICCS.plot_padding</code>.</p> </li> <li> <code>all</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, all seismograms are shown in the plot instead of the selected ones only.</p> </li> <li> <code>use_seismogram_image</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Use the seismogram image instead of the stack).</p> </li> <li> <code>return_fig</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, the <code>Figure</code> and <code>Axes</code> objects are returned instead of shown.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Figure, Axes] | None</code>           \u2013            <p>Figure of the stack with the picker if <code>return_fig</code> is <code>True</code>.</p> </li> </ul> Info <p>The new time window may not be chosen such that the pick lies outside the the window. The picker will therefore automatically correct itself for invalid window choices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.iccs import ICCS, update_timewindow\n&gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n&gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n&gt;&gt;&gt;\n&gt;&gt;&gt; update_timewindow(iccs)\n&gt;&gt;&gt;\n</code></pre> <p> </p> Source code in <code>pysmo/tools/iccs/_functions.py</code> <pre><code>def update_timewindow(\n    iccs: ICCS,\n    padded: bool = True,\n    all: bool = False,\n    use_seismogram_image: bool = False,\n    return_fig: bool = False,\n) -&gt; tuple[Figure, Axes] | None:\n    \"\"\"Pick new time window limits.\n\n    This function launches an interactive figure to pick new values for\n    [`window_pre`][pysmo.tools.iccs.ICCS.window_pre] and\n    [`window_post`][pysmo.tools.iccs.ICCS.window_post].\n\n    Parameters:\n        iccs: Instance of the [`ICCS`][pysmo.tools.iccs.ICCS] class.\n        padded: If True, the plot is padded on both sides of the\n            time window by the amount defined in\n            [`ICCS.plot_padding`][pysmo.tools.iccs.ICCS.plot_padding].\n        all: If `True`, all seismograms are shown in the plot instead of the\n            selected ones only.\n        use_seismogram_image: Use the\n            [seismogram image][pysmo.tools.iccs.plot_seismograms]\n            instead of the [stack][pysmo.tools.iccs.plot_stack]).\n        return_fig: If `True`, the [`Figure`][matplotlib.figure.Figure] and\n            [`Axes`][matplotlib.axes.Axes] objects are returned instead of\n            shown.\n\n    Returns:\n        Figure of the stack with the picker if `return_fig` is `True`.\n\n    Info:\n        The new time window may not be chosen such that the pick lies\n        outside the the window. The picker will therefore automatically correct\n        itself for invalid window choices.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.iccs import ICCS, update_timewindow\n        &gt;&gt;&gt; iccs = ICCS(iccs_seismograms)\n        &gt;&gt;&gt; _ = iccs(autoselect=True, autoflip=True)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; update_timewindow(iccs)\n        &gt;&gt;&gt;\n        ```\n\n        &lt;!-- invisible-code-block: python\n        ```\n        &gt;&gt;&gt; import matplotlib.pyplot as plt\n        &gt;&gt;&gt; plt.close(\"all\")\n        &gt;&gt;&gt; if savedir:\n        ...     plt.style.use(\"dark_background\")\n        ...     fig, _ = update_timewindow(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_update_timewindow-dark.png\", transparent=True)\n        ...\n        ...     plt.style.use(\"default\")\n        ...     fig, _ = update_timewindow(iccs, return_fig=True)\n        ...     fig.savefig(savedir / \"iccs_update_timewindow.png\", transparent=True)\n        &gt;&gt;&gt;\n        ```\n        --&gt;\n\n        ![Picking a new time window](../../../examples/figures/iccs_update_timewindow.png#only-light){ loading=lazy }\n        ![Picking a new time window](../../../examples/figures/iccs_update_timewindow-dark.png#only-dark){ loading=lazy }\n    \"\"\"\n\n    if use_seismogram_image:\n        fig, ax, _ = _plot_common_image(\n            iccs, padded, all, figsize=(10, 6), constrained=False\n        )\n        fig.subplots_adjust(bottom=0.2, left=0.05, right=0.95, top=0.93)\n    else:\n        fig, ax = _plot_common_stack(\n            iccs, padded, all, figsize=(10, 6), constrained=False\n        )\n        fig.subplots_adjust(bottom=0.2, left=0.09, right=1.05, top=0.93)\n\n    ax.set_title(\"Pick a new time window.\")\n\n    # 'old_extents' is used to revert to the last valid extents\n    old_extents = (iccs.window_pre.total_seconds(), iccs.window_post.total_seconds())\n\n    def onselect(xmin: float, xmax: float) -&gt; None:\n        nonlocal old_extents\n        if iccs.validate_time_window(timedelta(seconds=xmin), timedelta(seconds=xmax)):\n            ax.set_title(\n                f\"Click save to set window at {xmin:.3f} to {xmax:.3f} seconds.\"\n            )\n            old_extents = xmin, xmax\n            fig.canvas.draw()\n            return\n        span.extents = old_extents\n\n    span = SpanSelector(\n        ax,\n        onselect,\n        \"horizontal\",\n        useblit=True,\n        props=dict(alpha=0.5, facecolor=\"tab:blue\"),\n        interactive=True,\n        drag_from_anywhere=True,\n    )\n\n    # Set the initial extents to the existing time window\n    span.extents = old_extents\n\n    class SaveOrCancel:\n        def save(self, _: Event) -&gt; None:\n            iccs.window_pre = timedelta(seconds=span.extents[0])\n            iccs.window_post = timedelta(seconds=span.extents[1])\n            plt.close()\n\n        def cancel(self, _: Event) -&gt; None:\n            plt.close()\n\n    callback = SaveOrCancel()\n    ax_save = fig.add_axes((0.7, 0.05, 0.1, 0.075))\n    ax_cancel = fig.add_axes((0.81, 0.05, 0.1, 0.075))\n    b_save = Button(ax_save, \"Save\", color=\"darkgreen\", hovercolor=\"green\")\n    b_save.on_clicked(callback.save)\n    b_abort = Button(ax_cancel, \"Cancel\", color=\"darkred\", hovercolor=\"red\")\n    b_abort.on_clicked(callback.cancel)\n\n    if return_fig:\n        return fig, ax\n    plt.show()\n    return None\n</code></pre>"},{"location":"api/pysmo/tools/noise/","title":"noise","text":""},{"location":"api/pysmo/tools/noise/#pysmo.tools.noise","title":"pysmo.tools.noise","text":"<p>Generate realistic synthetic noise.</p> <p>This module provides support for calculating random synthetic noise that matches the naturally observed amplitude spectrum.</p> <p>Examples:</p> <p>Given the spectral amplitude in observed seismic noise on Earth is not flat (i.e. not consisting of white noise), it makes sense to calculate more realistic noise for things like resolution tests with synthetic data.</p> <p>In this example, random noise seismograms are generated from three different noise models. These are Peterson's NHNM (red), NLNM (blue), and an interpolated model that lies between the two (green).</p> <p> </p> Example source code peterson.py<pre><code>\"\"\"\nExample script for pysmo.tools.noise\n\"\"\"\n\n#!/usr/bin/env python\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import signal\nfrom pysmo.tools.noise import generate_noise, peterson\nfrom datetime import timedelta\n\n\ndef calc_power(\n    data: np.ndarray, sampling_frequency: float, nperseg: int, nfft: int\n) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"Calculuate power and drop first element (f=0Hz) to avoid dividing by 0\"\"\"\n    freqs, psd = signal.welch(\n        data, sampling_frequency, nperseg=nperseg, nfft=nfft, scaling=\"density\"\n    )\n    return freqs[1:], psd[1:]\n\n\ndef main() -&gt; None:\n    # Set parameters\n    npts: int = 200000  # multiple of 4\n    delta = timedelta(seconds=0.1)\n    sampling_frequency = 1 / delta.total_seconds()\n    nperseg = int(npts / 4)\n    nfft = int(npts / 2)\n    time_in_seconds = np.linspace(0, npts * delta.total_seconds(), npts)\n\n    # Calculate noise models\n    low_noise_model = peterson(noise_level=0)\n    mid_noise_model = peterson(noise_level=0.5)\n    high_noise_model = peterson(noise_level=1)\n\n    # Generate random noise seismograms\n    low_noise_seismogram = generate_noise(npts=npts, model=low_noise_model, delta=delta)\n    mid_noise_seismogram = generate_noise(npts=npts, model=mid_noise_model, delta=delta)\n    high_noise_seismogram = generate_noise(\n        npts=npts, model=high_noise_model, delta=delta\n    )\n\n    # Calculuate power spectral density\n    f_low, Pxx_dens_low = calc_power(\n        low_noise_seismogram.data, sampling_frequency, nperseg, nfft\n    )\n    f_mid, Pxx_dens_mid = calc_power(\n        mid_noise_seismogram.data, sampling_frequency, nperseg, nfft\n    )\n    f_high, Pxx_dens_high = calc_power(\n        high_noise_seismogram.data, sampling_frequency, nperseg, nfft\n    )\n\n    _ = plt.figure(figsize=(13, 9), layout=\"tight\")\n\n    # Plot random high and low noise seismograms\n    ax1 = plt.subplot2grid((4, 3), (0, 0))\n    plt.plot(time_in_seconds, high_noise_seismogram.data, \"r\", linewidth=0.2)\n    plt.ylabel(\"Ground Accelaration\")\n    plt.xlabel(\"Time [s]\")\n    plt.xlim(time_in_seconds[0], time_in_seconds[-1])\n    xticks = np.arange(\n        tmin := time_in_seconds[0], (tmax := time_in_seconds[-1]) + 1, (tmax - tmin) / 5\n    )\n    ax1.set_xticks(xticks)\n\n    ax2 = plt.subplot2grid((4, 3), (0, 1))\n    ax2.set_xticks(xticks)\n    plt.plot(time_in_seconds, mid_noise_seismogram.data, \"g\", linewidth=0.2)\n    plt.xlabel(\"Time [s]\")\n    plt.xlim(time_in_seconds[0], time_in_seconds[-1])\n\n    ax3 = plt.subplot2grid((4, 3), (0, 2))\n    ax3.set_xticks(xticks)\n    plt.plot(time_in_seconds, low_noise_seismogram.data, \"b\", linewidth=0.2)\n    plt.xlabel(\"Time [s]\")\n    plt.xlim(time_in_seconds[0], time_in_seconds[-1])\n\n    # Plot PSD of noise\n    _ = plt.subplot2grid((4, 3), (1, 0), rowspan=3, colspan=3)\n    plt.plot(\n        1 / f_high,\n        10 * np.log10(Pxx_dens_high),\n        \"r\",\n        linewidth=0.5,\n        label=\"generated high noise\",\n    )\n    plt.plot(\n        1 / f_mid,\n        10 * np.log10(Pxx_dens_mid),\n        \"g\",\n        linewidth=0.5,\n        label=\"generated medium noise\",\n    )\n    plt.plot(\n        1 / f_low,\n        10 * np.log10(Pxx_dens_low),\n        \"b\",\n        linewidth=0.5,\n        label=\"generated low noise\",\n    )\n    plt.plot(\n        high_noise_model.T,\n        high_noise_model.psd,\n        \"k\",\n        linewidth=1,\n        linestyle=\"dotted\",\n        label=\"NHNM\",\n    )\n    plt.plot(\n        mid_noise_model.T,\n        mid_noise_model.psd,\n        \"k\",\n        linewidth=1,\n        linestyle=\"dashdot\",\n        label=\"Interpolated noise model\",\n    )\n    plt.plot(\n        low_noise_model.T,\n        low_noise_model.psd,\n        \"k\",\n        linewidth=1,\n        linestyle=\"dashed\",\n        label=\"NLNM\",\n    )\n    plt.gca().set_xscale(\"log\")\n    plt.xlim(low_noise_model.T[0], low_noise_model.T[-1])\n    plt.xlabel(\"Period [s]\")\n    plt.ylabel(\"Power Spectral Density (dB/Hz)\")\n    plt.legend()\n    plt.savefig(\"peterson.png\", transparent=True)\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Classes:</p> <ul> <li> <code>NoiseModel</code>           \u2013            <p>Class to store seismic noise models.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>generate_noise</code>             \u2013              <p>Generate a random seismogram from a noise model. Realistic seismic noise is</p> </li> <li> <code>peterson</code>             \u2013              <p>Generate a noise model by interpolating between Peterson's[^1]</p> </li> </ul>"},{"location":"api/pysmo/tools/noise/#pysmo.tools.noise.NoiseModel","title":"NoiseModel  <code>dataclass</code>","text":"<p>Class to store seismic noise models.</p> <p>Attributes:</p> <ul> <li> <code>psd</code>               (<code>ndarray</code>)           \u2013            <p>Power spectral density of ground acceleration [dB].</p> </li> <li> <code>T</code>               (<code>ndarray</code>)           \u2013            <p>Period [seconds].</p> </li> </ul> Source code in <code>pysmo/tools/noise.py</code> <pre><code>@dataclass(frozen=True)\nclass NoiseModel:\n    \"\"\"Class to store seismic noise models.\n\n    Attributes:\n        psd: Power spectral density of ground acceleration [dB].\n        T: Period [seconds].\n    \"\"\"\n\n    psd: np.ndarray = field(default_factory=lambda: np.array([]))\n    T: np.ndarray = field(default_factory=lambda: np.array([]))\n\n    def __post_init__(self) -&gt; None:\n        if np.size(self.psd) != np.size(self.T):\n            raise ValueError(\n                \"dB and T arrays are not of same size\",\n                f\"({np.size(self.psd)} != {np.size(self.T)}\",\n            )\n        self.psd.flags.writeable = False\n        self.T.flags.writeable = False\n</code></pre>"},{"location":"api/pysmo/tools/noise/#pysmo.tools.noise.generate_noise","title":"generate_noise","text":"<pre><code>generate_noise(\n    model: NoiseModel,\n    npts: int,\n    delta: timedelta = delta.value,\n    begin_time: datetime = begin_time.value,\n    return_velocity: bool = False,\n    seed: int | None = None,\n) -&gt; MiniSeismogram\n</code></pre> <p>Generate a random seismogram from a noise model. Realistic seismic noise is generated by assigning random phases to a fixed amplitude spectrum prescribed by a noise model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>NoiseModel</code>)           \u2013            <p>Noise model used to compute seismic noise.</p> </li> <li> <code>npts</code>               (<code>int</code>)           \u2013            <p>Number of points of generated noise</p> </li> <li> <code>delta</code>               (<code>timedelta</code>, default:                   <code>delta.value</code> )           \u2013            <p>Sampling interval of generated noise</p> </li> <li> <code>begin_time</code>               (<code>datetime</code>, default:                   <code>begin_time.value</code> )           \u2013            <p>Seismogram begin time</p> </li> <li> <code>return_velocity</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return velocity instead of acceleration.</p> </li> <li> <code>seed</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>set random seed manually (usually for testing purposes).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MiniSeismogram</code>           \u2013            <p>Seismogram with random seismic noise as data.</p> </li> </ul> Source code in <code>pysmo/tools/noise.py</code> <pre><code>def generate_noise(\n    model: NoiseModel,\n    npts: int,\n    delta: timedelta = SEISMOGRAM_DEFAULTS.delta.value,\n    begin_time: datetime = SEISMOGRAM_DEFAULTS.begin_time.value,\n    return_velocity: bool = False,\n    seed: int | None = None,\n) -&gt; MiniSeismogram:\n    \"\"\"Generate a random seismogram from a noise model. Realistic seismic noise is\n    generated by assigning random phases to a fixed amplitude spectrum prescribed by a\n    noise model.\n\n    Parameters:\n        model: Noise model used to compute seismic noise.\n        npts: Number of points of generated noise\n        delta: Sampling interval of generated noise\n        begin_time: Seismogram begin time\n        return_velocity: Return velocity instead of acceleration.\n        seed: set random seed manually (usually for testing purposes).\n\n    Returns:\n        Seismogram with random seismic noise as data.\n    \"\"\"\n    # Sampling frequency\n    Fs = 1 / delta.total_seconds()\n\n    # Nyquist frequency\n    Fnyq = 0.5 / delta.total_seconds()\n\n    # get next power of 2 of the nunmber of points and calculate frequencies from\n    # Fs/NPTS to Fnyq (we skip a frequency of 0 for now to avoid dividing by 0)\n    NPTS = int(2 ** np.ceil(np.log2(npts)))\n    freqs = np.linspace(Fs / NPTS, Fnyq, NPTS - 1)\n\n    # interpolate psd and recreate amplitude spectrum with the first\n    # term=0 (i.e. mean=0).\n    Pxx = np.interp(1 / freqs, model.T, model.psd)\n    spectrum = np.append(\n        np.array([0]), np.sqrt(10 ** (Pxx / 10) * NPTS / delta.total_seconds() * 2)\n    )\n\n    # phase is randomly generated\n    rng = np.random.default_rng(seed)\n    phase = (rng.random(NPTS) - 0.5) * np.pi * 2\n\n    # combine amplitude with phase and perform ifft\n    NewX = spectrum * (np.cos(phase) + 1j * np.sin(phase))\n    acceleration = np.fft.irfft(NewX)\n\n    start = int((NPTS - npts) / 2)\n    end = start + npts\n    if return_velocity:\n        velocity = cumulative_trapezoid(acceleration, dx=delta.total_seconds())\n        velocity = velocity[start:end]\n        return MiniSeismogram(begin_time=begin_time, delta=delta, data=velocity)\n    acceleration = acceleration[start:end]\n    return MiniSeismogram(begin_time=begin_time, delta=delta, data=acceleration)\n</code></pre>"},{"location":"api/pysmo/tools/noise/#pysmo.tools.noise.peterson","title":"peterson","text":"<pre><code>peterson(noise_level: float) -&gt; NoiseModel\n</code></pre> <p>Generate a noise model by interpolating between Peterson's<sup>1</sup> New Low Noise Model (NLNM) and New High Noice Model (NHNM).</p> <ol> <li> <p>Peterson, Jon R. Observations and Modeling of Seismic Background Noise. Report, 93\u2013322, 1993, https://doi.org/10.3133/ofr93322. USGS Publications Warehouse.\u00a0\u21a9</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>noise_level</code>               (<code>float</code>)           \u2013            <p>Determines the noise level of the generated noise model.          A noise level of 0 returns the NLNM, 1 returns the NHNM,          and anything &gt; 0 and &lt; 1 returns an interpolated model          that lies between the NLNM and NHNM.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NoiseModel</code>           \u2013            <p>Noise model.</p> </li> </ul> Source code in <code>pysmo/tools/noise.py</code> <pre><code>def peterson(noise_level: float) -&gt; NoiseModel:\n    \"\"\"Generate a noise model by interpolating between Peterson's[^1]\n    New Low Noise Model (NLNM) and New High Noice Model (NHNM).\n\n    [^1]: Peterson, Jon R. Observations and Modeling of Seismic Background\n        Noise. Report, 93\u2013322, 1993, https://doi.org/10.3133/ofr93322. USGS\n        Publications Warehouse.\n\n    Parameters:\n        noise_level: Determines the noise level of the generated noise model.\n                     A noise level of 0 returns the NLNM, 1 returns the NHNM,\n                     and anything &gt; 0 and &lt; 1 returns an interpolated model\n                     that lies between the NLNM and NHNM.\n\n    Returns:\n        Noise model.\n    \"\"\"\n    # check for valid input\n    if not 0 &lt;= noise_level &lt;= 1:\n        raise ValueError(\n            f\"Parameter noise_level={noise_level} is not within 0-1 range.\"\n        )\n\n    # calculate noise model\n    if noise_level == 0:\n        return NLNM\n    elif noise_level == 1:\n        return NHNM\n    else:\n        T_common = np.unique(np.concatenate((NLNM.T, NHNM.T)))\n        NLNM_interp = np.interp(T_common, NLNM.T, NLNM.psd)\n        NHNM_interp = np.interp(T_common, NHNM.T, NHNM.psd)\n        dB = NLNM_interp + (NHNM_interp - NLNM_interp) * noise_level\n        return NoiseModel(psd=dB, T=T_common)\n</code></pre>"},{"location":"api/pysmo/tools/plotutils/","title":"plotutils","text":""},{"location":"api/pysmo/tools/plotutils/#pysmo.tools.plotutils","title":"pysmo.tools.plotutils","text":"<p>Utilities for plotting with pysmo types.</p> <p>Pysmo provides functions that perform common operations on the types of data that match pysmo's types.</p> <p>Functions:</p> <ul> <li> <code>plotseis</code>             \u2013              <p>Plot Seismogram objects.</p> </li> <li> <code>time_array</code>             \u2013              <p>Create an array containing Matplotlib dates.</p> </li> <li> <code>unix_time_array</code>             \u2013              <p>Create an array containing unix epoch dates.</p> </li> </ul>"},{"location":"api/pysmo/tools/plotutils/#pysmo.tools.plotutils.plotseis","title":"plotseis","text":"<pre><code>plotseis(\n    *seismograms: Seismogram,\n    outfile: str = \"\",\n    showfig: bool = True,\n    title: str = \"\",\n    **kwargs: dict\n) -&gt; Figure\n</code></pre> <p>Plot Seismogram objects.</p> <p>Parameters:</p> <ul> <li> <code>seismograms</code>               (<code>Seismogram</code>, default:                   <code>()</code> )           \u2013            <p>One or more seismogram objects. If a 'label' attribute is found          it will be used to label the trace in the plot.</p> </li> <li> <code>outfile</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Optionally save figure to this filename.</p> </li> <li> <code>showfig</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Display figure.</p> </li> <li> <code>title</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Optionally set figure title.</p> </li> <li> <code>kwargs</code>               (<code>dict</code>, default:                   <code>{}</code> )           \u2013            <p>Optionally add kwargs to pass to the plot command</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.plotutils import plotseis\n&gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; fig = plotseis(seis)\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/plotutils.py</code> <pre><code>def plotseis(\n    *seismograms: Seismogram,\n    outfile: str = \"\",\n    showfig: bool = True,\n    title: str = \"\",\n    **kwargs: dict,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"Plot Seismogram objects.\n\n    Parameters:\n        seismograms: One or more seismogram objects. If a 'label' attribute is found\n                     it will be used to label the trace in the plot.\n        outfile: Optionally save figure to this filename.\n        showfig: Display figure.\n        title: Optionally set figure title.\n        kwargs: Optionally add kwargs to pass to the plot command\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.plotutils import plotseis\n        &gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; fig = plotseis(seis)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    fig = plt.figure()\n    for seis in seismograms:\n        time = time_array(seis)\n        plt.plot(time, seis.data, scalex=True, scaley=True, **kwargs)\n    plt.xlabel(\"Time\")\n    plt.gcf().autofmt_xdate()\n    fmt = mdates.DateFormatter(\"%H:%M:%S\")\n    plt.gca().xaxis.set_major_formatter(fmt)\n    if not title:\n        left, _ = plt.xlim()\n        title = mdates.num2date(left).strftime(\"%Y-%m-%d %H:%M:%S\")\n    plt.title(title)\n    if outfile:\n        plt.savefig(outfile)\n    if showfig:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"api/pysmo/tools/plotutils/#pysmo.tools.plotutils.time_array","title":"time_array","text":"<pre><code>time_array(seismogram: Seismogram) -&gt; ndarray\n</code></pre> <p>Create an array containing Matplotlib dates.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>Seismogram</code>)           \u2013            <p>Seismogram object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array containing the Matplotlib dates of seismogram data.</p> </li> <li> <code>ndarray</code>           \u2013            <p>array containing the Matplotlib dates (number of days since 1970)</p> </li> <li> <code>ndarray</code>           \u2013            <p>of each point in the seismogram data.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.tools.plotutils import time_array\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; seis_data = seis.data\n&gt;&gt;&gt; seis_times = time_array(seis)\n&gt;&gt;&gt; for t, v in zip(seis_times, seis_data):\n...     print(t,v)\n...\n12843.30766388889 2302.0\n12843.307664120372 2313.0\n12843.307664351854 2345.0\n12843.307664583335 2377.0\n...\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/plotutils.py</code> <pre><code>def time_array(seismogram: Seismogram) -&gt; np.ndarray:\n    \"\"\"Create an array containing Matplotlib dates.\n\n    Parameters:\n        seismogram: Seismogram object.\n\n    Returns:\n        Array containing the Matplotlib dates of seismogram data.\n        array containing the Matplotlib dates (number of days since 1970)\n        of each point in the seismogram data.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.tools.plotutils import time_array\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; seis_data = seis.data\n        &gt;&gt;&gt; seis_times = time_array(seis)\n        &gt;&gt;&gt; for t, v in zip(seis_times, seis_data):\n        ...     print(t,v)\n        ...\n        12843.30766388889 2302.0\n        12843.307664120372 2313.0\n        12843.307664351854 2345.0\n        12843.307664583335 2377.0\n        ...\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    start = mdates.date2num(seismogram.begin_time)\n    end = mdates.date2num(seismogram.end_time)\n    return np.linspace(start, end, len(seismogram))\n</code></pre>"},{"location":"api/pysmo/tools/plotutils/#pysmo.tools.plotutils.unix_time_array","title":"unix_time_array","text":"<pre><code>unix_time_array(seismogram: Seismogram) -&gt; ndarray\n</code></pre> <p>Create an array containing unix epoch dates.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>Seismogram</code>)           \u2013            <p>Seismogram object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>array containing the unix epoch times (number of seconds since 1970)</p> </li> <li> <code>ndarray</code>           \u2013            <p>of each point in the seismogram data.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.plotutils import unix_time_array\n&gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; seis_data = seis.data\n&gt;&gt;&gt; seis_times = unix_time_array(seis)\n&gt;&gt;&gt; for t, v in zip(seis_times, seis_data):\n...     print(t,v)\n...\n1109661782.16 2302.0\n1109661782.18 2313.0\n1109661782.2 2345.0\n1109661782.22 2377.0\n...\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/plotutils.py</code> <pre><code>def unix_time_array(seismogram: Seismogram) -&gt; np.ndarray:\n    \"\"\"Create an array containing unix epoch dates.\n\n    Parameters:\n        seismogram: Seismogram object.\n\n    Returns:\n        array containing the unix epoch times (number of seconds since 1970)\n        of each point in the seismogram data.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.plotutils import unix_time_array\n        &gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; seis_data = seis.data\n        &gt;&gt;&gt; seis_times = unix_time_array(seis)\n        &gt;&gt;&gt; for t, v in zip(seis_times, seis_data):\n        ...     print(t,v)\n        ...\n        1109661782.16 2302.0\n        1109661782.18 2313.0\n        1109661782.2 2345.0\n        1109661782.22 2377.0\n        ...\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    start = seismogram.begin_time.timestamp()\n    end = seismogram.end_time.timestamp()\n    return np.linspace(start, end, len(seismogram))\n</code></pre>"},{"location":"api/pysmo/tools/signal/","title":"signal","text":""},{"location":"api/pysmo/tools/signal/#pysmo.tools.signal","title":"pysmo.tools.signal","text":"<p>Functions used in signal processing.</p> <p>Functions:</p> <ul> <li> <code>delay</code>             \u2013              <p>Cross correlates two seismograms to determine signal delay.</p> </li> <li> <code>envelope</code>             \u2013              <p>Calculates the envelope of a gaussian filtered seismogram.</p> </li> <li> <code>gauss</code>             \u2013              <p>Returns a gaussian filtered seismogram.</p> </li> </ul>"},{"location":"api/pysmo/tools/signal/#pysmo.tools.signal.delay","title":"delay","text":"<pre><code>delay(\n    seismogram1: Seismogram,\n    seismogram2: Seismogram,\n    total_delay: bool = False,\n    max_shift: timedelta | None = None,\n    abs_max: bool = False,\n) -&gt; tuple[timedelta, float]\n</code></pre> <p>Cross correlates two seismograms to determine signal delay.</p> <p>This function is a wrapper around the [<code>scipy.signal.correlate</code>][] function. The default behavior is to call the correlate function with <code>mode=\"full\"</code> using the full length data of the input seismograms. This is the most robust option, but also the slowest.</p> <p>If an approximate delay is known (e.g. because a particular phase is being targeted using a computed arrival time), the search space can be limited by setting the <code>max_shift</code> parameter to a value. The length of the seismogram data used for the cross-correlation is then set such that the calculated delay lies within +/- <code>max_shift</code>.</p> Note <p><code>max_shift</code> intentionally does not take the begin times of the seismograms into consideration. Thus, calling <code>delay()</code> with <code>total_delay=True</code> may return a delay that is larger than <code>max_shift</code>.</p> <p>Implications of setting the <code>max_shift</code> parameter are as follows:</p> <ul> <li>This mode requires the seismograms to be of equal length.</li> <li>If the true delay (i.e. the amount of time the seismograms should be   shifted by) lies within the <code>max_shift</code> range, and also produces the   highest correlation, the delay time returned is identical for both   methods.</li> <li>If the true delay lies outside the <code>max_shift</code> range and produces the   highest correlation, the delay time returned will be incorrect when   <code>max_shift</code> is set.</li> <li>In the event that the true delay lies within the <code>max_shift</code> range but   the maximum signal correlation occurs outside, it will be correctly   retrieved when the <code>max_shift</code> parameter is set, while not setting it   yields an incorrect result.</li> </ul> <p>Parameters:</p> <ul> <li> <code>seismogram1</code>               (<code>Seismogram</code>)           \u2013            <p>First seismogram to use for cross correlation.</p> </li> <li> <code>seismogram2</code>               (<code>Seismogram</code>)           \u2013            <p>Second seismogram to use for cross correlation.</p> </li> <li> <code>total_delay</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Include the difference in <code>begin_time</code> in the delay.</p> </li> <li> <code>max_shift</code>               (<code>timedelta | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum (absolute) length of the delay.</p> </li> <li> <code>abs_max</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return the delay corresponding to absolute maximum.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>delay</code> (              <code>timedelta</code> )          \u2013            <p>Time delay of the second seismogram with respect to the first.</p> </li> <li> <code>ccnorm</code> (              <code>float</code> )          \u2013            <p>Normalised cross correlation value of the overlapping seismograms after shifting (uses [<code>scipy.stats.mstats.pearsonr</code>][] for the calculation). This value ranges from -1 to 1, with 1 indicating a perfect correlation, 0 indicating no correlation, and -1 indicating a perfect anti-correlation.</p> </li> </ul> <p>Examples:</p> <p>To illustration the use of the <code>delay()</code> function, we read a seismogram from a SAC file and then generate a second seismogram from it by modifying it with a shift in the data and a shift in the begin time. This means the true delay is known, and we are able to compare the computed delays with this known delay:</p> <pre><code>&gt;&gt;&gt; from pysmo import MiniSeismogram\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.functions import detrend, clone_to_mini\n&gt;&gt;&gt; from pysmo.tools.signal import delay\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a Seismogram from a SAC file and detrend it:\n&gt;&gt;&gt; seis1 = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; detrend(seis1)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Create a second seismogram from the first with\n&gt;&gt;&gt; # a different begin_time and a shift in the data:\n&gt;&gt;&gt; seis2 = clone_to_mini(MiniSeismogram, seis1)\n&gt;&gt;&gt; nroll = 1234\n&gt;&gt;&gt; seis2.data = np.roll(seis2.data, nroll)\n&gt;&gt;&gt; begin_time_delay = timedelta(seconds=100)\n&gt;&gt;&gt; seis2.begin_time += begin_time_delay\n&gt;&gt;&gt;\n&gt;&gt;&gt; # The signal delay is the number of samples shifted * delta:\n&gt;&gt;&gt; (signal_delay := nroll * seis1.delta).total_seconds()\n24.68\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Call the delay function with the two seismograms and verify\n&gt;&gt;&gt; # that the caclulated_delay is equal to the known signal delay:\n&gt;&gt;&gt; calculated_delay, _ = delay(seis1, seis2)\n&gt;&gt;&gt; calculated_delay == signal_delay\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>As we know what the true delay is, we can mimic a scenario where an approximate delay is known prior to the cross-correlation, which can be used to limit the search space and speed up the calculation. Here we assign a value of the known signal delay plus 1 second to the <code>max_shift</code> parameter:</p> <pre><code>&gt;&gt;&gt; max_shift = signal_delay + timedelta(seconds=1)\n&gt;&gt;&gt; calculated_delay, _ = delay(seis1, seis2, max_shift=max_shift)\n&gt;&gt;&gt; # As before, the calculated delay should be equal to the signal delay:\n&gt;&gt;&gt; calculated_delay == signal_delay\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>Setting <code>total_delay=True</code>, we also takes into account the difference in <code>begin_time</code> between the two seismograms:</p> <pre><code>&gt;&gt;&gt; calculated_delay, _ = delay(seis1, seis2, total_delay=True, max_shift=signal_delay+timedelta(seconds=1))\n&gt;&gt;&gt; # With `total_delay=True`, the calculated delay should be equal to\n&gt;&gt;&gt; # the signal delay plus the begin time difference:\n&gt;&gt;&gt; calculated_delay == signal_delay + (seis1.begin_time - seis2.begin_time)\nTrue\n&gt;&gt;&gt;\n</code></pre> <p>To demonstrate usage of the <code>abs_max</code> parameter, we flip the sign of the second seismogram data:</p> <pre><code>&gt;&gt;&gt; seis2.data *= -1\n&gt;&gt;&gt; calculated_delay, ccnorm = delay(seis1, seis2)\n&gt;&gt;&gt; # Without `abs_max=True`, the calculated delay is no longer equal\n&gt;&gt;&gt; # to the true signal delay (as expected):\n&gt;&gt;&gt; calculated_delay == signal_delay\nFalse\n&gt;&gt;&gt; # The normalised cross correlation value is also not very high\n&gt;&gt;&gt; ccnorm\nnp.float64(0.4267205)\n&gt;&gt;&gt;\n&gt;&gt;&gt; calculated_delay, ccnorm = delay(seis1, seis2, abs_max=True)\n&gt;&gt;&gt; # with `abs_max=True`, the signal delay is again retrieved:\n&gt;&gt;&gt; calculated_delay == signal_delay\nTrue\n&gt;&gt;&gt; # And, as the signals are completely opposite, the normalised\n&gt;&gt;&gt; # cross correlation value is -1:\n&gt;&gt;&gt; np.testing.assert_approx_equal(ccnorm, -1)\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/signal/_delay.py</code> <pre><code>def delay(\n    seismogram1: Seismogram,\n    seismogram2: Seismogram,\n    total_delay: bool = False,\n    max_shift: timedelta | None = None,\n    abs_max: bool = False,\n) -&gt; tuple[timedelta, float]:\n    \"\"\"\n    Cross correlates two seismograms to determine signal delay.\n\n    This function is a wrapper around the\n    [`scipy.signal.correlate`][scipy.signal.correlate] function. The default\n    behavior is to call the correlate function with `#!py mode=\"full\"` using\n    the full length data of the input seismograms. This is the most robust\n    option, but also the slowest.\n\n    If an approximate delay is known (e.g. because a particular phase is being\n    targeted using a computed arrival time), the search space can be limited\n    by setting the `max_shift` parameter to a value. The length of the\n    seismogram data used for the cross-correlation is then set such that the\n    calculated delay lies within +/- `max_shift`.\n\n    Note:\n        `max_shift` intentionally does *not* take the begin times of the\n        seismograms into consideration. Thus, calling `#!py delay()` with\n        `#!py total_delay=True` may return a delay that is larger than\n        `max_shift`.\n\n    Implications of setting the `max_shift` parameter are as follows:\n\n    - This mode requires the seismograms to be of equal length.\n    - If the true delay (i.e. the amount of time the seismograms _should_ be\n      shifted by) lies within the `max_shift` range, and also produces the\n      highest correlation, the delay time returned is identical for both\n      methods.\n    - If the true delay lies outside the `max_shift` range and produces the\n      highest correlation, the delay time returned will be incorrect when\n      `max_shift` is set.\n    - In the event that the true delay lies within the `max_shift` range but\n      the maximum signal correlation occurs outside, it will be correctly\n      retrieved when the `max_shift` parameter is set, while not setting it\n      yields an incorrect result.\n\n\n    Parameters:\n        seismogram1: First seismogram to use for cross correlation.\n        seismogram2: Second seismogram to use for cross correlation.\n        total_delay: Include the difference in `begin_time` in the delay.\n        max_shift: Maximum (absolute) length of the delay.\n        abs_max: Return the delay corresponding to absolute maximum.\n\n    Returns:\n        delay: Time delay of the second seismogram with respect to the first.\n        ccnorm: Normalised cross correlation value of the overlapping\n            seismograms *after* shifting (uses\n            [`scipy.stats.mstats.pearsonr`][scipy.stats.mstats.pearsonr] for\n            the calculation). This value ranges from -1 to 1, with 1 indicating\n            a perfect correlation, 0 indicating no correlation, and -1\n            indicating a perfect anti-correlation.\n\n    Examples:\n        To illustration the use of the `delay()` function, we read a seismogram\n        from a SAC file and then generate a second seismogram from it by\n        modifying it with a shift in the data and a shift in the begin time.\n        This means the true delay is known, and we are able to compare the\n        computed delays with this known delay:\n\n        ```python\n        &gt;&gt;&gt; from pysmo import MiniSeismogram\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.functions import detrend, clone_to_mini\n        &gt;&gt;&gt; from pysmo.tools.signal import delay\n        &gt;&gt;&gt; from datetime import timedelta\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a Seismogram from a SAC file and detrend it:\n        &gt;&gt;&gt; seis1 = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; detrend(seis1)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Create a second seismogram from the first with\n        &gt;&gt;&gt; # a different begin_time and a shift in the data:\n        &gt;&gt;&gt; seis2 = clone_to_mini(MiniSeismogram, seis1)\n        &gt;&gt;&gt; nroll = 1234\n        &gt;&gt;&gt; seis2.data = np.roll(seis2.data, nroll)\n        &gt;&gt;&gt; begin_time_delay = timedelta(seconds=100)\n        &gt;&gt;&gt; seis2.begin_time += begin_time_delay\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # The signal delay is the number of samples shifted * delta:\n        &gt;&gt;&gt; (signal_delay := nroll * seis1.delta).total_seconds()\n        24.68\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Call the delay function with the two seismograms and verify\n        &gt;&gt;&gt; # that the caclulated_delay is equal to the known signal delay:\n        &gt;&gt;&gt; calculated_delay, _ = delay(seis1, seis2)\n        &gt;&gt;&gt; calculated_delay == signal_delay\n        True\n        &gt;&gt;&gt;\n        ```\n\n        As we know what the true delay is, we can mimic a scenario where an\n        approximate delay is known prior to the cross-correlation, which can be\n        used to limit the search space and speed up the calculation. Here we\n        assign a value of the known signal delay plus 1 second to the\n        `max_shift` parameter:\n\n        ```python\n        &gt;&gt;&gt; max_shift = signal_delay + timedelta(seconds=1)\n        &gt;&gt;&gt; calculated_delay, _ = delay(seis1, seis2, max_shift=max_shift)\n        &gt;&gt;&gt; # As before, the calculated delay should be equal to the signal delay:\n        &gt;&gt;&gt; calculated_delay == signal_delay\n        True\n        &gt;&gt;&gt;\n        ```\n\n        Setting `total_delay=True`, we also takes into account the difference\n        in `begin_time` between the two seismograms:\n\n        ```python\n        &gt;&gt;&gt; calculated_delay, _ = delay(seis1, seis2, total_delay=True, max_shift=signal_delay+timedelta(seconds=1))\n        &gt;&gt;&gt; # With `total_delay=True`, the calculated delay should be equal to\n        &gt;&gt;&gt; # the signal delay plus the begin time difference:\n        &gt;&gt;&gt; calculated_delay == signal_delay + (seis1.begin_time - seis2.begin_time)\n        True\n        &gt;&gt;&gt;\n        ```\n\n        To demonstrate usage of the `abs_max` parameter, we flip the sign of\n        the second seismogram data:\n\n        ```python\n        &gt;&gt;&gt; seis2.data *= -1\n        &gt;&gt;&gt; calculated_delay, ccnorm = delay(seis1, seis2)\n        &gt;&gt;&gt; # Without `abs_max=True`, the calculated delay is no longer equal\n        &gt;&gt;&gt; # to the true signal delay (as expected):\n        &gt;&gt;&gt; calculated_delay == signal_delay\n        False\n        &gt;&gt;&gt; # The normalised cross correlation value is also not very high\n        &gt;&gt;&gt; ccnorm\n        np.float64(0.4267205)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; calculated_delay, ccnorm = delay(seis1, seis2, abs_max=True)\n        &gt;&gt;&gt; # with `abs_max=True`, the signal delay is again retrieved:\n        &gt;&gt;&gt; calculated_delay == signal_delay\n        True\n        &gt;&gt;&gt; # And, as the signals are completely opposite, the normalised\n        &gt;&gt;&gt; # cross correlation value is -1:\n        &gt;&gt;&gt; np.testing.assert_approx_equal(ccnorm, -1)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n\n    if seismogram1.delta != seismogram2.delta:\n        raise ValueError(\"Input seismograms must have the same sampling rate.\")\n\n    if max_shift is not None and len(seismogram1) != len(seismogram2):\n        raise ValueError(\n            \"Input seismograms must be of equal length when using `max_shift`.\"\n        )\n\n    data1, data2 = seismogram1.data, seismogram2.data\n    delta = seismogram1.delta\n\n    if max_shift is not None:\n        max_lag_in_samples = math.ceil(max_shift / delta)\n        zeros_to_add = np.zeros(max_lag_in_samples)\n        data1 = np.append(zeros_to_add, data1)\n        data1 = np.append(data1, zeros_to_add)\n        corr = _correlate(data1, data2, mode=\"valid\")\n    else:\n        corr = _correlate(data1, data2, mode=\"full\")\n\n    corr_index = np.argmax(corr)\n\n    if abs_max and np.max(corr) &lt; -1 * np.min(corr):\n        corr_index = np.argmin(corr)\n\n    if max_shift is not None:\n        shift = -int(corr_index - max_lag_in_samples)\n    else:\n        shift = int(np.size(data2) - 1 - corr_index)\n\n    delay = shift * delta\n\n    # find overlapping parts of seismograms after allignment\n    if shift &lt; 0:\n        data1 = data1[-shift:]\n    else:\n        data2 = data2[shift:]\n    if np.size(data1) &gt; np.size(data2):\n        data1 = data1[: np.size(data2)]\n    else:\n        data2 = data2[: np.size(data1)]\n\n    covr, _ = _pearsonr(data1, data2)\n\n    if total_delay:\n        delay += seismogram1.begin_time - seismogram2.begin_time\n\n    return delay, covr\n</code></pre>"},{"location":"api/pysmo/tools/signal/#pysmo.tools.signal.envelope","title":"envelope","text":"<pre><code>envelope(\n    seismogram: envelope[T], Tn: float, alpha: float\n) -&gt; envelope[T]\n</code></pre> <p>Calculates the envelope of a gaussian filtered seismogram.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>envelope[T]</code>)           \u2013            <p>Name of the seismogram object passed to this function.</p> </li> <li> <code>Tn</code>               (<code>float</code>)           \u2013            <p>Center period of Gaussian filter [in seconds]</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Set alpha (which determines filterwidth)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>envelope[T]</code>           \u2013            <p>Seismogram containing the envelope</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.signal import envelope\n&gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; Tn = 50 # Center Gaussian filter at 50s period\n&gt;&gt;&gt; alpha = 50 # Set alpha (which determines filterwidth) to 50\n&gt;&gt;&gt; envelope_seis = envelope(seis, Tn, alpha)\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/signal/_gauss.py</code> <pre><code>def envelope[T: Seismogram](seismogram: T, Tn: float, alpha: float) -&gt; T:\n    \"\"\"\n    Calculates the envelope of a gaussian filtered seismogram.\n\n    Parameters:\n        seismogram: Name of the seismogram object passed to this function.\n        Tn: Center period of Gaussian filter [in seconds]\n        alpha: Set alpha (which determines filterwidth)\n\n    Returns:\n        Seismogram containing the envelope\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.signal import envelope\n        &gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; Tn = 50 # Center Gaussian filter at 50s period\n        &gt;&gt;&gt; alpha = 50 # Set alpha (which determines filterwidth) to 50\n        &gt;&gt;&gt; envelope_seis = envelope(seis, Tn, alpha)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    clone = deepcopy(seismogram)\n    clone.data = _gauss(seismogram, Tn, alpha)[0]\n    return clone\n</code></pre>"},{"location":"api/pysmo/tools/signal/#pysmo.tools.signal.gauss","title":"gauss","text":"<pre><code>gauss(\n    seismogram: gauss[T], Tn: float, alpha: float\n) -&gt; gauss[T]\n</code></pre> <p>Returns a gaussian filtered seismogram.</p> <p>Parameters:</p> <ul> <li> <code>seismogram</code>               (<code>gauss[T]</code>)           \u2013            <p>Name of the SAC object passed to this function.</p> </li> <li> <code>Tn</code>               (<code>float</code>)           \u2013            <p>Center period of Gaussian filter [in seconds]</p> </li> <li> <code>alpha</code>               (<code>float</code>)           \u2013            <p>Set alpha (which determines filterwidth)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>gauss[T]</code>           \u2013            <p>Gaussian filtered seismogram.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; from pysmo.tools.signal import gauss\n&gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n&gt;&gt;&gt; Tn = 50 # Center Gaussian filter at 50s period\n&gt;&gt;&gt; alpha = 50 # Set alpha (which determines filterwidth) to 50\n&gt;&gt;&gt; gauss_seis = gauss(seis, Tn, alpha)\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/signal/_gauss.py</code> <pre><code>def gauss[T: Seismogram](seismogram: T, Tn: float, alpha: float) -&gt; T:\n    \"\"\"\n    Returns a gaussian filtered seismogram.\n\n    Parameters:\n        seismogram: Name of the SAC object passed to this function.\n        Tn: Center period of Gaussian filter [in seconds]\n        alpha: Set alpha (which determines filterwidth)\n\n    Returns:\n        Gaussian filtered seismogram.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; from pysmo.classes import SAC\n        &gt;&gt;&gt; from pysmo.tools.signal import gauss\n        &gt;&gt;&gt; seis = SAC.from_file(\"example.sac\").seismogram\n        &gt;&gt;&gt; Tn = 50 # Center Gaussian filter at 50s period\n        &gt;&gt;&gt; alpha = 50 # Set alpha (which determines filterwidth) to 50\n        &gt;&gt;&gt; gauss_seis = gauss(seis, Tn, alpha)\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    clone = deepcopy(seismogram)\n    clone.data = _gauss(seismogram, Tn, alpha)[1]\n    return clone\n</code></pre>"},{"location":"api/pysmo/tools/utils/","title":"utils","text":""},{"location":"api/pysmo/tools/utils/#pysmo.tools.utils","title":"pysmo.tools.utils","text":"<p>Pysmo's little helpers.</p> <p>Functions:</p> <ul> <li> <code>average_datetimes</code>             \u2013              <p>Average a sequence of datetimes.</p> </li> <li> <code>uuid_shortener</code>             \u2013              <p>Shorten a sequence of UUIDs to their shortest unique representation.</p> </li> </ul>"},{"location":"api/pysmo/tools/utils/#pysmo.tools.utils.average_datetimes","title":"average_datetimes","text":"<pre><code>average_datetimes(\n    datetimes: Sequence[datetime],\n) -&gt; datetime\n</code></pre> <p>Average a sequence of datetimes.</p> <p>Parameters:</p> <ul> <li> <code>datetimes</code>               (<code>Sequence[datetime]</code>)           \u2013            <p>Datetimes to average.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>datetime</code>           \u2013            <p>Datetime representing average of all datetimes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an empty sequence is provides as input.</p> </li> </ul> Source code in <code>pysmo/tools/utils.py</code> <pre><code>def average_datetimes(datetimes: Sequence[datetime]) -&gt; datetime:\n    \"\"\"Average a sequence of datetimes.\n\n    Parameters:\n        datetimes: Datetimes to average.\n\n    Returns:\n        Datetime representing average of all datetimes.\n\n    Raises:\n        ValueError: If an empty sequence is provides as input.\n    \"\"\"\n    if len(datetimes) == 0:\n        raise ValueError(\"Cannot average empty sequence of datetimes.\")\n    reference_time = datetimes[0]\n    seconds = sum((i - reference_time).total_seconds() for i in datetimes[1:])\n    return reference_time + timedelta(seconds=seconds / len(datetimes))\n</code></pre>"},{"location":"api/pysmo/tools/utils/#pysmo.tools.utils.uuid_shortener","title":"uuid_shortener","text":"<pre><code>uuid_shortener(\n    uuids: Sequence[UUID], min_length: int = 4\n) -&gt; dict[str, UUID]\n</code></pre> <p>Shorten a sequence of UUIDs to their shortest unique representation.</p> <p>Parameters:</p> <ul> <li> <code>uuids</code>               (<code>Sequence[UUID]</code>)           \u2013            <p>UUIDs to shorten.</p> </li> <li> <code>min_length</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Minimum length of the shortened UUID strings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, UUID]</code>           \u2013            <p>Dictionary mapping shortened UUID strings to their original UUID objects.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an empty sequence is provided as input.</p> </li> <li> <code>ValueError</code>             \u2013            <p>If <code>min_length</code> is not between 1 and 36.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; from pysmo.tools.utils import uuid_shortener\n&gt;&gt;&gt;\n&gt;&gt;&gt; uuids = [uuid.uuid4() for _ in range(100)]\n&gt;&gt;&gt; for k, v in sorted(uuid_shortener(uuids).items()):\n...     print(f\"{k} -&gt; {v}\")\n...\n01d7 -&gt; 01d74256-3860-4ab6-96a4-02f23ae8cc93\n03c7 -&gt; 03c72ba8-d605-4770-8a63-f881ffd0f9d5\n080a -&gt; 080aadfb-e7c9-4b26-9141-25c63a9bedd4\n0e51 -&gt; 0e51f30d-c6a7-4e39-84b0-32ccd7c524a5\n...\n&gt;&gt;&gt;\n</code></pre> Source code in <code>pysmo/tools/utils.py</code> <pre><code>def uuid_shortener(uuids: Sequence[UUID], min_length: int = 4) -&gt; dict[str, UUID]:\n    \"\"\"Shorten a sequence of UUIDs to their shortest unique representation.\n\n    Parameters:\n        uuids: UUIDs to shorten.\n        min_length: Minimum length of the shortened UUID strings.\n\n    Returns:\n        Dictionary mapping shortened UUID strings to their original UUID objects.\n\n    Raises:\n        ValueError: If an empty sequence is provided as input.\n        ValueError: If `min_length` is not between 1 and 36.\n\n    Examples:\n        ```python\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; from pysmo.tools.utils import uuid_shortener\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; uuids = [uuid.uuid4() for _ in range(100)]\n        &gt;&gt;&gt; for k, v in sorted(uuid_shortener(uuids).items()):\n        ...     print(f\"{k} -&gt; {v}\")\n        ...\n        01d7 -&gt; 01d74256-3860-4ab6-96a4-02f23ae8cc93\n        03c7 -&gt; 03c72ba8-d605-4770-8a63-f881ffd0f9d5\n        080a -&gt; 080aadfb-e7c9-4b26-9141-25c63a9bedd4\n        0e51 -&gt; 0e51f30d-c6a7-4e39-84b0-32ccd7c524a5\n        ...\n        &gt;&gt;&gt;\n        ```\n    \"\"\"\n    UUID_LENGTH = 36\n\n    if len(uuids) == 0:\n        raise ValueError(\"Cannot shorten empty sequence of UUIDs.\")\n\n    if not (1 &lt;= min_length &lt;= UUID_LENGTH):\n        raise ValueError(f\"min_length must be between 1 and {UUID_LENGTH}.\")\n\n    for length in range(min_length, UUID_LENGTH + 1):\n        shortened = [u[:length] for u in map(str, uuids)]\n        if len(set(shortened)) == len(uuids):\n            return {u: uuid for u, uuid in zip(shortened, uuids)}\n\n    # Fallback to full UUIDs if necessary (like that's going to happen...)\n    return {str(u): u for u in uuids}\n</code></pre>"},{"location":"developing/","title":"Developing pysmo","text":"<p>A central feature of pysmo is that any code using pysmo is easily reusable. Therefore, any time you use pysmo, you are potentially also writing code that can potentially be considered as part of pysmo itself. If this leads to you maintaining your own fork, or even contributing back to pysmo, it is important to understand a few things about pysmo code and repository structure.</p>"},{"location":"developing/#readmemd-files","title":"<code>README.md</code> files","text":"<p>The first step when developing pysmo is probably to browse the source to get a feel for how the code is organised and to read through the <code>README.md</code> files you find throughout the source directory. You may also need to edit these <code>README.md</code> files if you introduce major changes to the code.</p>"},{"location":"developing/#__init__py-files-and-api-reference","title":"<code>__init__.py</code> files and API Reference","text":"<p>The <code>__init__.py</code> files are the entry points for pysmo, and they will most likely need to be edited when introducing new features to pysmo.</p> <p>Similarly, the API reference in the docs folder may need editing to include the documentation of your code.</p>"},{"location":"developing/#formatting-and-style","title":"Formatting and style","text":""},{"location":"developing/#code","title":"Code","text":"<p>Adhering to python conventions such as PEP 8 and linting code with e.g. flake8 results in clean and easily readable code. Aside from using those kinds of tools, we highly encourage writing self-documenting code. For example, instead of writing code to calculate velocity like this:</p> documented-code.py<pre><code># Calculate the velocity v\ndef v(d: float, t: float) -&gt; float:\n  \"\"\"Calculates the velocity from distance and time.\"\"\"\n  # distance is d\n  # time is t\n  return d / t\n</code></pre> <p>Use more meaningful variable (and function) names to write code that is easier to read and less error prone:</p> self-documenting-code.py<pre><code>def velocity(distance: float, time: float) -&gt; float:\n  \"\"\"Calculates the velocity from distance and time.\"\"\"\n  return distance / time\n</code></pre>"},{"location":"developing/#documentation","title":"Documentation","text":"<p>This documentation is built using mkdocs using the material theme. Thus the main documentation source files are written in Markdown. The docstrings in the <code>.py</code> files are included via the mkdocstrings plugin. Please write the docstrings using the google style.</p>"},{"location":"developing/#testing","title":"Testing","text":"<p>Testing may present a chicken and egg type of situation, where the reference test data are calculated from the code that is being tested itself. While this does help avoid future code changes from breaking things, there is no way to know if the initial code is actually correct (e.g. free from logical errors). Ideally, test data should therefore be calculated using external tools. Where this is not possible, we suggest writing tests that involve creating figures (with matplotlib) that can be manually inspected to see if the output makes sense. These figures then become the reference data that future test runs can use via the pytest-mpl extension automatically.</p>"},{"location":"developing/contributing/","title":"Contributing","text":"<p>Thank you for considering contributing to pysmo. We welcome your contribution! To make the process as seamless as possible, please read through this guide carefully.</p>"},{"location":"developing/contributing/#what-are-contributions","title":"What are contributions?","text":"<p>Broadly speaking, contributions fall into the following categories:</p> <ul> <li>Questions: the easiest way to contribute to pysmo is ask for help if   something is unclear or you get stuck. Questions provide important   feedback that helps us determine what parts of pysmo might need attention,   so we are always keen to help. Development of pysmo happens publicly on   GitHub, and we kindly request that you   ask your questions there too. You may either create a new   issue or start a   discussion. Please also   feel free to answer any questions (including your own, should you figure it   out!) to help out other users.</li> <li>Bug reports: if something needs fixing in psymo we definitely want to hear   about it! Please create a new issue,   or add relevant information to an issue if one already exists for the bug   you found. Bonus points if you also provide a patch that fixes the bug!</li> <li>Enhancements: we reckon that if you are able to use pysmo, you are also   able to write code that can become part of pysmo. These can be things such as   useful functions, new pysmo types, or a cool tool that you made using pysmo.</li> </ul> <p>Contributing towards making pysmo better does not necessarily mean you need to submit code for inclusion in pysmo. However, if you do want to submit code, we ask that you read the information and follow steps outlined in the remaining sections on this page.</p>"},{"location":"developing/contributing/#development-workflow","title":"Development workflow","text":"<p>As mentioned in the previous chapter, development of pysmo happens on GitHub. Therefore, code submitted via a pull request has a much greater chance to be included in pysmo than e.g. sending a patch to us via email.</p> <p>Typically you would first fork pysmo and configure git to sync your fork with the upstream repository. Then you create a new feature branch where you add your code:</p> <pre><code>git checkout -b my_cool_feature\n</code></pre> <p>This feature branch is what you will also use to submit a pull request to pysmo when you are finished implementing your changes. Before submitting a pull request, please make sure you did the following:</p> <ul> <li>Write code that adheres to the PEP 8   style guide.</li> <li>Include unit tests with your submission. If you need help with that, feel   free to contact us.</li> <li>Run a code linter on your code and verify the unit tests all still pass.   Essentially this simply means <code>make tests</code> still   passes without errors.</li> <li>In order to keep a clean git history, please   rebase the pysmo master branch onto   your feature branch, and squash all commits into a single, well documented   commit. This avoids having commits such as \"fix typo\", or \"undo changes\"   finding their way into the git log. Note that this should only be done before   submitting the initial pull request.</li> </ul> <p>Once a pull request is submitted the following happens:</p> <ul> <li>The unit tests are executed automatically in clean Python environments via     GitHub Actions. Please verify all     tests still pass. If the tests pass on your development machine but fail in     the pull request, you may have e.g. forgotten to add a dependency to     <code>pyproject.toml</code> that you happened to already have installed on your     machine.</li> <li>Similarly, a build of the documentation from the code as it exists in the   pull request is also automatically triggered. Please follow the link that   appears in the pull request on GitHub and verify the documentation is as   expected.</li> <li>We will then review your submission, and hopefully be able to include it in   pysmo!</li> </ul>"},{"location":"developing/contributing/#what-should-be-included","title":"What should be included","text":"<p>A good contribution should contain code that is well written and documented, as well as provide meaningful test cases to ensure consistent and bug-free behaviour.</p> <p>A lot of the pysmo documentation is generated from the docstrings within the <code>.py</code> files. In many instances this means that a contribution may consist of only two files: the code itself and an associated test file.</p>"},{"location":"developing/developing/","title":"Development Environment","text":""},{"location":"developing/developing/#git-repository","title":"Git repository","text":"<p>We use GitHub for the development of pysmo. If you have never used git and/or GitHub we recommend you first have a look at their documentation. You can clone the pysmo repository two different ways:</p> <ol> <li>Clone the psymo repository directly to your desktop.</li> <li>Fork the repository on GitHub, and then clone it to your desktop (recommended    if you plan on submitting your changes to be included in pysmo).</li> </ol>"},{"location":"developing/developing/#clone-directly","title":"Clone directly","text":"<p>If you want to get started quickly, simply clone the pysmo git repository directly:</p> <pre><code>$ git clone https://github.com/pysmo/pysmo.github\nCloning into 'pysmo'...\n$ cd pysmo\n</code></pre> <p>That's it! Now skip ahead to project layout.</p>"},{"location":"developing/developing/#create-your-own-fork","title":"Create your own fork","text":"<p>Creating your own fork allows you to push your changes back to your fork on GitHub, which in turn makes submitting a pull request straightforward. Once you forked pysmo, you can clone your repository to your desktop:</p> <pre><code>$ git clone git@github.com:&lt;github-username&gt;/pysmo.git\nCloning into 'pysmo'...\n$ cd pysmo\n</code></pre> <p>Note</p> <p>We used ssh to clone the repository this time round. With an ssh-agent running, this will save you from having to constantly enter your credentials when pushing changes back to GitHub.</p> <p>In order to pull in changes in the upstream pysmo repository, we suggest adding it as an additional remote:</p> <pre><code>git remote add upstream https://github.com/pysmo/pysmo.git\n</code></pre>"},{"location":"developing/developing/#project-layout","title":"Project layout","text":"<p>Inside the pysmo folder you will find a relatively simple layout. The four most important items are:</p> <ol> <li><code>pysmo</code>: this directory is for the pysmo source code. There are <code>README.md</code>   files in all relevant sub-directories here to help you find your way around.</li> <li><code>docs</code>: anything to do with documentation happens here.</li> <li><code>tests</code>: we use this directory to hold unit tests.</li> <li><code>Makefile</code>: Most things can be managed with this makefile.</li> </ol> <p>Tip</p> <p>The psymo repository also contains files to create a development container, which performs the necessary setup tasks (all the steps below) for you automatically.</p>"},{"location":"developing/developing/#requirements","title":"Requirements","text":""},{"location":"developing/developing/#setting-up-windows","title":"Setting up Windows","text":"<p>To set up the development environment on Windows a few additional steps may be needed:</p> <ul> <li>Install Chocolatey, a package manager   for Windows which greatly simplifies installing additional dependencies   correctly.</li> <li>Once Chocolatey is installed, run the following commands (as administrator)   using either PowerShell or the Command Prompt to install the dependencies:</li> </ul> <pre><code>PS &gt; choco install make\nPS &gt; choco install awk\n</code></pre>"},{"location":"developing/developing/#uv","title":"uv","text":"<p>In order to develop pysmo in a consistent and isolated environment we use uv. Uv creates a Python virtual environment and manages the Python packages that are installed in that environment. This allows developing and testing while also having the stable version of pysmo installed at the same time.</p> <p>Note</p> <p>uv can also be used to install Python itself.</p>"},{"location":"developing/developing/#makefile","title":"Makefile","text":"<p>Pysmo provides a <code>Makefile</code> that helps with common tasks. Running the <code>make</code> command without arguments (or with <code>help</code>) will list available commands:</p> <pre><code>$ make help\n\nThis makefile executes mostly uv commands. To view all uv commands available\nrun 'uv help'.\n\nAVAILABLE COMMANDS\n  build                Build distribution.\n  check-uv             Check if uv is installed.\n  clean                Remove existing builds.\n  docs                 Build html docs.\n...\n</code></pre> <p>To get you started run</p> <pre><code>make sync\n</code></pre> <p>in a shell. This will first create a Python virtual environment for development of pysmo (unless the environment already already exists), then install pysmo and its dependencies.</p>"},{"location":"first-steps/","title":"Not so fast","text":"<p>Before starting your journey with pysmo, you should have a basic understanding of typing in the Python programming language. More precisely, you should know what type hinting is, and how it is used in conjunction with modern code editors (or other tools that check your code before it is executed).</p> <p>Tip</p> <p>Keep in mind that not only do programming languages themselves evolve, but also the tools used for writing code. Thus you get the most benefit out of pysmo when used together with a modern editor/IDE such as VSCode, PyCharm, Neovim, etc.</p>"},{"location":"first-steps/#dynamic-and-static-typing","title":"Dynamic and static typing","text":"<p>Python is a dynamically typed language. This means that the type (<code>float</code>, <code>str</code>, etc.) of a variable isn't set until you run code and assign a value to it. This is convenient, but can produce errors at runtime if you are not careful. This can be demonstrated with this simple function:</p> division.py<pre><code>def division(a, b):\n    return a / b\n</code></pre> <p>We load load this function into an interactive Python session and call it with the arguments <code>5</code> and <code>2</code>. Thus both variables <code>a=5</code> and <code>b=2</code> are numbers and we get the expected result:</p> <pre><code>$ python -i division.py\n&gt;&gt;&gt; division(5, 2)\n2.5 # (1)!\n&gt;&gt;&gt;\n</code></pre> <ol> <li> In Python, dividing two integers always creates a   float!</li> </ol> <p>In a second run they are set to <code>a=\"hello\"</code> and <code>b=\"world\"</code>. They are now strings, and the code doesn't make much sense anymore...</p> <pre><code>&gt;&gt;&gt; division(\"hello\", \"world\")\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"&lt;stdin&gt;\", line 2, in division\nTypeError: unsupported operand type(s) for /: 'str' and 'str'\n&gt;&gt;&gt;\n</code></pre> <p>Evidently the function only can be used if the variables <code>a</code> and <code>b</code> are numbers. To be clear, there is nothing wrong syntactically in this example, but certain operations are only available to the correct types (which is why a <code>TypeError</code> was raised at runtime). In order to detect these kinds of issues before running a program, Python allows adding type annotations to variables. This helps keep track of what types of input a function accepts, and what kind of output to expect:</p> division_annotated.py<pre><code>def division(a: float, b: float) -&gt; float:  # (1)!\n    return a / b\n\n\ndivision(\"a\", \"b\")  # &lt;- produces editor warning\ndivision(1, 2)  # &lt;- OK\n</code></pre> <ol> <li>Besides specifying that <code>a</code> and <code>b</code> are expected to be floats,     we are also making it clear that the object returned by the     function is also a float. This is important if the output of     the <code>division</code> function itself is used elsewhere.</li> </ol> <p>These annotations, also known as type hints, are not enforced (i.e. Python will still happily try running that function with strings as arguments). However, besides being a useful form of self-documentation, type hints become very powerful in combination with a modern source code editor, or third party tools like mypy. Both will scan code and catch type errors in your code before it is executed, making it sort of \"quasi statically typed\" (1).</p> <ol> <li> because you can run your code even with type errors!</li> </ol>"},{"location":"first-steps/#duck-typing","title":"Duck typing","text":"<p>At this point one may ask why static typing is not enforced everywhere. Well, sometimes it is more useful to consider how something behaves, rather than what it actually is. This is often referred to as duck typing. The same way that something can be considered a duck if it walks and talks like one, any object that has all the right attributes and methods expected e.g. by a function, can also be used as input for that function. The following example defines two classes for ducks and humans, and a function which runs error free when its argument is duck-like (it can quack and waddle, rather than strictly being of type <code>Duck</code>):</p> duck.py<pre><code>class Duck:  # (1)!\n    def quack(self):\n        return \"quack, quack!\"\n\n    def waddle(self):\n        return \"waddle, waddle!\"\n\n\nclass Human:  # (2)!\n    def quack(self):\n        return \"quack, quack!\"\n\n    def waddle(self):\n        return \"waddle, waddle!\"\n\n\ndef is_a_duck(thing):  # (3)!\n    try:\n        thing.quack()\n        thing.waddle()\n        print(\"I must be a duck!\")\n    except AttributeError:\n        print(\"I'm unable to walk and talk like a duck.\")\n</code></pre> <ol> <li> <p>The <code>duck</code> class has two methods: <code>quack</code> and <code>waddle</code>.</p> </li> <li> <p>A human can walk (<code>waddle</code>) and talk (<code>quack</code>) like a duck.</p> </li> <li> <p>This function, designed to answer the question of whether or not     a <code>thing</code> is a duck, actually doesn't really care if the <code>thing</code> is a     indeed a <code>duck</code> (or not). It merely requires the <code>thing</code> to be able to     talk and walk like one. It will determine that any <code>thing</code> that is     able to <code>quack</code> and <code>waddle</code> is a <code>duck</code>.</p> </li> </ol> <p>We then use this class in an interactive session, where the <code>is_a_duck</code> function tells us that <code>donald</code> (correctly) and <code>joe</code> (incorrectly) are both ducks:</p> <pre><code>$ python -i duck.py\n&gt;&gt;&gt; donald = Duck()  # (1)!\n&gt;&gt;&gt; joe = Human()  # (2)!\n&gt;&gt;&gt; is_a_duck(donald)\nI must be a duck!\n&gt;&gt;&gt; is_a_duck(joe)\nI must be a duck!\n&gt;&gt;&gt;\n</code></pre> <ol> <li>Create an instance of <code>Duck</code> called <code>donald</code>.</li> <li>Create an instance of <code>Human</code> called <code>joe</code>.</li> </ol> <p>The reason for this, is simply because the <code>is_a_duck</code> function doesn't check at all what it is given as input; as long as the <code>thing</code> object has the methods <code>quack</code> and <code>waddle</code> it will happily tell us something is a <code>duck</code>. Note that in some instances this is actually desired behavior.</p> Duck typing in the wild. <p>A real world example where duck typing is used in Python, is in the built-in <code>len()</code> function:</p> <pre><code>&gt;&gt;&gt; my_string = \"hello world\"\n&gt;&gt;&gt; len(my_string) # the len() function works with a string (1)!\n11\n&gt;&gt;&gt; my_list = [1, 2, 3]\n&gt;&gt;&gt; len(my_list) # and with a list (2)!\n3\n&gt;&gt;&gt; my_int = 42\n&gt;&gt;&gt; len(my_int) # but not with an integer (3)!\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: object of type 'int' has no len()\n&gt;&gt;&gt;\n</code></pre> <ol> <li> The <code>len()</code> function works with a string,     where it returns the number of characters in the string ...</li> <li> ... and with a list, where it ruturns the number     of items in the list.</li> <li> But not with an integer.</li> </ol> <p>Behind the scenes, <code>len()</code> doesn't look for valid input types, but rather if the object it is given as input possesses the <code>__len__()</code> attribute:</p> <pre><code>&gt;&gt;&gt; hasattr(my_string,'__len__')\nTrue\n&gt;&gt;&gt; hasattr(my_list,'__len__')\nTrue\n&gt;&gt;&gt; hasattr(my_int,'__len__')\nFalse\n&gt;&gt;&gt;\n</code></pre> <p>Note that we haven't annotated <code>is_a_duck()</code> with a type signature, making it quite fragile. If we were to change <code>Duck</code> or <code>Human</code> in ways that make them incompatible with the function we wouldn't find out until runtime. To fix this, we could annotate <code>is_a_duck()</code> like this:</p> <pre><code>def is_a_duck(thing: Duck | Human) -&gt; None: ...\n</code></pre> <p><code>is_a_duck()</code> now accepts only objects of type <code>Duck</code> or <code>Human</code>. This is now much safer to use, but it is also strongly coupled to both <code>Duck</code> and <code>Human</code>. If we were to change either of those classes, we might have to also change the function (or even the other class!). If we wanted to use a third class with this function some time in the future, we might find ourselves similarly forced to edit code all over the place to make things work. Using type hints like this to define a function that works with multiple different input types quickly reaches its limits. Fortunately, Python has a solution to this problem: <code>Protocol</code> classes.</p>"},{"location":"first-steps/#structural-subtyping-static-duck-typing","title":"Structural subtyping (static duck typing)","text":"<p>The two strategies (duck vs static typing) may appear somewhat orthogonal. In cases similar to the <code>len()</code> function they probably are, but what if we want duck typing with a bit more control? This is indeed possible with a strategy called structural subtyping. Revisiting the duck example from before, this time with with a new <code>Robot</code> class and structural subtyping:</p> duck_protocol.py<pre><code>from typing import Protocol  # (1)!\n\n\nclass Ducklike(Protocol):  # (2)!\n    def quack(self) -&gt; str: ...  # (3)!\n\n    def waddle(self) -&gt; str: ...\n\n\nclass Duck:  # (4)!\n    def quack(self) -&gt; str:\n        return \"quack, quack!\"\n\n    def waddle(self) -&gt; str:\n        return \"waddle, waddle!\"\n\n\nclass Human:  # (5)!\n    def quack(self) -&gt; str:\n        return \"quack, quack!\"\n\n    def waddle(self) -&gt; str:\n        return \"waddle, waddle!\"\n\n    def dance(self) -&gt; str:\n        return \"shaking those hips!\"\n\n\nclass Robot:  # (6)!\n    def quack(self) -&gt; bytes:\n        return bytes(\"beep, quack!\", \"UTF-8\")\n\n    def waddle(self) -&gt; str:\n        return \"waddle, waddle!\"\n\n\ndef is_a_duck(thing: Ducklike) -&gt; None:  # (7)!\n    try:\n        thing.quack()\n        thing.waddle()\n        print(\"I must be a duck!\")\n    except AttributeError:\n        print(\"I'm unable to walk and talk like a duck.\")\n</code></pre> <ol> <li>We import the <code>Protocol</code> class ...</li> <li>... and use it to define our <code>Ducklike</code> class. This protocol class defines a     structure (attributes and methods with their respective types) that can be     compared with structure present in any other class. If those classes have a     matching structure, they are considered subclasses (in terms of typing) of     the protocol class.</li> <li> Ellipses (<code>...</code>) are preferred over <code>pass</code> statements here.</li> <li>We add type hints to the otherwise unchanged Duck class. Because it has the     same structure as the <code>Ducklike</code> protocol class, it is implicitly considered     a subclass of <code>Ducklike</code>.</li> <li>The Human class is also a subclass of <code>Ducklike</code>, even though we added a new     dance method.</li> <li>An advanced robot can also walk and talk like a duck. However, it talks in     bytes instead of strings. This means the <code>Robot</code> class is not <code>Ducklike</code></li> <li>Unlike before, we only add annotations for one class     (the <code>Protocol</code> class) to the function. It is now not     coupled to any specific classes anymore. All we are saying is that the     function works with things that are <code>Ducklike</code> (i.e. the subclasses of     <code>Ducklike</code> - <code>Duck</code>, and <code>Human</code>, but not <code>Robot</code>).</li> </ol> <p>Loading this new version into an interactive Python session we get the following:</p> <pre><code>$ python -i duck_protocol.py\n&gt;&gt;&gt; donald = Duck()\n&gt;&gt;&gt; joe = Human()\n&gt;&gt;&gt; robert = Robot()\n&gt;&gt;&gt; like_a_duck(donald)\nI must be a duck!\nlike_a_duck(joe)\nI must be a duck!  # (1)!\nlike_a_duck(robert)\nI must be a duck!  # (2)!\n&gt;&gt;&gt;\n</code></pre> <ol> <li>As before, <code>donald</code> and <code>joe</code> appear to be <code>ducks</code>.</li> <li>Even this prints \"I must be a duck!\", but mypy or your IDE will     mark it as incompatible.</li> </ol> <p>The above example illustrates how <code>Protocol</code> classes are used, but doesn't explain why they are useful. With regards to pysmo, there are two important lessons to be learned here:</p> <ol> <li>The type annotations for the <code>like_a_duck()</code> function tell us it is    written with the base class <code>Ducklike</code> in mind instead of a particular    implementation of a <code>duck</code> class. This decoupling means we can write code    using a well defined and consistent interface.</li> <li>All attributes and methods in the <code>Protocol</code> class need    to be matched with the \"real\" classes, but not the other way around. The    <code>Duck</code> or <code>Human</code> classes may well contain methods like <code>fly</code>, <code>run</code>, <code>eat</code>,    <code>sleep</code>, etc. However, they can safely be ignored by <code>like_a_duck()</code>.</li> </ol> <p>In isolation the above two points may not appear that significant, but when we put them together the implications are quite substantial. The goal when writing code should always be to make it easy to understand and as reusable as possible, after all. Protocol classes help with exactly that. They are almost always going to be far less complex than a generic class(1). As such they allow breaking up a problem into smaller pieces, and write e.g. a function that works with a certain protocol rather than one particular class. The protocols define an interface a function can work with. It's as if a contract exists between a class and a function, whereby the class guarantees that the part they have a contract for is never going to change, regardless of what might happen elsewhere in the class. In pysmo, these contracts are the types we will discuss in greater detail later on.</p> <ol> <li>A generic class is a proper class, which holds data, has methods and    attributes etc (unlike a <code>Protocol</code> class, which only    contains the structure of a class).</li> </ol>"},{"location":"first-steps/#next-steps","title":"Next steps","text":"<ul> <li>Learn more about type hinting and how to check your code for type errors using  mypy.</li> <li>If you aren't already, consider switching to using a code editor that checks   your code (not just for typing errors) as you write it.</li> <li>Continue onwards to the next chapter and install pysmo!</li> </ul>"},{"location":"first-steps/installation/","title":"Installing pysmo","text":""},{"location":"first-steps/installation/#prerequisites","title":"Prerequisites","text":"<p>Pysmo is built on top of standard Python and uses some popular third party modules (e.g. <code>NumPy</code>, [<code>SciPy</code>][scipy]). In order to benefit from modern Python features and up to date modules, pysmo is developed on the latest stable Python versions. Automatic tests are done on version 3.12 and newer.</p> <p>Pysmo is available as a package from the Python Package Index. This means it can be easily installed using the <code>pip</code> module:</p> StablePre-releaseDevelopment Version <pre><code>$ python3 -m pip install pysmo\n</code></pre> <pre><code>$ python3 -m pip install pysmo --pre\n</code></pre> <pre><code>$ python3 -m pip install git+https://github.com/pysmo/pysmo\n</code></pre> <p>Hint</p> <p>It is possible to install the stable release alongside the development version. Please read the pysmo development documentation for instructions.</p>"},{"location":"first-steps/installation/#upgrading","title":"Upgrading","text":"<p>Upgrades to pysmo are also performed with the <code>pip</code> command:</p> <pre><code>python3 -m pip install -U pysmo\n</code></pre>"},{"location":"first-steps/installation/#uninstalling","title":"Uninstalling","text":"<p>To remove pysmo from the system run:</p> <pre><code>python3 -m pip uninstall pysmo\n</code></pre> <p>Warning</p> <p>Unfortunately <code>pip</code> currently does not remove dependencies that were automatically installed. We suggest running <code>pip list</code> to see the installed packages, which can then also be removed using <code>pip uninstall</code>.</p>"},{"location":"first-steps/tutorial/tutorial/","title":"Tutorial","text":"In\u00a0[1]: Copied! <pre>from pysmo.classes import SAC\n</pre> from pysmo.classes import SAC <p>then we use it to download a SAC file from IRIS and create a <code>SAC</code> instance named <code>sac</code>:</p> In\u00a0[2]: Copied! <pre>sac = SAC.from_iris(\n    net=\"IU\",\n    sta=\"ANMO\",\n    cha=\"LHZ\",\n    loc=\"00\",\n    start=\"2005-03-28T15:00:00\",\n    duration=3600 * 5,\n    scale=\"AUTO\",\n    demean=\"true\",\n    force_single_result=True,\n)\n</pre> sac = SAC.from_iris(     net=\"IU\",     sta=\"ANMO\",     cha=\"LHZ\",     loc=\"00\",     start=\"2005-03-28T15:00:00\",     duration=3600 * 5,     scale=\"AUTO\",     demean=\"true\",     force_single_result=True, ) <p>If you are familiar with the SAC file format, you will know that it has a lot of header variables for metadata. For example for the station and event coordinates:</p> In\u00a0[3]: Copied! <pre>def print_coords(sac):\n    print(f\"Station coordinates: {sac.stla}/{sac.stlo}\")\n    print(f\"Event coordinates: {sac.evla}/{sac.evlo}\")\n\n\nprint_coords(sac)\n</pre> def print_coords(sac):     print(f\"Station coordinates: {sac.stla}/{sac.stlo}\")     print(f\"Event coordinates: {sac.evla}/{sac.evlo}\")   print_coords(sac) <pre>Station coordinates: None/None\nEvent coordinates: None/None\n</pre> <p>Whoops! It appears our SAC file was missing values for these headers. This is not really surprising, as many of the SAC headers are optional fields. Let's fix this before proceeding:</p> In\u00a0[4]: Copied! <pre>sac.stla, sac.stlo = 34.9462, 106.4567\nsac.evla, sac.evlo = 2.09, -97.15\n\nprint_coords(sac)\n</pre> sac.stla, sac.stlo = 34.9462, 106.4567 sac.evla, sac.evlo = 2.09, -97.15  print_coords(sac) <pre>Station coordinates: 34.9462/106.4567\nEvent coordinates: 2.09/-97.15\n</pre> In\u00a0[5]: Copied! <pre># %load tutorial_seismogram.py\nfrom dataclasses import dataclass\nimport numpy as np\n\n\n@dataclass\nclass TutorialSeismogram:\n    event_latitude: float | None\n    event_longitude: float | None\n    station_latitude: float | None\n    station_longitude: float | None\n    delta: float\n    data: np.ndarray\n</pre> # %load tutorial_seismogram.py from dataclasses import dataclass import numpy as np   @dataclass class TutorialSeismogram:     event_latitude: float | None     event_longitude: float | None     station_latitude: float | None     station_longitude: float | None     delta: float     data: np.ndarray <p>Next we create an instance of this class using data from <code>sac</code>:</p> In\u00a0[6]: Copied! <pre>from copy import copy\n\ntseis = TutorialSeismogram(\n    event_latitude=sac.evla,\n    event_longitude=sac.evlo,\n    station_latitude=sac.stla,\n    station_longitude=sac.stlo,\n    delta=sac.delta,\n    data=copy(sac.data),\n)\n</pre> from copy import copy  tseis = TutorialSeismogram(     event_latitude=sac.evla,     event_longitude=sac.evlo,     station_latitude=sac.stla,     station_longitude=sac.stlo,     delta=sac.delta,     data=copy(sac.data), ) In\u00a0[7]: Copied! <pre># %load calc_gcd_from_seismogram.py\nfrom pyproj import Geod  # We will use the Geod class for the calculations\nfrom tutorial_seismogram import TutorialSeismogram\n\n\ndef calc_gcd_from_seismogram(seismogram: TutorialSeismogram) -&gt; float:\n    g = Geod(ellps=\"WGS84\")\n    # The g.inv method returns azimuth, back-azimuth and distance (in metres)\n    # We only need the distance here:\n    _, _, dist = g.inv(\n        lons1=seismogram.event_longitude,\n        lats1=seismogram.event_latitude,\n        lons2=seismogram.station_longitude,\n        lats2=seismogram.station_latitude,\n    )\n    return round(dist / 1000)\n</pre> # %load calc_gcd_from_seismogram.py from pyproj import Geod  # We will use the Geod class for the calculations from tutorial_seismogram import TutorialSeismogram   def calc_gcd_from_seismogram(seismogram: TutorialSeismogram) -&gt; float:     g = Geod(ellps=\"WGS84\")     # The g.inv method returns azimuth, back-azimuth and distance (in metres)     # We only need the distance here:     _, _, dist = g.inv(         lons1=seismogram.event_longitude,         lats1=seismogram.event_latitude,         lons2=seismogram.station_longitude,         lats2=seismogram.station_latitude,     )     return round(dist / 1000) <p>Before running the function with our <code>tsac</code> object, let's think about what we can infer from the first line of the function definition. Basically it reads: \"define a function called <code>calc_gcd_from_seismogram</code> that uses data in a variable called <code>seismogram</code> (which is of type <code>TutorialSeismogram</code>) and return a <code>float</code>. That is quite concise, but probably also sounds a bit strange - calculating a distance from a seismogram...? That is because in order to intuitively understand this function, a user needs to have intricate knowlege of the structure of the input object (<code>TutorialSeismogram</code>).</p> <p>Calling the function with our data we get:</p> In\u00a0[8]: Copied! <pre>distance = calc_gcd_from_seismogram(tseis)\nprint(f\"The great circle distance is {distance} km\")\n</pre> distance = calc_gcd_from_seismogram(tseis) print(f\"The great circle distance is {distance} km\") <pre>The great circle distance is 15229 km\n</pre> <p>Great, this worked! However, there are two problems with our implementation:</p> <ol> <li>Because the input type is a particular class (i.e. <code>TutorialSeismogram</code>) rather than a <code>Protocol</code> class, this function only works with that one input type.</li> <li>It will crash when any of the coordinates are <code>None</code> (you can test this by downloading the data again and running the function without adding the station and event coordinates first). Given that many of the headers in a SAC file are optional this is a likely scenario that we need to manage in our code.</li> </ol> In\u00a0[9]: Copied! <pre># %load calc_gcd_from_floats.py\nfrom pyproj import Geod\n\n\ndef calc_gcd_from_floats(\n    longitude_1: float, latitude_1: float, longitude_2: float, latitude_2: float\n) -&gt; float:\n    g = Geod(ellps=\"WGS84\")\n    _, _, dist = g.inv(\n        lons1=longitude_1, lats1=latitude_1, lons2=longitude_2, lats2=latitude_2\n    )\n    return round(dist / 1000)\n</pre> # %load calc_gcd_from_floats.py from pyproj import Geod   def calc_gcd_from_floats(     longitude_1: float, latitude_1: float, longitude_2: float, latitude_2: float ) -&gt; float:     g = Geod(ellps=\"WGS84\")     _, _, dist = g.inv(         lons1=longitude_1, lats1=latitude_1, lons2=longitude_2, lats2=latitude_2     )     return round(dist / 1000) <p>Which reads as: \"define a function called <code>calc_gcd_from_floats</code> that uses a variable called <code>longitude_1</code> (which is a <code>float</code>), a variable called <code>latitude_1</code> (which is a <code>float</code>), a variable called <code>longitude_2</code> (which is a <code>float</code>), a variable called <code>latitude_2</code> (which is a float), and return a <code>float</code>\". That is not only a bit awkward to read, but also less convenient to use:</p> In\u00a0[10]: Copied! <pre>distance = calc_gcd_from_floats(\n    tseis.event_longitude,\n    tseis.event_latitude,\n    tseis.station_longitude,\n    tseis.station_latitude,\n)\nprint(f\"The great circle distance is {distance} km\")\n</pre> distance = calc_gcd_from_floats(     tseis.event_longitude,     tseis.event_latitude,     tseis.station_longitude,     tseis.station_latitude, ) print(f\"The great circle distance is {distance} km\") <pre>The great circle distance is 15229 km\n</pre> <p>It will, however also work with <code>SAC</code> objects:</p> In\u00a0[11]: Copied! <pre>distance = calc_gcd_from_floats(sac.evlo, sac.evla, sac.stlo, sac.stla)\nprint(f\"The great circle distance is {distance} km\")\n</pre> distance = calc_gcd_from_floats(sac.evlo, sac.evla, sac.stlo, sac.stla) print(f\"The great circle distance is {distance} km\") <pre>The great circle distance is 15229 km\n</pre> In\u00a0[12]: Copied! <pre># %load calc_gcd_pysmo.py\nfrom pyproj import Geod\nfrom pysmo import Location\n\n\ndef calc_gcd(point1: Location, point2: Location) -&gt; float:\n    g = Geod(ellps=\"WGS84\")\n    _, _, dist = g.inv(\n        lons1=point1.longitude,\n        lats1=point1.latitude,\n        lons2=point2.longitude,\n        lats2=point2.latitude,\n    )\n    return round(dist / 1000)\n</pre> # %load calc_gcd_pysmo.py from pyproj import Geod from pysmo import Location   def calc_gcd(point1: Location, point2: Location) -&gt; float:     g = Geod(ellps=\"WGS84\")     _, _, dist = g.inv(         lons1=point1.longitude,         lats1=point1.latitude,         lons2=point2.longitude,         lats2=point2.latitude,     )     return round(dist / 1000) <p><code>Location</code> is a <code>Protocol</code> class that has just two attributes (which are both <code>floats</code>). We can list them like this:</p> In\u00a0[13]: Copied! <pre>Location.__protocol_attrs__\n</pre> Location.__protocol_attrs__ Out[13]: <pre>{'latitude', 'longitude'}</pre> <p>Neither of the two classes above have these attributes, and can therefore not be used as inputs for this function:</p> In\u00a0[14]: Copied! <pre>isinstance(tseis, Location), isinstance(sac, Location)\n</pre> isinstance(tseis, Location), isinstance(sac, Location) Out[14]: <pre>(False, False)</pre> <p>You have now reached an important point in this tutorial! It would appear that our nice function with pysmo types cannot be used with our data. Assuming you need to work with two types of seismogram objects (e.g. <code>SAC</code> and <code>TutorialSeismogram</code>) you have three options going forward:</p> <ol> <li>Write the same function two times for each class.</li> <li>Use only built-in types in your functions.</li> <li>Make your classes work with pysmo types.</li> </ol> <p>Given that the number of functions is almost always going to be far greater then the number of classes, (1) doesn't seem reasonable. (2) might seem okay at first, but consider that everytime you want to call a function you will have to write something like this:</p> <pre>if isinstance(seismogram, SAC):\n    distance = calc_gcd_from_floats(\n    sac_seis.evlo, sac_seis.evla, sac_seis.stlo, sac_seis.stla\n    )\nelif isinstance(seismogram, TutorialSeismogram):\n    distance = calc_gcd_from_floats(\n    seismogram.event_longitude,\n    seismogram.event_latitude,\n    seismogram.station_longitude,\n    seismogram.station_latitude,\n    )\n</pre> <p>This too is a lot of work, and it will only get worse if more classes need to be added sometime in the future. Moreover, if at any point one of the classes changes (e.g. the names of SAC headers change - though that is probably unlikely to actually happen...), you will have to adjust your code accordingly. Conversely, a <code>Location</code> type with only two attributes, <code>latitude</code> and <code>longitude</code>, is pretty much guaranteed to never change (something to consider even if you are only working with one type).</p> <p>This leaves the last option - make your classes work with pysmo types. There may be different ways of achieving this, but for this tutorial we show how to modify existing classes to make them work with pysmo types directly.</p> In\u00a0[15]: Copied! <pre># %load tutorial_seismogram_pysmo.py\nfrom dataclasses import dataclass, field\nfrom tutorial_seismogram import TutorialSeismogram\n\n\n@dataclass\nclass TutorialStation:\n    parent: TutorialSeismogram\n\n    @property\n    def latitude(self) -&gt; float:\n        if self.parent.station_latitude is None:\n            raise ValueError(\"parent value may not be None\")\n        return self.parent.station_latitude\n\n    @latitude.setter\n    def latitude(self, value: float):\n        self.parent.station_latitude = value\n\n    @property\n    def longitude(self) -&gt; float:\n        if self.parent.station_longitude is None:\n            raise ValueError(\"parent value may not be None\")\n        return self.parent.station_longitude\n\n    @longitude.setter\n    def longitude(self, value: float):\n        self.parent.station_longitude = value\n\n\n@dataclass\nclass TutorialEvent:\n    parent: TutorialSeismogram\n\n    @property\n    def latitude(self) -&gt; float:\n        if self.parent.event_latitude is None:\n            raise ValueError(\"parent value may not be None\")\n        return self.parent.event_latitude\n\n    @latitude.setter\n    def latitude(self, value: float):\n        self.parent.event_latitude = value\n\n    @property\n    def longitude(self) -&gt; float:\n        if self.parent.event_longitude is None:\n            raise ValueError(\"parent value may not be None\")\n        return self.parent.event_longitude\n\n    @longitude.setter\n    def longitude(self, value: float):\n        self.parent.event_longitude = value\n\n\n@dataclass\nclass TutorialSeismogramPysmo(TutorialSeismogram):\n    station: TutorialStation = field(init=False)\n    event: TutorialEvent = field(init=False)\n\n    def __post_init__(self) -&gt; None:\n        self.station = TutorialStation(parent=self)\n        self.event = TutorialEvent(parent=self)\n</pre> # %load tutorial_seismogram_pysmo.py from dataclasses import dataclass, field from tutorial_seismogram import TutorialSeismogram   @dataclass class TutorialStation:     parent: TutorialSeismogram      @property     def latitude(self) -&gt; float:         if self.parent.station_latitude is None:             raise ValueError(\"parent value may not be None\")         return self.parent.station_latitude      @latitude.setter     def latitude(self, value: float):         self.parent.station_latitude = value      @property     def longitude(self) -&gt; float:         if self.parent.station_longitude is None:             raise ValueError(\"parent value may not be None\")         return self.parent.station_longitude      @longitude.setter     def longitude(self, value: float):         self.parent.station_longitude = value   @dataclass class TutorialEvent:     parent: TutorialSeismogram      @property     def latitude(self) -&gt; float:         if self.parent.event_latitude is None:             raise ValueError(\"parent value may not be None\")         return self.parent.event_latitude      @latitude.setter     def latitude(self, value: float):         self.parent.event_latitude = value      @property     def longitude(self) -&gt; float:         if self.parent.event_longitude is None:             raise ValueError(\"parent value may not be None\")         return self.parent.event_longitude      @longitude.setter     def longitude(self, value: float):         self.parent.event_longitude = value   @dataclass class TutorialSeismogramPysmo(TutorialSeismogram):     station: TutorialStation = field(init=False)     event: TutorialEvent = field(init=False)      def __post_init__(self) -&gt; None:         self.station = TutorialStation(parent=self)         self.event = TutorialEvent(parent=self) <p>This is a bit of effort upfront, but consider that you only need to do this once! As before we can create an instance of our class from the data in the sac object:</p> In\u00a0[16]: Copied! <pre>from copy import copy\n\ntseisp = TutorialSeismogramPysmo(\n    event_latitude=sac.evla,\n    event_longitude=sac.evlo,\n    station_latitude=sac.stla,\n    station_longitude=sac.stlo,\n    delta=sac.delta,\n    data=copy(sac.data),\n)\n</pre> from copy import copy  tseisp = TutorialSeismogramPysmo(     event_latitude=sac.evla,     event_longitude=sac.evlo,     station_latitude=sac.stla,     station_longitude=sac.stlo,     delta=sac.delta,     data=copy(sac.data), ) <p>And verify that e.g. <code>tseisp.event_latitude</code> is the same as <code>tseisp.event.latitude</code>:</p> In\u00a0[17]: Copied! <pre>tseisp.event_latitude == tseisp.event.latitude\n</pre> tseisp.event_latitude == tseisp.event.latitude Out[17]: <pre>True</pre> <p>This is still true after modifying an attribute:</p> In\u00a0[18]: Copied! <pre>tseisp.event.latitude = 12.34\ntseisp.event_latitude == tseisp.event.latitude\n</pre> tseisp.event.latitude = 12.34 tseisp.event_latitude == tseisp.event.latitude Out[18]: <pre>True</pre> <p>We can also verify that the helper classes match the <code>Location</code> type:</p> In\u00a0[19]: Copied! <pre>print(f\"tseisp.event matches Location type: {isinstance(tseisp.event, Location)}\")\nprint(f\"tseisp.station matches Location type: {isinstance(tseisp.station, Location)}\")\n</pre> print(f\"tseisp.event matches Location type: {isinstance(tseisp.event, Location)}\") print(f\"tseisp.station matches Location type: {isinstance(tseisp.station, Location)}\") <pre>tseisp.event matches Location type: True\ntseisp.station matches Location type: True\n</pre> <p>Finally, lets run the <code>calc_gcd()</code> function with the modified class:</p> In\u00a0[20]: Copied! <pre>distance = calc_gcd(tseisp.event, tseisp.station)\n\nprint(f\"The great circle distance is {distance} km\")\n</pre> distance = calc_gcd(tseisp.event, tseisp.station)  print(f\"The great circle distance is {distance} km\") <pre>The great circle distance is 14213 km\n</pre> <p>That seemed to work!</p> <p>Spoiler: the <code>SAC</code> class already has such helper classes...</p> In\u00a0[21]: Copied! <pre>distance = calc_gcd(sac.event, sac.station)\n\nprint(f\"The great circle distance is {distance} km\")\n</pre> distance = calc_gcd(sac.event, sac.station)  print(f\"The great circle distance is {distance} km\") <pre>The great circle distance is 15229 km\n</pre> <p>which also map other attributes:</p> In\u00a0[22]: Copied! <pre>sac.station.name\n</pre> sac.station.name Out[22]: <pre>'ANMO'</pre> In\u00a0[23]: Copied! <pre>from pysmo import Seismogram\n\nSeismogram.__protocol_attrs__\n</pre> from pysmo import Seismogram  Seismogram.__protocol_attrs__ Out[23]: <pre>{'__len__', 'begin_time', 'data', 'delta', 'end_time'}</pre> <p>And as before we can use the <code>SAC</code> class with this type via a nested helper class:</p> In\u00a0[24]: Copied! <pre>isinstance(sac.seismogram, Seismogram)\n</pre> isinstance(sac.seismogram, Seismogram) Out[24]: <pre>True</pre> <p>We can therefore explore the attribute values using the <code>sac</code> object. The <code>begin_time</code> is a point in time, that is roughly equivalent to the <code>B</code> header in a sac file:</p> In\u00a0[25]: Copied! <pre>sac.seismogram.begin_time\n</pre> sac.seismogram.begin_time Out[25]: <pre>datetime.datetime(2005, 3, 28, 15, 0, 0, 498100, tzinfo=datetime.timezone.utc)</pre> <p>However, unlike <code>B</code>...</p> In\u00a0[26]: Copied! <pre>sac.b\n</pre> sac.b Out[26]: <pre>9.999999747378752e-05</pre> <p>...it is not a relative time, but an absolute time that uses Python's <code>datetime</code> module. Similarly the sampling interval <code>delta</code> is a <code>timedelta</code> rather than a float:</p> In\u00a0[27]: Copied! <pre>sac.seismogram.delta\n</pre> sac.seismogram.delta Out[27]: <pre>datetime.timedelta(seconds=1)</pre> In\u00a0[28]: Copied! <pre>sac.delta\n</pre> sac.delta Out[28]: <pre>1.0</pre> <p>All time related variables in pysmo make use of the datetime module, as it greatly simplifies time calculations. For example, the time of the last sample in the seismogram can be calculated as:</p> In\u00a0[29]: Copied! <pre>sac.seismogram.begin_time + (len(sac.seismogram) - 1) * sac.seismogram.delta\n</pre> sac.seismogram.begin_time + (len(sac.seismogram) - 1) * sac.seismogram.delta Out[29]: <pre>datetime.datetime(2005, 3, 28, 19, 59, 59, 498100, tzinfo=datetime.timezone.utc)</pre> <p>This exact calculation is actually done to calculate the <code>end_time</code> attribute in the <code>SAC</code> class:</p> In\u00a0[30]: Copied! <pre>sac.seismogram.end_time\n</pre> sac.seismogram.end_time Out[30]: <pre>datetime.datetime(2005, 3, 28, 19, 59, 59, 498100, tzinfo=datetime.timezone.utc)</pre> <p>Because the <code>end_time</code> can be derived from other attributes already present in the class, it is a read-only property. If we try to change it we get an error:</p> In\u00a0[31]: Copied! <pre>from datetime import timedelta\n\ntry:\n    sac.seismogram.end_time += timedelta(seconds=10)\nexcept AttributeError as e:\n    print(f\"Error: {e}\")\n</pre> from datetime import timedelta  try:     sac.seismogram.end_time += timedelta(seconds=10) except AttributeError as e:     print(f\"Error: {e}\") <pre>Error: property 'end_time' of 'SacSeismogram' object has no setter\n</pre> <p>If it were writeable, changing the <code>end_time</code> would require updating either the <code>begin_time</code> or <code>delta</code> attribute (or both!). As there is no way of knowing how to do this, pysmo types never contain writetable attributes that can be derived by others.</p> In\u00a0[32]: Copied! <pre># %load plot_seismo_gcd.py\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom pysmo import Seismogram, Location\nfrom calc_gcd_pysmo import calc_gcd\n\n\ndef plot_seismo_gcd(seismogram: Seismogram, point1: Location, point2: Location) -&gt; None:\n    distance = calc_gcd(point1, point2)\n    t = np.array(\n        [seismogram.begin_time + seismogram.delta * i for i in range(len(seismogram))]\n    )\n    plt.plot(t, seismogram.data, \"g\")\n    plt.title(f\"Distance: {distance} km\")\n    plt.gcf().autofmt_xdate()\n</pre> # %load plot_seismo_gcd.py from matplotlib import pyplot as plt import numpy as np from pysmo import Seismogram, Location from calc_gcd_pysmo import calc_gcd   def plot_seismo_gcd(seismogram: Seismogram, point1: Location, point2: Location) -&gt; None:     distance = calc_gcd(point1, point2)     t = np.array(         [seismogram.begin_time + seismogram.delta * i for i in range(len(seismogram))]     )     plt.plot(t, seismogram.data, \"g\")     plt.title(f\"Distance: {distance} km\")     plt.gcf().autofmt_xdate() In\u00a0[33]: Copied! <pre>%matplotlib inline\nplot_seismo_gcd(sac.seismogram, sac.event, sac.station)\n</pre> %matplotlib inline plot_seismo_gcd(sac.seismogram, sac.event, sac.station) <p>As before we can run the function with other classes, or even mix them:</p> In\u00a0[34]: Copied! <pre>plot_seismo_gcd(sac.seismogram, tseisp.event, tseisp.station)\n</pre> plot_seismo_gcd(sac.seismogram, tseisp.event, tseisp.station) In\u00a0[35]: Copied! <pre>from pysmo import MiniLocation\n\nmini_location = MiniLocation(latitude=12, longitude=34)\nprint(\n    f\"{mini_location=} is an instance of Location: {isinstance(mini_location, Location)}\"\n)\n</pre> from pysmo import MiniLocation  mini_location = MiniLocation(latitude=12, longitude=34) print(     f\"{mini_location=} is an instance of Location: {isinstance(mini_location, Location)}\" ) <pre>mini_location=MiniLocation(latitude=12, longitude=34) is an instance of Location: True\n</pre> <p>The <code>MiniSeismogram</code> class has defaults, so an instance can be created without providing attribute values:</p> In\u00a0[36]: Copied! <pre>from pysmo import MiniSeismogram\n\nmini_seismogram = MiniSeismogram()\nprint(\n    f\"{mini_seismogram=} is an instance of Seismogram: {isinstance(mini_seismogram, Seismogram)}\"\n)\n</pre> from pysmo import MiniSeismogram  mini_seismogram = MiniSeismogram() print(     f\"{mini_seismogram=} is an instance of Seismogram: {isinstance(mini_seismogram, Seismogram)}\" ) <pre>mini_seismogram=MiniSeismogram(begin_time=datetime.datetime(1970, 1, 1, 0, 0, tzinfo=datetime.timezone.utc), delta=datetime.timedelta(seconds=1), data=array([], dtype=float64)) is an instance of Seismogram: True\n</pre> <p>Note that the mini classes do not allow creating new attributes:</p> In\u00a0[37]: Copied! <pre>try:\n    mini_seismogram.custom_attribute = 123\nexcept AttributeError as e:\n    print(f\"AttributeError: {e}\")\n</pre> try:     mini_seismogram.custom_attribute = 123 except AttributeError as e:     print(f\"AttributeError: {e}\") <pre>AttributeError: 'MiniSeismogram' object has no attribute 'custom_attribute'\n</pre> In\u00a0[38]: Copied! <pre>from pysmo.functions import clone_to_mini\n\nmini_seismogram = clone_to_mini(MiniSeismogram, sac.seismogram)\nprint(\n    f\"{mini_seismogram=} is an instance of Seismogram: {isinstance(mini_seismogram, Seismogram)}\"\n)\n</pre> from pysmo.functions import clone_to_mini  mini_seismogram = clone_to_mini(MiniSeismogram, sac.seismogram) print(     f\"{mini_seismogram=} is an instance of Seismogram: {isinstance(mini_seismogram, Seismogram)}\" ) <pre>mini_seismogram=MiniSeismogram(begin_time=datetime.datetime(2005, 3, 28, 15, 0, 0, 498100, tzinfo=datetime.timezone.utc), delta=datetime.timedelta(seconds=1), data=array([2.41037213e-07, 2.12793083e-07, 1.08320187e-07, ...,\n       1.37353561e-06, 2.51878942e-06, 3.21547782e-06], shape=(18000,))) is an instance of Seismogram: True\n</pre> <p>After updating the attributes in the clone we can copy changes back too using <code>copy_from_mini()</code>:</p> In\u00a0[39]: Copied! <pre>from pysmo.functions import copy_from_mini\nfrom datetime import datetime, timezone\n\nmini_seismogram.begin_time = datetime.now(timezone.utc)\ncopy_from_mini(mini_seismogram, sac.seismogram)\nprint(f\"New begin_time: {sac.seismogram.begin_time=}\")\n</pre> from pysmo.functions import copy_from_mini from datetime import datetime, timezone  mini_seismogram.begin_time = datetime.now(timezone.utc) copy_from_mini(mini_seismogram, sac.seismogram) print(f\"New begin_time: {sac.seismogram.begin_time=}\") <pre>New begin_time: sac.seismogram.begin_time=datetime.datetime(2025, 4, 7, 16, 45, 46, 506303, tzinfo=datetime.timezone.utc)\n</pre>"},{"location":"first-steps/tutorial/tutorial/#tutorial","title":"Tutorial\u00b6","text":"<p>After reading the first section of the documentation you should have a basic understanding of three things:</p> <ul> <li>How type annotations in Python work.</li> <li>That defining a class also means you are defining a type.</li> <li>How defining types with <code>Protocol</code> classes allows annotating functions without coupling them to one or more normal classes.</li> </ul>"},{"location":"first-steps/tutorial/tutorial/#introduction-to-pysmo-types","title":"Introduction to pysmo types\u00b6","text":"<p>Pysmo makes use of <code>Protocol</code> classes not just to make functions and classes work together nicely, but especially also to define types that are relevant in seismologial processing. In this section we show you how to use pysmo types, and illustrate how it enables writing code that is easy to write (and read!), while at the same time also being highly reusable.</p>"},{"location":"first-steps/tutorial/tutorial/#getting-sac-data","title":"Getting SAC Data\u00b6","text":"<p>Let's begin by downloading a seismogram and storing it in a Python object. Pysmo has a class called <code>SAC</code>, which lets us use SAC files directly in Python. We first import the <code>SAC</code> class from pysmo:</p>"},{"location":"first-steps/tutorial/tutorial/#a-new-seismogram-class","title":"A new seismogram class\u00b6","text":"<p>Anyone not familiar with the SAC file format could easily be confused or overwhelmed by all the different SAC header fields. Working with a class with more descriptive attribute names is probably easier. A rudimentary class may look something like this:</p>"},{"location":"first-steps/tutorial/tutorial/#using-a-seismogram-in-a-function","title":"Using a seismogram in a function\u00b6","text":"<p>So far so good. Let's use our new object and use it to calculate something. As we now have event and station coordinates, we can use them to determine the great circle distance between them. To do so we write a function (complete with type hints):</p>"},{"location":"first-steps/tutorial/tutorial/#a-function-using-only-builtin-types","title":"A function using only builtin types\u00b6","text":"<p>Both of these problems can be addressed with a more general implementation using only the built-in <code>float</code>:</p>"},{"location":"first-steps/tutorial/tutorial/#a-happy-middle-ground","title":"A happy middle ground\u00b6","text":"<p>The two functions we used could be characterised as being on opposite ends of the spectrum: one function uses a single, somewhat complex object as input, while the other uses only the most fundamental types that are built into Python. Leaving aside any advantages or shortcomings of either approach and just focusing on the task at hand - calculating the distance between two points - we might find a function signature more like this to be easiest to read/understand:</p> <pre>def calc_gcd(point1: Location,\n             point2: Location,\n            ) -&gt; float: ...\n</pre> <p><code>Location</code> is indeed a type in pysmo, and we could implement the <code>gcd</code> function as follows:</p>"},{"location":"first-steps/tutorial/tutorial/#modifying-an-existing-class","title":"Modifying an existing class\u00b6","text":"<p>The problem we need to solve with our existing <code>TutorialSeismogram</code> class is really that two sets of coordinates need to be managed using the same name. In order to use e.g. <code>station_latitude</code> as <code>latitude</code> we need to map it in a way that doesn't interfere with <code>event_latitude</code>. We can do this with what one could call \"helper\" classes that themselves are attributes of the main class. We define one such class for station data and one for event data:</p>"},{"location":"first-steps/tutorial/tutorial/#summary","title":"Summary\u00b6","text":"<p>This example demonstrates how to write functions using pysmo types and what some advantages are:</p> <ul> <li>Pysmo types are simple and intuitive (e.g. the <code>Location</code> type only has two attributes, whereas the <code>SAC</code> class has over 100 (due to the large number of header fields specified in the file format.</li> <li>Because the types are so simple, values of <code>None</code> are typically not allowed in their attributes. A SAC file without event coordinates is still a valid SAC file, whereas a location with no latitude or longitude doesn't make sense.</li> <li>The simplicity of the types also results in the functions written with them being useful in more situations. We may have e.g. an <code>Airport</code> class we could use with the <code>calc_gcd()</code> function to calculate how far apart two airports are.</li> </ul> <p>In conclusion, we believe that a good class for storing data (where we may want to have as much metadata as possible), is not necessarily the best class to use inside functions (where we only use a small portion of the data stored in the class). The best way to overcome this chasm is to use (simple!) <code>Protocol</code> classes to annotate functions and ensure we use compatible classes as input.</p>"},{"location":"first-steps/tutorial/tutorial/#a-seismogram-in-pysmo","title":"A Seismogram in pysmo\u00b6","text":"<p>In the previous example we saw that pysmo types (e.g. <code>Location</code>) contain a very small number of attributes compared to a class like <code>SAC</code>. This essentially allows us to focus only on part of the data contained in a <code>SAC</code> object and ignore the rest. In a sense this means we don't distinguish between \"data\" and \"metadata - there is only the data that are currently being used by a pysmo type. An important such type is of course the seismogram.</p>"},{"location":"first-steps/tutorial/tutorial/#the-seismogram-type","title":"The Seismogram type\u00b6","text":"<p>Pysmo provides a <code>Seismogram</code> type which only has 5 attributes (though <code>__len__</code> actually has to be implemented as a method for the <code>len()</code> function):</p>"},{"location":"first-steps/tutorial/tutorial/#functions-with-multiple-input-types","title":"Functions with multiple input types\u00b6","text":"<p>As with the <code>Location</code> type above, using <code>Seismogram</code> restricts usage of the attributes of a <code>SAC</code> object to the ones that defined by the type. So if we want to use attributes that are in two seperate pysmo types, we need to use both types in our function:</p>"},{"location":"first-steps/tutorial/tutorial/#summary","title":"Summary\u00b6","text":"<p>The <code>Seismogram</code> type exemplifies the simplicity of pysmo types. It contains only four attributs and a <code>__len__</code> method (for the python <code>len()</code> function). What would typically be considered metadata in traditional seismograms (e.g. in Python classes or file formats) is not part of the type. While they may well be stored together, they are instead treated as their own distinct types during processing and therefore may need to be passed to functions seperately.</p>"},{"location":"first-steps/tutorial/tutorial/#mini-classes","title":"Mini Classes\u00b6","text":"<p>Using protocol classes to annotate functions allows for a lot of freedom when it comes to the class(es) used for storing data. Those classes may be specific to an application, file format, use a database backend, download data from the internet etc, and they will still work with pysmo types. For situations where such classes are too comprehensive or you want to potentially speed up performance, pysmo provides minimal implementations of compatible classes for each type - the pysmo \"mini\" classes. These classes:</p> <ul> <li>Have the same names as their respective types, but with a \"Mini\" prefix (e.g. the <code>Location</code> type has a <code>MiniLocation</code> class).</li> <li>Have exactly the same attributes as the types.</li> <li>Are, together with pysmo types, the only items in the base namespace (i.e. importable via <code>from pysmo import ...</code>).</li> </ul>"},{"location":"first-steps/tutorial/tutorial/#creating-a-new-mini-instance","title":"Creating a new Mini instance\u00b6","text":"<p>The Mini classes can be instantiated by simply passing the attribute values:</p>"},{"location":"first-steps/tutorial/tutorial/#creating-a-mini-clone","title":"Creating a Mini clone\u00b6","text":"<p>Another way to create Mini instances is to clone an existing object using the <code>clone_to_mini()</code> function. For example from the <code>sac</code> object we created right at the beginning:</p>"},{"location":"first-steps/tutorial/tutorial/#summary","title":"Summary\u00b6","text":"<p>In order for pysmo types to be useful, there needs to be at least one class that matches the type signature. Pysmo's mini classes do exactly this in a minimal fashion. As such they are useful in situations where no other suitable class is available, or if using them as clones instead of an existing (compatible) class provides benefits in processing speed. Because of their close relationship to a particular type they are imported from the pysmo base namespace.</p>"},{"location":"user-guide/","title":"Introduction","text":""},{"location":"user-guide/#how-to-use-this-documentation","title":"How to use this documentation","text":"<p>This section of the documentation is intended to give you a good overview of the principal concepts behind pysmo. It describes what pysmo is, why you may want to use it, and how to use it. If you are looking for specifics on a particular component of pysmo, please refer to the relevant section in the API reference.</p>"},{"location":"user-guide/#rationale","title":"Rationale","text":"<p>Anyone who has taken a course on programming (in any language) will most likely first have been taught about the different data types available. These typically consist of simple types like integers, floats, strings, as well as the more complicated arrays, dictionaries, etc. These types are typically very clearly defined and intuitive to use. For example, we don't need to think very hard whether or not it makes sense to pass the string \"hello world\" as input to a program that calculates the square root of numbers. That simply doesn't make much sense, and not just within a piece of code, but also when using pen and paper.</p> <p>As one moves from general-purpose programming towards more specialised problem solving (e.g. within a particular scientific field), the expected input (and output) for a piece of code is likely to become more complex. We may therefore quite easily reach a point where we no longer have that intuitive feeling about the data we are working with. In seismology this effect may be compounded by the fact that different file formats (and thus definitions) for seismograms exist.</p> <p>Pysmo aims to mitigate this by defining types that make sense for seismological problems the same way the built-in types make sense for general-purpose programming. This is implemented by differentiating between how data are stored, and how they are processed. As a matter of fact, the focus is pretty much exclusively on how they are processed. The two main reasons for this are:</p> <ul> <li>The vast majority of code we write deals with processing data, not storing.</li> <li>When we are processing data, we are typically thinking of data more in terms   of what they represent in the physical world. This is less so when storing   data, as we are then less interested in capturing only the essence of e.g.   a seismogram, but rather want to add as much useful metadata as possible,   combine different data sources into one large object, etc.</li> </ul>"},{"location":"user-guide/#a-software-contract","title":"A software contract","text":"<p>When we write software, we often need to pass information around between different parts of our code. To do this, the different parts need to be in an agreement about the type of data they are going to exchange. One could say that a contract exists that needs to be followed for our code to work properly. In Python we can use type hints to describe such a contract. In the simplest case, the information that is being exchanged consists of a built-in type such as a <code>float</code>:</p> <pre><code>def times_two(input_variable: float) -&gt; float:\n    \"\"\"Returns input variable multiplied by 2.\"\"\"\n\n    return input_variable * 2\n</code></pre> <p>The above function makes it quite clear what the contract for its usage is: it expects a <code>float</code> as as input, and it returns a <code>float</code> as output. If we try to call this function in other parts of our code using e.g. a <code>str</code> as input, our code editor will notify us that we made a mistake before we even run our program! The same is true for the function output - if we use the output as if it were a <code>str</code>, we would again get an error message from our code editor.</p> <p>Things get more challenging when the information passed around is not just a built-in type, but instead a piece of code itself. To illustrate this, lets imagine a hypothetical function that is used to sign up a new user for our service, and sends them an email for confirmation. The function does not itself send the email, but instead uses a 3rd party module passed as an argument to the function. Our code may look something like this:</p> signup.py<pre><code>from emailprovider import EmailProvider\n\n\ndef signup(username: str, email_address: str, emailer: EmailProvider) -&gt; None:\n    \"\"\"Send a welcome email to a new user using 3rd party email service.\"\"\"\n\n    formatted_message = f\"Hello {username}, welcome to the pysmo service!\"\n    emailer.send_email(email_address, formatted_message)\n</code></pre> <p>The contract here, again expressed using type hints (and by using the <code>send_email</code> method of the <code>EmailProvider</code> class...), is between our <code>signup</code> function and the 3rd party module. The contract is also quite specifically with this particular email service provider. This means our function is strongly coupled with this 3rd party module. An easy way to tell this would be to remove the first line from the above code - your code editor would straight away complain that <code>EmailProvider</code> is not defined. Should the email provider go out of business, or even just change their API (i.e. how their module works), our code would break. This is likely an easy fix if we use this email provider in just one place, but if we have multiple functions that make use of this module, they will all need to be refactored too. This would potentially be a lot of work, which can be avoided by writing the contract outside of the function(s). This contract would only need to be written once. If you remember the first-steps section, you'll likely guess that this way of defining the contract is by using <code>Protocol</code> classes:</p> signup2.py<pre><code>from typing import Protocol\n\n\nclass EmailSender(Protocol):\n    def send_email(self, email_address: str, message: str) -&gt; None: ...\n\n\ndef signup(username: str, email_address: str, emailer: EmailSender) -&gt; None:\n    \"\"\"Send a welcome email to a new user using 3rd party email service.\"\"\"\n\n    formatted_message = f\"Hello {username}, welcome to the pysmo service!\"\n    emailer.send_email(email_address, formatted_message)\n</code></pre> <p>Now there exists a contract between the <code>signup</code> function and the <code>EmailSender</code> class. Any third party email provider we might want to use will need to fulfill a contract with the <code>EmailSender</code> class instead of the <code>signup</code> function. Here, the <code>EmailSender</code> class doesn't do anything by itself. Instead it describes what a generic \"class that can send emails\" should look like in order to work with the <code>signup</code> function. The <code>EmailSender</code> class is only used by the type checker in your code editor, so it cannot be used in parts of the code that actually do things (i.e. you cannot create an instance of the <code>EmailSender</code> class). Instead you use a generic class that matches what <code>EmailSender</code> prescribes to actually perform the desired <code>send_email</code> action:</p> <pre><code>from emailprovider import EmailProvider #(1)!\nfrom emailprovider2 import EmailProvider2 #(2)!\nfrom signup import signup as signup1\nfrom signup2 import signup as signup2\n\nemailer1 = EmailProvider()\nemailer2 = EmailProvider2()\nnew_user = \"joe\"\nnew_user_email = \"joe@example.com\"\n\nsignup1(new_user, new_user_email, emailer1) #(3)!\nsignup1(new_user, new_user_email, emailer2) #(4)!\nsignup2(new_user, new_user_email, emailer1) #(5)!\nsignup2(new_user, new_user_email, emailer2) #(6)!\n</code></pre> <ol> <li>This is the email provider that is also used in <code>signup.py</code>.</li> <li>This is another 3rd party email provider. We assume it also has a    <code>send_email</code> method.</li> <li>Our type checker will be happy with this - all contracts are fulfilled.</li> <li>Type checker will complain - <code>signup1</code> expects <code>EmailProvider</code>, but got    <code>EmailProvider2</code>.</li> <li>Type checker is happy with this - <code>signup2</code> doesn't expect any particular    email provider class, but whichever one provided must have a <code>send_email</code>    method.</li> <li>Type checker is happy with this - <code>EmailProvider2</code> has a <code>send_email</code> method.</li> </ol> <p>To summarise, we can describe Python's typing system as contracts with the following two important properties:</p> <ul> <li>They are only used by type checkers that scan code rather than executing it.   They are ignored at runtime.</li> <li>We can define intermediary contracts with Protocol   classes. These serve as interfaces that describe how information is   exchanged (hence the name \"protocol\").</li> </ul> <p>Tip</p> <p>If you are still not sure what protocols are (or why they are so useful), consider how ubiquitous email is despite the existance of a myriad of alternatives for communicating in todays digital world. The likely reason for this success is interoperability: we can freely email each other using different work or private email addresses, and we can do so using various email clients or webmail. This is only possible because the way emails are sent and received is prescribed by protocols. These protocols define a common standard that allows using email everywhere, without needing to be concerned about things such as differences between the inner workings of different types of email servers.</p>"},{"location":"user-guide/#what-does-pysmo-do","title":"What does pysmo do?","text":"<p>What we haven't discussed so far is how Protocol classes allow us to be very specific about what we need (and also don't need) for our code to run. Consider the two email providers we used in the example above: perhaps <code>EmailProvider</code> can only send emails, while <code>EmailProvider2</code> also is able to receive emails using a <code>receive_email</code> method. However, as this method is not specified in our <code>EmailSender</code> class, we can safely ignore this difference and use both email providers interchangeably. Should we at some point in the future need to receive emails, we would just create a <code>EmailReceiver</code> protocol for that purpose. We would then have two smaller contracts with <code>EmailProvider2</code> instead of one big one.</p> <p>In seismology, a seismogram is typically a time series with some metadata attached to it. What these metadata are, often varies between different file types or use cases. Consider for example the SAC file format: it contains over 150 different header fields, of which only six are required (granted, some of those 150 are unused). This probably makes a lot of sense for storing data, or using SAC files with the SAC application. However, it also means we can never be certain about exactly what information is contained in a given SAC file. This is not dissimilar to the example with two different email providers. There, we dealt with it by defining ourselves what an email sender should look like.</p> <p>In pysmo we do exactly the same thing, but for types relevant to seismology. Pysmo forms the contract between areas where we want to add lots of detail to our data (e.g. when storing data, or within an application) and general-purpose processing of data where we typically don't care about metadata. For example, one of the most basic operations is applying a filter to a seismogram. Rather than writing an implementation for it over and over again for different types of seismograms, we can define a common interface for them and then use the same implementation all the time.</p> <p>At its core, pysmo is simply a set of contracts that allow writing code for a very simple and narrow definition of e.g. a seismogram, and then re-using that same code for a seismogram that is highly specific in its implementation.</p> <p>Tip</p> <p> Above we used the terms contract, type and protocol somewhat interchangeably. Hopefully it is clear that pieces of software don't actually sign contracts between them; we just used the term to express how they depend on each other and are thus coupled. That leaves us with types and (protocol) classes. Let's explore their relationship using the built-in float type as an example:</p> <pre><code>&gt;&gt;&gt; a = 1.2 #(1)!\n&gt;&gt;&gt; type(a) #(2)!\n&lt;class 'float'&gt;\n&gt;&gt;&gt; type(float) #(3)!\n&lt;class 'type'&gt;\n&gt;&gt;&gt;\n</code></pre> <ol> <li>We first assign a float to the variable <code>a</code>.</li> <li>Then we verify it is indeed a float using the <code>type</code> command.</li> <li>The type of the float class is...</li> </ol> <p>Remember, in Python everything is an object. So in the above snippet we created an object called <code>a</code> of the <code>float</code> class (objects are instances of a class). Where it gets interesting, is when we query what type our variable <code>a</code> is using the <code>type</code> command; instead of returning simply \"float\", the Python interpreter tells us the type of <code>a</code> is <code>&lt;class 'float'&gt;</code>. In other words, the <code>float</code> class is itself a type (which we verify in the last line). Simply put then, every time we define a class in Python, we also define a type.</p>"},{"location":"user-guide/#use-cases","title":"Use cases","text":"<p>There is actually no specific use case for psymo; the main purpose of pysmo is to serve as a library when writing new code, which means when and how to use pysmo is essentially up to you to decide. To help with this, pysmo has exactly two priorities:</p> <ol> <li>Focus on making the coding experience as intuitive and pleasant as possible    (proper typing, autocompletion, etc.).</li> <li>Ensure code can be easily reused.</li> </ol> <p>Priority (1) is probably fairly obvious. As for (2), consider for example two applications that store data in different ways internally (i.e. they define their own types), but share some common steps in their processing flows. If you ensure the application specific types match pysmo types, you only need to write the common steps once for both applications. If you've been using pysmo for a while already you may even find you unwittingly already wrote a function that does just what you need (or someone else may have written it)!</p> <p>Note</p> <p>If an application or framework that solves your problem already exists, there is little reason to use pysmo (though you might find it useful to use existing frameworks in combination with pysmo). Note also that from pysmo's perspective, there is little difference between an application and a framework - they both typically user their own particular structures for storing and processing data.</p>"},{"location":"user-guide/classes/","title":"Classes","text":"<p>The types discussed in the previous chapter are only useful in conjunction with compatible classes. The pysmo package contains classes that work with pysmo types (in the <code>pysmo</code> and <code>pysmo.classes</code> namespaces). Here we discuss how to write your own classes that work with pysmo types.</p>"},{"location":"user-guide/classes/#writing-compatible-classes","title":"Writing compatible classes","text":"<p>A class is is compatible with a particular type if all attributes and methods present in the type (defined by the respective protocol class) are also present in the class itself. For example, a <code>City</code> class may look something like this:</p> city.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass City:\n    name: str\n    founded: int\n    latitude: float\n    longitude: float\n    elevation: float\n</code></pre> <p>As the <code>City</code> class has <code>latitude</code> and <code>longitude</code> attributes, an instance of it is also an instance of the <code>Location</code> type:</p> python -i city.pyfrom pysmo import Locationnyc = City(name='New York', founded='1624', \\                latitude=40.7, longitude=-74, elevation=10)isinstance(nyc, Location)True <p>This example also illustrates that a class may contain additional attributes and methods that are not part of the type definition. In fact, a class may even match multiple types. Classes may therefore be essentially arbitrarily complex and still work with pysmo types as long as the necessary attributes are present.</p> <p>Warning</p> <p>In cases where a class contains additional attributes or methods, we strongly suggest to never access these in e.g. a function using pysmo types as input. For example, the code below will run if the <code>city</code> input is an instance of the <code>City</code> class (because it has the <code>name</code> attribute). However, the <code>name</code> attribute may not be present in another class that matches the <code>Location</code> type, resulting in a runtime error when this function is called.</p> <pre><code># Do not do this!\ndef print_coordinates(city: Location) -&gt; None:\n   print(f\"The coordinates of {city.name} are: {city.latitude}, {city.longitude}\")\n</code></pre>"},{"location":"user-guide/classes/#pysmo-mini-classes","title":"Pysmo Mini classes","text":"<p>The <code>City</code> example above illustrates how easy it is to write a class that is compatible with functions that expect pysmo types as input. However, this is not necessary if the data do not require a class with attributes that exceed pysmo types. For such cases the pysmo package includes \"Mini\" classes that correspond to each type (e.g. for the <code>Location</code> type there is a <code>MiniLocation</code> class).</p>"},{"location":"user-guide/classes/#using-pysmo-with-existing-classes","title":"Using pysmo with existing classes","text":"<p>Recall that pysmo types are aimed at the processing side of things, and not data storage. Consequently, pysmo is not centered around a \"native\" file format or Python class (and the Mini classes or not meant to be understood as such). The preferred approach is to use existing classes and modify them to work with pysmo instead.</p>"},{"location":"user-guide/classes/#anatomy-of-a-class","title":"Anatomy of a class","text":"<p>A typical third party module that reads data from files and uses its own specific class for both data storage and processing will likely look something like this:</p> <p> </p>      Relationship between Python objects and files storing data.    <p>Here, the Python class has many responsibilities; it needs to manage file input and output, data consistency (e.g. if changing one attribute means another one also needs to be changed), and process data via methods. The Python module may also contain functions that use instances of the class as inputs.</p> <p>These kinds of Python classes can be quite sophisticated, and often become the centrepieces of Python packages. As one might imagine, writing and maintaining these classes is a lot of work, and it does not make much sense to create yet another one for pysmo.</p>"},{"location":"user-guide/classes/#extending-an-existing-class","title":"Extending an existing class","text":"<p>In order to make use of these existing classes, we must ensure compatibility with the pysmo types. While some types may work out of the box with an existing class, it is usually necessary to modify the class to work with pysmo types. Crucially, this requires only a fraction of work compared to writing these kinds of classes from scratch.</p> <p> </p>      (a) An existing generic class may well contain the exact data that are used     as input for functions. However, as the functions expect those data to be     presented in a particular way (i.e. they need to match pysmo types), the     class is mostly incompatible. (b) After extending the generic class     (typically simply by mapping attributes in the class to attributes in the     type via aliases) it becomes compatible with more pysmo types, and thus can     be used for all the functions."},{"location":"user-guide/classes/#the-sac-classes","title":"The SAC classes","text":"<p>SAC (Seismic Analysis Code) is a commonly used program that uses its own file format. Pysmo was initially conceived as a small project to read and write SAC files using Python. This was done with the <code>SacIO</code> class, which is still part of the pysmo package. However, it is not compatible with pysmo types, and is therefore not intended to be used directly anymore. It now serves as base for the <code>SAC</code> class, which adds a compatibility layer that enables using pysmo types. We can therefore use the SAC classes as an example of how to adapt existing third party classes to work with pysmo types.</p>"},{"location":"user-guide/classes/#adding-attributes-to-the-sacio-class","title":"Adding attributes to the <code>SacIO</code> class","text":"<p>The <code>SacIO</code> class allows us to create objects from SAC files, which we can then access in Python:</p> read_sacfile.py<pre><code>from pysmo.lib.io import SacIO\n\nsac = SacIO.from_file(\"example.sac\")\n</code></pre> <p>After creating <code>SacIO</code> objects, SAC data and header fields can be accessed using the same names as used in the SAC file format (in lowercase). For example for the station location:</p> # Start an interactive python shell after executing read_sacfile.py:python -i read_sacfile.pyprint(f\"Station latitude: {sac.stla:.2f}\")Station latitude: -48.47print(f\"Station longitude: {sac.stlo:.2f}\")Station longitude: -72.56&gt;&gt;&gt; <p>These attributes have the correct format, but not the right name for the pysmo <code>Location</code> type:</p> python -i read_sacfile.pyfrom pysmo import Locationisinstance(sac, Location)False&gt;&gt;&gt; <p>What is needed is a way to access existing attributes via different names that correspond to the attributes expected by pysmo types. This can be done quite easily by creating a new class which inherits from the original one:</p> read_sacfile2.py<pre><code>from pysmo.lib.io import SacIO\n\n\nclass SacIO2(SacIO):\n    @property\n    def latitude(self) -&gt; float:\n        if self.stla is None:  # (1)!\n            raise ValueError(\"SAC Header STLA is not set\")\n        return self.stla\n\n    @latitude.setter\n    def latitude(self, value: float) -&gt; None:\n        self.stla = value\n\n    @property\n    def longitude(self) -&gt; float:\n        if self.stlo is None:\n            raise ValueError(\"SAC Header STLO is not set\")\n        return self.stlo\n\n    @longitude.setter\n    def longitude(self, value: float) -&gt; None:\n        self.stlo = value\n\n\nsac2 = SacIO2.from_file(\"example.sac\")\n</code></pre> <ol> <li><code>STLA</code> and <code>STLO</code> are optional header fields in a SAC file. However, the   <code>Location</code> type requires the   <code>latitude</code> and   <code>longitude</code> attributes to be <code>floats</code>   (i.e. they may not be of type <code>None</code>).</li> </ol> <p>Objects created from this new class can do everything the <code>SacIO</code> class can do, while also matching the <code>Location</code> type. Changing the mapped attributes will also change the original ones:</p> python -i read_sacfile2.pyfrom pysmo import Locationisinstance(sac2, Location)Truesac2.latitude = -12.3sac2.stla-12.3&gt;&gt;&gt; <p>With just a few lines of code we were able to make the <code>SacIO</code> class (itself over 1000 lines of code) compatible with the <code>Location</code> type. That said, creating new attributes directly and mapping them to existing ones may not always be possible for large classes like <code>SacIO</code>. For example, the event location is also stored in the headers of a SAC file, but we can't map it to the <code>latitude</code> and <code>longitude</code> attributes because they are already used for the station location. A more flexible approach is to map attributes into helper classes, which themselves are attributes in a new class.</p> <p>Tip</p> <p>In case you are asking yourself why you would want to go through this extra step of making a class work with pysmo types instead of writing functions that directly use the original class - consider that the number of functions will almost always be much greater than the number of classes. You may well be using the same class with 200 different functions, and if that class were to change for some reason (or you decide to use a different one entirely), all 200 functions may need to be edited to accomadate the changes. Conversely, extending these classes to work with pysmo types means that in the event the original class changes, only the code that does the extending would need to be edited, while all 200 functions can stay the same.</p>"},{"location":"user-guide/classes/#sac-helper-classes","title":"SAC helper classes","text":"<p>Because SAC files have a large number of header fields, <code>SacIO</code> objects have the potential to match several different pysmo types (or the same type multiple times). For the actual implementation of the above principle in the <code>SAC</code> class packaged in pysmo, we therefore use helper classes to provide a clear way to distinguish between types and avoid mapped attributes clashing with each other. This is best illustrated with a simple example:</p> <pre><code>&gt;&gt;&gt; from pysmo import Seismogram, Station\n&gt;&gt;&gt; from pysmo.classes import SAC\n&gt;&gt;&gt; sac = SAC.from_file(\"example.sac\")\n&gt;&gt;&gt; isinstance(sac.seismogram, Seismogram) # (1)!\nTrue\n&gt;&gt;&gt; isinstance(sac.station, Station) # (2)!\nTrue\n&gt;&gt;&gt;\n</code></pre> <ol> <li><code>sac.seismogram</code> is an instance of   <code>SacSeismogram</code> and is therefore   compatible with the <code>Seismogram</code> type.</li> <li><code>sac.station</code> is an instance of   <code>SacStation</code> and is therefore compatible with   the <code>Station</code> type.</li> </ol>"},{"location":"user-guide/functions/","title":"Functions","text":""},{"location":"user-guide/functions/#functions","title":"Functions","text":"<p>At this point you have probably seen quite a few examples of functions that use pysmo types in this documentation. This chapter shows how to use pysmo types for the type hints in your functions.</p>"},{"location":"user-guide/functions/#pysmo-types-as-input","title":"Pysmo types as input","text":"<p>The simplest way of using pysmo types is in functions that only use them as inputs. In these instances we don't need to be concerned about differences between different compatible classes, as their \"journeys\" end here. For example, the following function takes any <code>Seismogram</code> compatible object as input, and always returns a <code>float</code> regardless of what is used as input (e.g. <code>MiniSeismogram</code>, <code>SacSeismogram</code>, or a custom class):</p> double_delta_float.py<pre><code>from pysmo import Seismogram\nfrom datetime import timedelta\n\n\ndef double_delta_float(seismogram: Seismogram) -&gt; timedelta:\n    \"\"\"Return double the sampling interval of a seismogram.\n\n    Parameters:\n        seismogram: Seismogram object.\n\n    Returns:\n        sampling interval multiplied by 2.\n    \"\"\"\n\n    return seismogram.delta * 2\n</code></pre> <p>Because the function output is always a <code>float</code>, we don't lose track of any typing information when the function output is used elsewhere (e.g. in a function that needs a <code>float</code> as input).</p> <p>Warning</p> <p>Be careful when changing attributes of the input class inside a function. Sometimes the attributes are objects that contain other objects (e.g. an <code>ndarray</code> containing <code>float</code> objects). In our example above, the <code>seismogram</code> we use as input shares the nested objects in the <code>data</code> attribute with the <code>seismogram</code> inside the function. Changing <code>seismgram.data</code> inside the function will therefore also change it outside too. This behavior is often desired, but you must be aware of when this occurs and when not.</p>"},{"location":"user-guide/functions/#mini-classes-as-output","title":"Mini classes as output","text":"<p>While it may be perfectly acceptable to use pysmo types as output, we often lose some typing information when doing so. If we modify the above function to use a <code>Seismogram</code> for both input and output, we end up not knowing what exactly was used as input:</p> double_delta.py<pre><code>from pysmo import Seismogram\nfrom pysmo.classes import SAC\nfrom pathlib import Path\nfrom copy import deepcopy\nfrom typing import reveal_type  # (1)!\n\n\ndef double_delta(seismogram: Seismogram) -&gt; Seismogram:\n    \"\"\"Double the sampling interval of a seismogram.\n\n    Parameters:\n        seismogram: Seismogram object.\n\n    Returns:\n        Seismogram with double the sampling interval of input seismogram.\n    \"\"\"\n\n    clone = deepcopy(seismogram)  # (2)!\n    clone.delta *= 2\n    return clone\n\n\nsacfile = Path(\"example.sac\")\nmy_seis_in = SAC.from_file(sacfile).seismogram\nmy_seis_out = double_delta(my_seis_in)\n\nreveal_type(my_seis_in)\nreveal_type(my_seis_out)\n</code></pre> <ol> <li><code>reveal_type</code> allows us to inspect the actual type of an object. It prints   type information at runtime (what it actually is) or when using mypy (what   can be inferred from type annotations).</li> <li> Deep copying objects can be expensive if they contain large nested   items.</li> </ol> <p>The highlighted lines in the code above produce the following output when the script is executed:</p> python double_delta.pyRuntime type is 'SacSeismogram'Runtime type is 'SacSeismogram' <p>This tells us that at runtime <code>my_seis_in</code> and <code>my_seis_out</code> are both of type <code>SacSeismogram</code>. Running mypy on the code, however, yields a different type for <code>my_seis_out</code>:</p> mypy double_delta.pydocs/snippets/double_delta.py:26: note: Revealed type is \"SacSeismogram\"docs/snippets/double_delta.py:27: note: Revealed type is \"Seismogram\"Success: no issues found in 1 source file <p>This discrepancy is due the fact that our function is annotated in a way that tells us any <code>Seismogram</code> is acceptable as input, and that a <code>Seismogram</code> is returned, but we don't know which type exactly that is going to be.</p> <p>Tip</p> <p>A modern editor may display type information without running mypy:</p> <p> </p> <p>This loss of information is often not a problem, but if you do intend to use the output of such a function for further processing, it might be better to be explicit about they type of output. Since all pysmo types have a corresponding Mini class, one strategy is to use those as output types:</p> double_delta_mini.py<pre><code>from pysmo import Seismogram, MiniSeismogram\nfrom pysmo.functions import clone_to_mini\n\n\ndef double_delta_mini(seismogram: Seismogram) -&gt; MiniSeismogram:\n    \"\"\"Double the sampling interval of a seismogram.\n\n    Parameters:\n        seismogram: Seismogram object.\n\n    Returns:\n        MiniSeismogram with double the sampling interval of input seismogram.\n    \"\"\"\n\n    clone = clone_to_mini(MiniSeismogram, seismogram)  # (1)!\n    clone.delta *= 2\n    return clone\n</code></pre> <ol> <li>Here we use the <code>clone_to_mini</code> function   to create a <code>MiniSeismogram</code> instances from other   <code>Seismogram</code> instances. It is typically faster than deep   copying because it only copies the attributes that are actually used.</li> </ol>"},{"location":"user-guide/functions/#type-preservation","title":"Type preservation","text":"<p>Another option to be explicit about the output type of a function is to declare that the input type has to be the same as the output type. For pysmo types this requires two things:</p> <ol> <li>We need to save the input type as variable which we can reference for the   output type.</li> <li>We need to place bounds on this variable so that it is limited to the   desired pysmo type(s).</li> </ol> <p>This typing strategy involves generics, and changes our function to the following:</p> double_delta_generic.py<pre><code>from pysmo import Seismogram\nfrom pysmo.classes import SAC\nfrom pathlib import Path\nfrom copy import deepcopy\nfrom typing import reveal_type\n\n\ndef double_delta_generic[T: Seismogram](seismogram: T) -&gt; T:  # (1)!\n    \"\"\"Double the sampling interval of a seismogram.\n\n    Parameters:\n        seismogram: Seismogram object.\n\n    Returns:\n        Seismogram with double the sampling interval of input seismogram.\n    \"\"\"\n\n    clone = deepcopy(seismogram)\n    clone.delta *= 2\n    return clone\n\n\nsacfile = Path(\"example.sac\")\nmy_seis_in = SAC.from_file(sacfile).seismogram\nmy_seis_out = double_delta_generic(my_seis_in)\n\nreveal_type(my_seis_in)\nreveal_type(my_seis_out)\n</code></pre> <ol> <li> This syntax is only valid for Python versions 3.12 and above.</li> </ol> <p>In our example <code>[T: Seismogram]</code> defines a type variable <code>T</code> that has to be a <code>Seismogram</code>. We then use <code>T</code> as before to annotate the function. This means that if we use it with e.g. a <code>MiniSeismogram</code> as input, <code>T</code> is set to <code>MiniSeismogram</code> and the function signature effectively becomes:</p> <pre><code>def double_delta_generic(seismogram: MiniSeismogram) -&gt; MiniSeismogram:\n  ...\n</code></pre> <p>Or if we use a <code>SacSeismogram</code>:</p> <pre><code>def double_delta_generic(seismogram: SacSeismogram) -&gt; SacSeismogram:\n  ...\n</code></pre> <p>which is also what we used for our example. Therefore, running <code>mypy</code> on <code>double_delta_generic.py</code> gives:</p> mypy double_delta_generic.pydouble_delta_generic.py:25: note: Revealed type is \"SacSeismogram\"double_delta_generic.py:26: note: Revealed type is \"SacSeismogram\"Success: no issues found in 1 source file <p>Crucially, because <code>T</code> has an upper bound (in this case <code>Seismogram</code>), we get all the usual benefits from type hints while coding (autocompletion, error checking, etc.).</p>"},{"location":"user-guide/in-the-box/","title":"What is in the Box?","text":""},{"location":"user-guide/in-the-box/#library-vs-framework","title":"Library vs. framework","text":"<p>Before getting into what is included in the pysmo package, we briefly want to discuss what we mean by \"library\" and \"framework\" within the context of pysmo (or even within software in general). We use the following definitions:</p> <ul> <li>Libraries serve as building blocks to solve more complex problems or   for building applications.</li> <li>Frameworks provide ready-made solutions to solve complex problems. A   framework may easily also be considered an application.</li> </ul> <p>Distinguishing between the two can be a bit tricky when it comes to using third party tools like pysmo. Often it is not only a question of what the respective authors intend their software to be, but also how you use it for your purposes. A helpful way of looking at this (and an important consideration for future proofing your code), is to ask yourself in which ways your code depends on the third party package you are using. By this we mean factors such as:</p> <ul> <li>Do you understand what a particular package does, or does it feel more like   a black box when you e.g. call a function from that package?</li> <li>Does the third party package play nicely with other packages or data formats?</li> <li>Can it easily be replaced by a similar package (or your own implementation)?</li> <li>Does using a particular package make it impossible to e.g. rewrite your   code in a different programming language?</li> </ul> <p>Often it boils down to a trade-off between convenience and transparency, and which side if it you find yourself on more. With that said, we consider the core of pysmo to be very much a library. Outside that core part, there are some extra bits that fall more on the framework side of things. To accommodate for that, pysmo organises things into different namespaces (as we show below).</p>"},{"location":"user-guide/in-the-box/#package-contents","title":"Package contents","text":"<p>At the heart of pysmo will always be the pysmo types which, according to the above definitions, constitute a library that you can use in your own code. As any code written using pysmo types will often be reusable, we also include such code for use in a more framework-like setting. In other words, you don't need to reinvent the wheel in order to use pysmo. Aside from the types you can find the following in the psymo package:</p> <ul> <li>Classes: used to store data in a way that conforms   with pysmo types, and can therefore be used as input for functions that   expect pysmo types. As there is a strong relationship with the pysmo types,   the pysmo package includes reference classes for each type. These reference   classes are minimal implementations of pysmo type compatible classes, and are   thus named with a <code>Mini</code> prefix   (e.g. <code>MiniSeismogram</code>). The <code>Mini</code> classes are in   the base (<code>pysmo</code>) namespace, while others are in   <code>pysmo.classes</code>).</li> <li>Functions: basic functions used to manipulate data that is   stored in the classes described above. They are imported from the   <code>pysmo.functions</code> namespace.</li> <li>Tools: provide the framework-like functionality described above.   This is for example grouping of functions belonging to a particular topic,   or providing more complex workflows (typically building on top of the   basic functions or other tools). In order to use a particular tool, you must   import it via <code>pysmo.tools.&lt;tool-name&gt;</code>.</li> </ul> <p>Package namespaces</p> <p>Package namespaces are a way to keep things organised and to avoid name collisions (which is why you should avoid using <code>import *</code> statements in Python). As for pysmo, the main reason for breaking things up into multiple namespaces is to make it easy to add new functionality to pysmo without the need to edit existing code. As a user this simply means you may need to occasionally use more than one <code>import</code> statement at the begining of your scripts.</p>"},{"location":"user-guide/types/","title":"Types","text":"<p>In the previous section we briefly mention that every time we define a class in Python, we also define a type. As these types may be structures containing other types (e.g. an array containing floats) they can be arbitrarily complex. We can therefore conveniently group any data into an object to store and process them(1). However, the best way to structure such an object for storage may often be at odds with the best way for processing. Thus, a Python type that is well suited for storing seismological data is sometimes not a good type for processing (and vice-versa). Pysmo avoids having to deal with this discrepancy by using different types for storing and processing data.</p> <ol> <li> Remember that objects are instances of a class.</li> </ol> <p>The types used for storing data are the generic classes you may be used to using, whereas the types used for processing data are protocol classes. This may sound a bit confusing at first, but it is a simple matter of understanding the following points:</p> <ol> <li>Protocol classes themselves do not provide any functionality, thus the   objects we pass as input to a function are indeed still instances of generic   classes.</li> <li>The purpose of protocol classes is to provide a mechanism to define   constraints on the generic classes.</li> <li>In order to use a generic class as input for a function that uses protocol   classes in its type hints, the generic class must be a subclass of of the   protocol class. You can therefore think of a protocol class as a sort of   placeholder, which is substituted by a generic class when code is executed.</li> </ol> <p>This chapter aims to explain the above points in greater detail, and to hopefully convince you that doing things this way is indeed a good idea!</p>"},{"location":"user-guide/types/#protocol-classes","title":"Protocol classes","text":"<p><code>Protocol</code> classes were introduced in Python 3.8, and are discussed in detail in PEP 544. In this section, we explain why and how they are used in pysmo.</p>"},{"location":"user-guide/types/#why-protocol-classes","title":"Why Protocol classes?","text":"<p>In natural sciences we often process data that exist in one form or another in the physical world. We are of the opinion that Python types used for these data should not just be an arbitrary and abstract thing, but rather something that captures the essence of the data we are working with as they exist in nature. Of course, there are always going to be some abstractions. These already occur at the \"pen and paper\" stage, where we initially formulise problems, define models parameters etc. Pysmo types are defined with this early stage in mind. This makes it a lot easier to go from defining a problem, to coming up with a strategy or algorithm, to finally writing computer code. How these types are implemented is largely irrelevant at this early stage. Protocol classes are precisely for this use case - defining a type without implementing it.</p>"},{"location":"user-guide/types/#how-they-work-as-pysmo-types","title":"How they work as pysmo types","text":"<p>Let's see how to use protocol classes in pysmo with some example code that calculates the great circle distance (gcd) between the location of a station and an event source in two different ways: the traditional way, and the pysmo way. For the traditional approach we use the same data class(1) for both storage and processing. For the pysmo approach, we also use that data class for storage, but use pysmo types for processing instead.</p> <ol> <li>In this discussion \"data classes\" simply refers to a class containing     (seismological) data, and not the Python dataclass.</li> </ol> <p>For our example we assume the data we want to process is stored in a sac file called <code>example.sac</code>. Such files can be read in pysmo using the <code>SAC</code> class. The following code shows what the traditional way might look like:</p> gcd_traditional.py<pre><code>from pysmo.classes import SAC\nfrom pyproj import Geod  # (1)!\n\n\ndef f_traditional(seismogram: SAC) -&gt; float:\n    \"\"\"Calculate the great circle distance between the event and station.\n\n    Parameters:\n        seismogram: SAC seismogram object.\n\n    Returns:\n        Distance between the points in metres using the WGS84 ellipsoid.\n    \"\"\"\n\n    station_latitude = seismogram.stla  # (2)!\n    station_longitude = seismogram.stlo\n    event_latitude = seismogram.evla\n    event_longitude = seismogram.evlo\n\n    if (\n        station_latitude is None  # (3)!\n        or station_longitude is None\n        or event_latitude is None\n        or event_longitude is None\n    ):\n        raise ValueError(\"One or more coordinates are None.\")\n\n    g = Geod(ellps=\"WGS84\")\n    _, _, distance = g.inv(  # (4)!\n        station_longitude, station_latitude, event_longitude, event_latitude\n    )\n    return distance\n\n\nsac = SAC.from_file(\"example.sac\")\ngcd = f_traditional(sac)\nprint(f\"The great circle distance is {gcd} metres.\")\n</code></pre> <ol> <li>For this example we use the pyproj module for the distance calculation.</li> <li>The <code>SAC</code> class gives us access to the header fields in   sac files using their respective names as attributes.</li> <li>Because the SAC variables for station and event coordinates are optional   headers in the sac file file format, we cannot assume they contain values.   Thus, we check they all contain valid data before continuing.</li> <li><code>g.inv()</code> returns azimuth, backazimuth, and distance. We use the single   underscore (<code>_</code>) variable to indicate we are not interested in azimuth and   backazimuth.</li> </ol> <p>There are two things to note about the code above:</p> <ol> <li>When we think of sac files, we consider station and event information to be   merely metadata for the included seismogram. Because of that there is an   apparent disconnect between the purpose of the function (calculating gcd -   an operation that requires coordinates) and the type of input variable.   Consequently the above code may be difficult to understand without solid   knowledge of the sac format.</li> <li>We must also deal with the idiosyncrasies of the sac file format. In this   instance with the fact that very few of the many header fields are mandatory.</li> </ol> <p>The same example code, but using pysmo types instead would look like this:</p> gcd_pysmo.py<pre><code>from pysmo import Location  # (1)!\nfrom pysmo.classes import SAC\nfrom pyproj import Geod\n\n\ndef f_pysmo(location_1: Location, location_2: Location) -&gt; float:\n    \"\"\"Calculate the great circle distance between two locations.\n\n    Parameters:\n        location_1: Location of the first point.\n        location_2: Location of the second point.\n\n    Returns:\n        Distance between the points in metres using the WGS84 ellipsoid.\n    \"\"\"\n\n    g = Geod(ellps=\"WGS84\")\n    _, _, distance = g.inv(\n        location_1.longitude,\n        location_1.latitude,\n        location_2.longitude,\n        location_2.latitude,\n    )\n    return distance\n\n\nsac = SAC.from_file(\"example.sac\")\nevent = sac.event  # (2)!\nstation = sac.station\ngcd = f_pysmo(event, station)\nprint(f\"The great circle distance is {gcd} metres.\")\n</code></pre> <ol> <li>One of the pysmo types is <code>Location</code>, which is a simple   protocol class with two attributes <code>latitude</code> and <code>longitude</code>. We use this   class for the type hints in our function.</li> <li> <p>The <code>SAC</code> class directly mirrors the structure of sac   files, and as such would not work with pysmo types without some additional   attributes to extend the functionality of the class. Two such attributes are   <code>event</code> and   <code>station</code>, which provide access to data stored in   a sac file in a way that does work with pysmo types. For the purposes of this   example, we can verify that these attributes are indeed subclasses (and thus   instances) of the desired pysmo types:</p> <pre><code>&gt;&gt;&gt; isinstance(seismogram.event, Location)\nTrue\n</code></pre> </li> </ol> <p>At a first glance the two scripts look quite similar. The function <code>f_pysmo</code> is simpler and more concise than <code>f_traditional</code>, but there is a bit of extra work involved before we call the function (the highlighted lines). Most importantly though, <code>f_pysmo</code> is a function that calculates the gcd from a much simpler and more meaningful input, which leads to the function as a whole being more intuitive and easier to understand.</p> <p>We can also illustrate the different ways the functions interact with <code>SAC</code> objects in the two scripts graphically (note that we ignore all header fields unrelated to station or event data in the figure):</p> <p> </p>      A simplified SAC object (shown in light green) contains within it station     data (light purple), event data (light yellow), and a seismogram (light     red). Instead of consuming the entire data class, pysmo functions (via     protocol classes) only use the information they actually need for a     calculation and ignore the rest. Here the Station and Event both match the     Location type (light blue), and can therefore be used as input for the     f<sub>pysmo</sub> function. The f<sub>traditional</sub> function was     specifically written for SAC objects, so naturally only accepts those as     input.    <p>Hopefully the above example convincingly demonstrates how pysmo types aid in writing and understanding code. Another benefit of using pysmo types is their stability; much like we can expect for something like a <code>float</code>, pysmo types are unlikely to ever need to change (because they are kept as simple as possible). This can't necessarily be guaranteed for something like the sac file format. If that happens, the structure of the <code>SAC</code> class may also need to change and <code>f_traditional</code> breaks:</p> <p> </p>      Because a different format is being used (represented by dark colours instead     of light), the function f<sub>traditional</sub> no longer is able to perform     the calculation. The pysmo function f<sub>pysmo</sub> still works, provided     the new station and event information format also still match the Location     protocol.    <p>Furthermore, working with pysmo types also opens up interesting ways of working with seismological data. We illustrate some below:</p> <p> </p>      Examples of how pysmo functions can be used in novel ways: (a) If a     function needs data that is not present in a file format, the file can be     used in combination with external data (e.g. stored in a database) to     perform the computation. (b) Using synthetic seismograms with pysmo     functions is straightforward, as there is no need to add all the extra     (meta)data to turn it into a particular file format for further use. (c)     Functions can directly use data from different file types in the same     function."},{"location":"user-guide/types/#editor-support","title":"Editor support","text":"<p>At this point is worth repeating that type hints in Python are not enforced at runtime. They are therefore most useful when used together with a modern editor capable of interpreting these type hints. Typically this happens in the form of autocomplete and error checking.</p>"},{"location":"user-guide/types/#autocomplete","title":"Autocomplete","text":"<p>Once installed, the pysmo types can be imported and used just like any class. We can, for example, use the <code>Seismogram</code> type to annotate a function. A modern editor is then able to tell us what attributes are available for a variable and speed up the coding process by offering autocomplete for the attributes:</p> <p> </p>"},{"location":"user-guide/types/#error-checking","title":"Error checking","text":"<p>Should we for some reason make coding errors such as trying to access a none-existing attribute, the editor will give us a warning:</p> <p> </p> <p>These kinds of warnings are not just for catching typos. They will also catch programming errors such as trying to set the value of <code>delta</code> to a string instead of a float.</p> <p>Tip</p> <p>Should your editor for some reason be unable to parse type hints, testing your code for typing errors can still be done with mypy by running:</p> <pre><code>$ python -m mypy mycode.py\n</code></pre>"},{"location":"user-guide/types/#rules-of-the-land","title":"Rules of the land","text":"<p>Wether you plan on only using pysmo types, or if you also want to write your own (in which case please consider submitting them for inclusion in the pysmo package), it is important to understand the rules used when they are declared.</p>"},{"location":"user-guide/types/#what-kind-of-data-should-be-part-of-a-type","title":"What kind of data should be part of a type?","text":"<p>In short, a pysmo type should represent something that can (for the most part) be independently measured or observed, rather than being derived from some other type of data. The aim of this rule is to prevent ambiguous relationships between class attributes leading to inconsistencies creeping into data. Occasionally  this means we need to decide which attributes are more important. For example, the <code>Seismogram</code> type has <code>begin_time</code> and <code>delta</code> attributes. Using these two together with the length of the seismogram (number of samples), we can calculate the end time of the seismogram. For convenience there is actually also a <code>end_time</code> attribute in the type, but it is read-only. Were it also writable, changing its value would require updating the <code>begin_time</code> or the <code>delta</code> attribute. There is no way to know which one to update (or even both?), and we might also introduce rounding errors.</p> <p>We must consider the same thing not just for type attributes, but also for the types themselves. In the example above we calculate the great circle distance (gcd) from two <code>Location</code> objects. There may be some ways to measure the gcd directly, but most likely it will be derived from coordinates. Therefore, gcd cannot be a pysmo type (or writable type attribute).</p>"},{"location":"user-guide/types/#units","title":"Units","text":"<p>All units should be SI units. Points in time should be <code>datetime</code> objects (in UTC), and time deltas <code>timedelta</code> objects.</p>"},{"location":"user-guide/types/#avoid-declaring-methods","title":"Avoid declaring methods","text":"<p>While protocol classes certainly allow for methods to be declared, they do not make much sense for how protocol classes are used in pysmo. A pysmo type should declare what a thing is, not what it can do.</p>"},{"location":"user-guide/types/#avoid-allowing-attributes-to-be-none","title":"Avoid allowing attributes to be <code>None</code>","text":"<p>In most cases, allowing attributes to be <code>None</code> means the types become meaningless. For example, a <code>Location</code> where coordinates are optional doesn't really make sense.</p>"},{"location":"user-guide/types/#reuse-existing-types","title":"Reuse existing types","text":"<p>As the protocols contain only the typing structure, pysmo types can quite easily inherit from each other. If a new type were to contain all attributes of an existing type, that existing type should be reused. This is used in e.g. the <code>Station</code> type - a station requires coordinates, and we therefore inherit the <code>Location</code> type in the class definition:</p> pysmo/_types/_station.py<pre><code>class Station(Location, Protocol):\n    \"\"\"Protocol class to define the `Station` type.\"\"\"\n\n    @property\n</code></pre> <p>Tip</p> <p>This strategy means <code>Station</code> objects are also instances of <code>Location</code>. We can therefore write more generic functions (e.g. a function that calcluates gcd not just for a specific type of seismogram object, but any two objects containing locations), while  simultaniously being very specific about type of input requried by the functions.</p>"},{"location":"user-guide/types/#specialised-types","title":"Specialised types","text":"<p>The basic types included in pysmo are not exclusively derived from whatever it is they represent in the physical world. Because they define the interface used for interoperability between different parts of code, they are also influenced by the requirements of the code itself (arguably this is what protocols are really all about).</p> <p>This is worth remembering when dealing with algorithms with very specific data requirements. One of the principles of pysmo is that e.g. a function should be asking for the exact type of data it needs, rather than having to deal with whatever the structure of the data provided is. For example, if we need a special type of <code>Seismogram</code> that also needs a plethora of extra attributes for processing, we should not have to pass those attributes as arguments to a function. Instead, we should create a new type that contains those attributes.</p> <p>This is why some of the components in the pysmo package (e.g. <code>pysmo.tools.iccs</code>) use their own types (<code>ICCSSeismogram</code>) rather than the basic pysmo types. Crucially, these types inherit from the basic pysmo types, and therefore can still be used the same way as e.g. a basic <code>Seismogram</code>.</p> <p>Tip</p> <p>These specialised types all have a corresponding mini class. Thus, if you are working with a class that matches e.g. the <code>Seismogram</code> type, but not the <code>ICCCSeismogram</code> type, you can create a <code>MiniICCSSeismogram</code> object using the <code>clone_to_mini()</code> function by adding the missing attributes via the <code>update</code> argument.</p>"}]}