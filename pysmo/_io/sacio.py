# WARNING: Do not edit this file!
# It is generated by running the script 'generate_sacio.py' using values from
# 'sacheader.yml' and the 'sacio-template.py.j2' file. These 3 files are found
# in the utils directory.
from pysmo.exc import SacHeaderUndefined
from pysmo.functions._location import _azdist as azdist
from pysmo._lib.defaults import SACIO_DEFAULTS
from typing import Any, Self
from attrs import define, field, validators, converters, Attribute
from attrs_strict import type_validator
from enum import Enum
import struct
import datetime
import io
import requests
import urllib.parse
import zipfile
import numpy as np
import numpy.typing as npt


class IFTYPE(Enum):
    time = 1
    rlim = 2
    amph = 3
    xy = 4


class IDEP(Enum):
    unkn = 5
    disp = 6
    vel = 7
    acc = 8
    volts = 50


class IZTYPE(Enum):
    unkn = 5
    b = 9
    day = 10
    o = 11
    a = 12
    t0 = 13
    t1 = 14
    t2 = 15
    t3 = 16
    t4 = 17
    t5 = 18
    t6 = 19
    t7 = 20
    t8 = 21
    t9 = 22


class IEVTYP(Enum):
    unkn = 5
    nucl = 37
    pren = 38
    postn = 39
    quake = 40
    preq = 41
    postq = 42
    chem = 43
    qb = 72
    qb1 = 73
    qb2 = 74
    qbx = 75
    qmt = 76
    eq = 77
    eq1 = 78
    eq2 = 79
    me = 80
    ex = 81
    nu = 82
    nc = 83
    o = 11
    l = 85
    r = 86
    t = 87
    u = 88
    other = 44


class IQUAL(Enum):
    good = 45
    glch = 46
    drop = 47
    lowsn = 48
    other = 44


class ISYNTH(Enum):
    rldta = 49


class IMAGTYP(Enum):
    mb = 52
    ms = 53
    ml = 54
    mw = 55
    md = 56
    mx = 57


class IMAGSRC(Enum):
    neic = 58
    pde = 61
    isc = 62
    reb = 63
    usgs = 64
    brk = 65
    caltech = 66
    llnl = 67
    evloc = 68
    jsop = 69
    user = 70
    unknown = 71


class IBODY(Enum):
    sun = 98
    mercury = 99
    venus = 100
    earth = 101
    moon = 102
    mars = 103


SAC_ENUMS_DICT = dict(
    iftype=IFTYPE,
    idep=IDEP,
    iztype=IZTYPE,
    ievtyp=IEVTYP,
    iqual=IQUAL,
    isynth=ISYNTH,
    imagtyp=IMAGTYP,
    imagsrc=IMAGSRC,
    ibody=IBODY,
)


@define(frozen=True)
class HeaderType:
    definition: str
    undefined: float | int | str | bool
    length: int
    format: str
    description: str | None = None


HEADER_TYPES = dict(
    f=HeaderType(definition="floating", undefined=-12345, length=4, format="f"),
    n=HeaderType(definition="integer", undefined=-12345, length=4, format="i"),
    i=HeaderType(definition="enumerated", undefined=-12345, length=4, format="i"),
    l=HeaderType(definition="logical", undefined=False, length=1, format="?"),
    k=HeaderType(definition="alphanumeric", undefined="-12345", length=8, format="8s"),
    d=HeaderType(definition="double", undefined=-12345, length=8, format="d"),
)


@define(frozen=True)
class Header:
    start: int
    length: int
    format: str
    type: str
    required: bool


SAC_HEADERS = dict(
    delta=Header(start=0, length=4, format="f", type="f", required=True),
    depmin=Header(start=4, length=4, format="f", type="f", required=False),
    depmax=Header(start=8, length=4, format="f", type="f", required=False),
    unused3=Header(start=12, length=4, format="f", type="f", required=False),
    odelta=Header(start=16, length=4, format="f", type="f", required=False),
    b=Header(start=20, length=4, format="f", type="f", required=True),
    e=Header(start=24, length=4, format="f", type="f", required=True),
    o=Header(start=28, length=4, format="f", type="f", required=False),
    a=Header(start=32, length=4, format="f", type="f", required=False),
    internal9=Header(start=36, length=4, format="f", type="f", required=False),
    t0=Header(start=40, length=4, format="f", type="f", required=False),
    t1=Header(start=44, length=4, format="f", type="f", required=False),
    t2=Header(start=48, length=4, format="f", type="f", required=False),
    t3=Header(start=52, length=4, format="f", type="f", required=False),
    t4=Header(start=56, length=4, format="f", type="f", required=False),
    t5=Header(start=60, length=4, format="f", type="f", required=False),
    t6=Header(start=64, length=4, format="f", type="f", required=False),
    t7=Header(start=68, length=4, format="f", type="f", required=False),
    t8=Header(start=72, length=4, format="f", type="f", required=False),
    t9=Header(start=76, length=4, format="f", type="f", required=False),
    f=Header(start=80, length=4, format="f", type="f", required=False),
    resp0=Header(start=84, length=4, format="f", type="f", required=False),
    resp1=Header(start=88, length=4, format="f", type="f", required=False),
    resp2=Header(start=92, length=4, format="f", type="f", required=False),
    resp3=Header(start=96, length=4, format="f", type="f", required=False),
    resp4=Header(start=100, length=4, format="f", type="f", required=False),
    resp5=Header(start=104, length=4, format="f", type="f", required=False),
    resp6=Header(start=108, length=4, format="f", type="f", required=False),
    resp7=Header(start=112, length=4, format="f", type="f", required=False),
    resp8=Header(start=116, length=4, format="f", type="f", required=False),
    resp9=Header(start=120, length=4, format="f", type="f", required=False),
    stla=Header(start=124, length=4, format="f", type="f", required=False),
    stlo=Header(start=128, length=4, format="f", type="f", required=False),
    stel=Header(start=132, length=4, format="f", type="f", required=False),
    stdp=Header(start=136, length=4, format="f", type="f", required=False),
    evla=Header(start=140, length=4, format="f", type="f", required=False),
    evlo=Header(start=144, length=4, format="f", type="f", required=False),
    evel=Header(start=148, length=4, format="f", type="f", required=False),
    evdp=Header(start=152, length=4, format="f", type="f", required=False),
    mag=Header(start=156, length=4, format="f", type="f", required=False),
    user0=Header(start=160, length=4, format="f", type="f", required=False),
    user1=Header(start=164, length=4, format="f", type="f", required=False),
    user2=Header(start=168, length=4, format="f", type="f", required=False),
    user3=Header(start=172, length=4, format="f", type="f", required=False),
    user4=Header(start=176, length=4, format="f", type="f", required=False),
    user5=Header(start=180, length=4, format="f", type="f", required=False),
    user6=Header(start=184, length=4, format="f", type="f", required=False),
    user7=Header(start=188, length=4, format="f", type="f", required=False),
    user8=Header(start=192, length=4, format="f", type="f", required=False),
    user9=Header(start=196, length=4, format="f", type="f", required=False),
    dist=Header(start=200, length=4, format="f", type="f", required=False),
    az=Header(start=204, length=4, format="f", type="f", required=False),
    baz=Header(start=208, length=4, format="f", type="f", required=False),
    gcarc=Header(start=212, length=4, format="f", type="f", required=False),
    internal54=Header(start=216, length=4, format="f", type="f", required=False),
    internal55=Header(start=220, length=4, format="f", type="f", required=False),
    depmen=Header(start=224, length=4, format="f", type="f", required=False),
    cmpaz=Header(start=228, length=4, format="f", type="f", required=False),
    cmpinc=Header(start=232, length=4, format="f", type="f", required=False),
    xminimum=Header(start=236, length=4, format="f", type="f", required=False),
    xmaximum=Header(start=240, length=4, format="f", type="f", required=False),
    yminimum=Header(start=244, length=4, format="f", type="f", required=False),
    ymaximum=Header(start=248, length=4, format="f", type="f", required=False),
    unused63=Header(start=254, length=4, format="f", type="f", required=False),
    unused64=Header(start=258, length=4, format="f", type="f", required=False),
    unused65=Header(start=262, length=4, format="f", type="f", required=False),
    unused66=Header(start=264, length=4, format="f", type="f", required=False),
    unused67=Header(start=268, length=4, format="f", type="f", required=False),
    unused68=Header(start=272, length=4, format="f", type="f", required=False),
    unused69=Header(start=276, length=4, format="f", type="f", required=False),
    nzyear=Header(start=280, length=4, format="i", type="n", required=False),
    nzjday=Header(start=284, length=4, format="i", type="n", required=False),
    nzhour=Header(start=288, length=4, format="i", type="n", required=False),
    nzmin=Header(start=292, length=4, format="i", type="n", required=False),
    nzsec=Header(start=296, length=4, format="i", type="n", required=False),
    nzmsec=Header(start=300, length=4, format="i", type="n", required=False),
    nvhdr=Header(start=304, length=4, format="i", type="n", required=False),
    norid=Header(start=308, length=4, format="i", type="n", required=False),
    nevid=Header(start=312, length=4, format="i", type="n", required=False),
    npts=Header(start=316, length=4, format="i", type="n", required=True),
    internal80=Header(start=320, length=4, format="i", type="n", required=False),
    nwfid=Header(start=324, length=4, format="i", type="n", required=False),
    nxsize=Header(start=328, length=4, format="i", type="n", required=False),
    nysize=Header(start=332, length=4, format="i", type="n", required=False),
    unused84=Header(start=336, length=4, format="i", type="n", required=False),
    iftype=Header(start=340, length=4, format="i", type="i", required=True),
    idep=Header(start=344, length=4, format="i", type="i", required=False),
    iztype=Header(start=348, length=4, format="i", type="i", required=False),
    unused88=Header(start=352, length=4, format="i", type="i", required=False),
    iinst=Header(start=356, length=4, format="i", type="i", required=False),
    istreg=Header(start=360, length=4, format="i", type="i", required=False),
    ievreg=Header(start=364, length=4, format="i", type="i", required=False),
    ievtyp=Header(start=368, length=4, format="i", type="i", required=False),
    iqual=Header(start=372, length=4, format="i", type="i", required=False),
    isynth=Header(start=376, length=4, format="i", type="i", required=False),
    imagtyp=Header(start=380, length=4, format="i", type="i", required=False),
    imagsrc=Header(start=384, length=4, format="i", type="i", required=False),
    ibody=Header(start=388, length=4, format="i", type="i", required=False),
    unused98=Header(start=392, length=4, format="i", type="i", required=False),
    unused99=Header(start=396, length=4, format="i", type="i", required=False),
    unused100=Header(start=400, length=4, format="i", type="i", required=False),
    unused101=Header(start=404, length=4, format="i", type="i", required=False),
    unused102=Header(start=408, length=4, format="i", type="i", required=False),
    unused103=Header(start=412, length=4, format="i", type="i", required=False),
    unused104=Header(start=416, length=4, format="i", type="i", required=False),
    leven=Header(start=420, length=1, format="?", type="l", required=True),
    lpspol=Header(start=424, length=1, format="?", type="l", required=False),
    lovrok=Header(start=428, length=1, format="?", type="l", required=False),
    lcalda=Header(start=432, length=1, format="?", type="l", required=False),
    unused109=Header(start=436, length=1, format="?", type="l", required=False),
    kstnm=Header(start=440, length=8, format="8s", type="k", required=False),
    kevnm=Header(start=448, length=16, format="16s", type="k", required=False),
    khole=Header(start=464, length=8, format="8s", type="k", required=False),
    ko=Header(start=472, length=8, format="8s", type="k", required=False),
    ka=Header(start=480, length=8, format="8s", type="k", required=False),
    kt0=Header(start=488, length=8, format="8s", type="k", required=False),
    kt1=Header(start=496, length=8, format="8s", type="k", required=False),
    kt2=Header(start=504, length=8, format="8s", type="k", required=False),
    kt3=Header(start=512, length=8, format="8s", type="k", required=False),
    kt4=Header(start=520, length=8, format="8s", type="k", required=False),
    kt5=Header(start=528, length=8, format="8s", type="k", required=False),
    kt6=Header(start=536, length=8, format="8s", type="k", required=False),
    kt7=Header(start=544, length=8, format="8s", type="k", required=False),
    kt8=Header(start=552, length=8, format="8s", type="k", required=False),
    kt9=Header(start=560, length=8, format="8s", type="k", required=False),
    kf=Header(start=568, length=8, format="8s", type="k", required=False),
    kuser0=Header(start=576, length=8, format="8s", type="k", required=False),
    kuser1=Header(start=584, length=8, format="8s", type="k", required=False),
    kuser2=Header(start=592, length=8, format="8s", type="k", required=False),
    kcmpnm=Header(start=600, length=8, format="8s", type="k", required=False),
    knetwk=Header(start=608, length=8, format="8s", type="k", required=False),
    kdatrd=Header(start=616, length=8, format="8s", type="k", required=False),
    kinst=Header(start=624, length=8, format="8s", type="k", required=False),
)


@define(frozen=True)
class Footer:
    start: int
    length: int = 8
    format: str = "f"
    type: str = "d"


SAC_FOOTERS = dict(
    delta=Footer(start=0),
    b=Footer(start=8),
    e=Footer(start=16),
    o=Footer(start=24),
    a=Footer(start=32),
    t0=Footer(start=40),
    t1=Footer(start=48),
    t2=Footer(start=56),
    t3=Footer(start=64),
    t4=Footer(start=72),
    t5=Footer(start=80),
    t6=Footer(start=88),
    t7=Footer(start=96),
    t8=Footer(start=104),
    t9=Footer(start=112),
    f=Footer(start=120),
    evlo=Footer(start=128),
    evla=Footer(start=136),
    stlo=Footer(start=144),
    stla=Footer(start=152),
    sb=Footer(start=160),
    sdelta=Footer(start=168),
)


def validate_sacenum(instance: "SacIO", attribute: Attribute, value: Any) -> None:
    if not hasattr(SAC_ENUMS_DICT[attribute.name], value):
        raise ValueError(
            f"{value=} is an invalid enum value for sac attribute {attribute.name}."
        )


@define(kw_only=True)
class SacIO:
    """
    The `SacIO` class reads and writes data and header values to and from a
    SAC file. Instances of `SacIO` provide attributes named identially to
    header names in the SAC file format. Additonal attributes may be set, but
    are not written to a SAC file (because there is no space reserved for them
    there). Class attributes with corresponding header fields in a SAC file
    (for example the begin time `b`) are checked for a valid format before
    being saved in the `SacIO` instance.

    Warning:
        This class should typically never be used directly. Instead please
        use the [SAC][pysmo.classes.SAC] class, which inherits all attributes
        and methods from here.

    Examples:
        Create a new instance from a file and print seismogram data:

        >>> from pysmo._io import SacIO
        >>> my_sac = SacIO.from_file('testfile.sac')
        >>> data = my_sac.data
        >>> data
        array([-1616.0, -1609.0, -1568.0, -1606.0, -1615.0, -1565.0, ...

        Read the sampling rate:

        >>> delta = my_sac.delta
        >>> delta
        0.019999999552965164

        Change the sampling rate:

        >>> newdelta = 0.05
        >>> my_sac.delta = newdelta
        >>> my_sac.delta
        0.05

        Create a new instance from IRIS services:

        >>> from pysmo._io import SacIO
        >>> my_sac = SacIO.from_iris(
        >>>             net="C1",
        >>>             sta="VA01",
        >>>             cha="BHZ",
        >>>             loc="--",
        >>>             start="2021-03-22T13:00:00",
        >>>             duration=1 * 60 * 60,
        >>>             scale="AUTO",
        >>>             demean="true",
        >>>             force_single_result=True)
        >>> my_sac.npts
        144001

    For each SAC(file) header field there is a corresponding attribute in this
    class. There are a lot of header fields in a SAC file, which are all called
    the same way when using `SAC`.

    Attributes:
        delta:
            Increment between evenly spaced samples (nominal value).
        depmin:
            Minimum value of dependent variable.
        depmax:
            Maximum value of dependent variable.
        odelta:
            Observed increment if different from nominal value.
        b:
            Beginning value of the independent variable.
        e:
            Ending value of the independent variable.
        o:
            Event origin time (seconds relative to reference time).
        a:
            First arrival time (seconds relative to reference time).
        t0:
            User defined time pick or marker 0 (seconds relative to reference
            time).
        t1:
            User defined time pick or marker 1 (seconds relative to reference
            time).
        t2:
            User defined time pick or marker 2 (seconds relative to reference
            time).
        t3:
            User defined time pick or marker 3 (seconds relative to reference
            time).
        t4:
            User defined time pick or marker 4 (seconds relative to reference
            time).
        t5:
            User defined time pick or marker 5 (seconds relative to reference
            time).
        t6:
            User defined time pick or marker 6 (seconds relative to reference
            time).
        t7:
            User defined time pick or marker 7 (seconds relative to reference
            time).
        t8:
            User defined time pick or marker 8 (seconds relative to reference
            time).
        t9:
            User defined time pick or marker 9 (seconds relative to reference
            time).
        f:
            Fini or end of event time (seconds relative to reference time).
        resp0:
            Instrument response parameter 0 (not currently used).
        resp1:
            Instrument response parameter 1 (not currently used).
        resp2:
            Instrument response parameter 2 (not currently used).
        resp3:
            Instrument response parameter 3 (not currently used).
        resp4:
            Instrument response parameter 4 (not currently used).
        resp5:
            Instrument response parameter 5 (not currently used).
        resp6:
            Instrument response parameter 6 (not currently used).
        resp7:
            Instrument response parameter 7 (not currently used).
        resp8:
            Instrument response parameter 8 (not currently used).
        resp9:
            Instrument response parameter 9 (not currently used).
        stla:
            Station latitude (degrees, north positive).
        stlo:
            Station longitude (degrees, east positive).
        stel:
            Station elevation above sea level (meters).
        stdp:
            Station depth below surface (meters).
        evla:
            Event latitude (degrees, north positive).
        evlo:
            Event longitude (degrees, east positive).
        evel:
            Event elevation (meters).
        evdp:
            Event depth below surface (kilometers -- previously meters).
        mag:
            Event magnitude.
        user0:
            User defined variable storage area.
        user1:
            User defined variable storage area.
        user2:
            User defined variable storage area.
        user3:
            User defined variable storage area.
        user4:
            User defined variable storage area.
        user5:
            User defined variable storage area.
        user6:
            User defined variable storage area.
        user7:
            User defined variable storage area.
        user8:
            User defined variable storage area.
        user9:
            User defined variable storage area.
        dist:
            Station to event distance (km).
        az:
            Event to station azimuth (degrees).
        baz:
            Station to event azimuth (degrees).
        gcarc:
            Station to event great circle arc length (degrees).
        depmen:
            Mean value of dependent variable.
        cmpaz:
            Component azimuth (degrees clockwise from north).
        cmpinc:
            Component incident angle (degrees from upward vertical; SEED/MINISEED
            uses dip: degrees from horizontal down).
        xminimum:
            Minimum value of X (Spectral files only).
        xmaximum:
            Maximum value of X (Spectral files only).
        yminimum:
            Minimum value of Y (Spectral files only).
        ymaximum:
            Maximum value of Y (Spectral files only).
        nzyear:
            GMT year corresponding to reference (zero) time in file.
        nzjday:
            GMT julian day.
        nzhour:
            GMT hour.
        nzmin:
            GMT minute.
        nzsec:
            GMT second.
        nzmsec:
            GMT millisecond.
        nvhdr:
            Header version number.
        norid:
            Origin ID (CSS 3.0).
        nevid:
            Event ID (CSS 3.0).
        npts:
            Number of points per data component.
        nwfid:
            Waveform ID (CSS 3.0).
        nxsize:
            Spectral Length (Spectral files only).
        nysize:
            Spectral Length (Spectral files only).
        iftype:
            Type of file.
        idep:
            Type of dependent variable.
        iztype:
            Reference time equivalence.
        iinst:
            Type of recording instrument.
        istreg:
            Station geographic region.
        ievreg:
            Event geographic region.
        ievtyp:
            Type of event.
        iqual:
            Quality of data.
        isynth:
            Synthetic data flag.
        imagtyp:
            Magnitude type.
        imagsrc:
            Source of magnitude information.
        ibody:
            Body / Spheroid definition used in Distance Calculations.
        leven:
            TRUE if data is evenly spaced.
        lpspol:
            TRUE if station components have a positive polarity (left-hand rule).
        lovrok:
            TRUE if it is okay to overwrite this file on disk.
        lcalda:
            TRUE if DIST, AZ, BAZ, and GCARC are to be calculated from station and
            event coordinates.
        kstnm:
            Station name.
        kevnm:
            Event name.
        khole:
            Nuclear: hole identifier; Other: location identifier (LOCID).
        ko:
            Event origin time identification.
        ka:
            First arrival time identification.
        kt0:
            User defined time pick identification.
        kt1:
            User defined time pick identification.
        kt2:
            User defined time pick identification.
        kt3:
            User defined time pick identification.
        kt4:
            User defined time pick identification.
        kt5:
            User defined time pick identification.
        kt6:
            User defined time pick identification.
        kt7:
            User defined time pick identification.
        kt8:
            User defined time pick identification.
        kt9:
            User defined time pick identification.
        kf:
            Fini identification.
        kuser0:
            User defined variable storage area.
        kuser1:
            User defined variable storage area.
        kuser2:
            User defined variable storage area.
        kcmpnm:
            Channel name. SEED volumes use three character names, and the third is
            the component/orientation. For horizontals, the current trend is to
            use 1 and 2 instead of N and E.
        knetwk:
            Name of seismic network.
        kdatrd:
            Date data was read onto computer.
        kinst:
            Generic name of recording instrument.
    """

    delta: float = field(
        default=SACIO_DEFAULTS.delta, converter=float, validator=[type_validator()]
    )
    odelta: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    b: float = field(
        default=SACIO_DEFAULTS.b, converter=float, validator=[type_validator()]
    )
    o: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    a: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t0: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t1: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t2: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t3: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t4: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t5: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    f: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp0: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp1: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp2: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp3: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp4: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp5: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    stla: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.ge(-90), validators.le(90)]
        ),
    )
    stlo: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.gt(-180), validators.le(180)]
        ),
    )
    stel: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    stdp: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    evla: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.ge(-90), validators.le(90)]
        ),
    )
    evlo: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.gt(-180), validators.le(180)]
        ),
    )
    evel: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    evdp: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    mag: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user0: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user1: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user2: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user3: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user4: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user5: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    cmpaz: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    cmpinc: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    nzyear: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzjday: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzhour: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzmin: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzsec: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzmsec: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nvhdr: int = field(default=SACIO_DEFAULTS.nvhdr, validator=[type_validator()])
    norid: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nevid: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nwfid: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    iftype: str = field(default=SACIO_DEFAULTS.iftype, validator=validate_sacenum)
    idep: str = field(default=SACIO_DEFAULTS.idep, validator=validate_sacenum)
    iztype: str = field(default=SACIO_DEFAULTS.iztype, validator=validate_sacenum)
    iinst: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    istreg: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    ievreg: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    ievtyp: str = field(default=SACIO_DEFAULTS.ievtyp, validator=validate_sacenum)
    iqual: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    isynth: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    imagtyp: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    imagsrc: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    ibody: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    leven: bool = field(default=SACIO_DEFAULTS.leven, validator=[type_validator()])
    lpspol: bool | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    lovrok: bool | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    kstnm: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kevnm: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(16)]),
    )
    khole: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    ko: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    ka: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt0: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt1: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt2: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt3: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt4: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt5: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt6: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt7: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt8: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt9: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kf: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kuser0: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kuser1: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kuser2: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kcmpnm: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    knetwk: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kdatrd: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kinst: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    data: npt.NDArray = field(factory=lambda: np.array([]), validator=type_validator())
    x: npt.NDArray = field(factory=lambda: np.array([]), validator=type_validator())
    y: npt.NDArray = field(factory=lambda: np.array([]), validator=type_validator())

    @property
    def depmin(self) -> float | None:
        if self.npts == 0:
            return None
        return np.min(self.data).item()

    @property
    def depmax(self) -> float | None:
        if self.npts == 0:
            return None
        return np.max(self.data).item()

    @property
    def depmen(self) -> float | None:
        if self.npts == 0:
            return None
        return np.mean(self.data).item()

    @property
    def e(self) -> float:
        if self.npts == 0:
            return self.b
        return self.b + (self.npts - 1) * self.delta

    @property
    def dist(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return (
                azdist(lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo)[
                    2
                ]
                / 1000
            )
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def az(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return azdist(
                lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo
            )[0]
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def baz(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return azdist(
                lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo
            )[1]
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def gcarc(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            lat1, lon1 = np.deg2rad(self.stla), np.deg2rad(self.stlo)
            lat2, lon2 = np.deg2rad(self.evla), np.deg2rad(self.evlo)
            return np.rad2deg(
                np.arccos(
                    np.sin(lat1) * np.sin(lat2)
                    + np.cos(lat1) * np.cos(lat2) * np.cos(np.abs(lon1 - lon2))
                )
            )
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def xminimum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return np.min(self.x).item()

    @property
    def xmaximum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return np.max(self.x).item()

    @property
    def yminimum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.min(self.y).item()

    @property
    def ymaximum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.max(self.y).item()

    @property
    def npts(self) -> int:
        return np.size(self.data)

    @property
    def nxsize(self) -> float | None:
        if np.size(self.x) == 0:
            return None
        return np.size(self.x)

    @property
    def nysize(self) -> float | None:
        if np.size(self.y) == 0:
            return None
        return np.size(self.y)

    @property
    def lcalda(self) -> bool:
        # all distances and bearings are always calculated...
        return True

    @property
    def kzdate(self) -> str | None:
        """
        Returns:
            ISO 8601 format of GMT reference date.
        """
        if self.nzyear is None or self.nzjday is None:
            return None
        _kzdate = datetime.date(self.nzyear, 1, 1) + datetime.timedelta(self.nzjday - 1)
        return _kzdate.isoformat()

    @property
    def kztime(self) -> str | None:
        """
        Returns:
            Alphanumeric form of GMT reference time.
        """
        if (
            self.nzhour is None
            or self.nzmin is None
            or self.nzsec is None
            or self.nzmsec is None
        ):
            return None
        _kztime = datetime.time(self.nzhour, self.nzmin, self.nzsec, self.nzmsec * 1000)
        return _kztime.isoformat(timespec="milliseconds")

    def read(self, filename: str) -> None:
        """Read data and headers from a SAC file into an existing SAC instance.

        Parameters:
            filename: Name of the sac file to read.
        """

        with open(filename, "rb") as file_handle:
            self.read_buffer(file_handle.read())

    def read_buffer(self, buffer: bytes) -> None:
        """Read data and headers from a SAC byte buffer into an existing SAC instance.

        Parameters:
            buffer: Buffer containing SAC file content.
        """

        if len(buffer) < 632:
            raise EOFError()

        # Guess the file endianness first using the unused12 header field.
        # It is located at position 276 and its value should be -12345.0.
        # Try reading with little endianness
        if struct.unpack("<f", buffer[276:280])[-1] == -12345.0:
            file_byteorder = "<"
        # otherwise assume big endianness.
        else:
            file_byteorder = ">"

        # Loop over all header fields and store them in the SAC object under their
        # respective private names.
        npts = 0
        for header, header_metadata in SAC_HEADERS.items():
            header_type = header_metadata.type
            header_required = header_metadata.required
            header_undefined = HEADER_TYPES[header_type].undefined
            start = header_metadata.start
            length = header_metadata.length
            end = start + length
            if end >= len(buffer):
                continue
            content = buffer[start:end]
            value = struct.unpack(file_byteorder + header_metadata.format, content)[0]
            if isinstance(value, bytes):
                # strip spaces and "\x00" chars
                value = value.decode().rstrip(" \x00")

            # npts is read only property in this class, but is needed for reading data
            if header == "npts":
                npts = int(value)

            # raise error if header is undefined AND required
            if value == header_undefined and header_required:
                raise RuntimeError(
                    f"Required {header=} is undefined - invalid SAC file!"
                )

            # skip if undefined (value == -12345...) and not required
            if value == header_undefined and not header_required:
                continue

            # convert enumerated header to string and format others
            if header_type == "i":
                value = SAC_ENUMS_DICT[header](value).name

            # SAC file has headers fields which are read only attributes in this
            # class. We skip them with this try/except.
            # TODO: This is a bit crude, should maybe be a bit more specific.
            try:
                setattr(self, header, value)
            except AttributeError as e:
                if "object has no setter" in str(e):
                    pass

        # Only accept IFTYPE = ITIME SAC files. Other IFTYPE use two data blocks,
        # which is something we don't support for now.
        if self.iftype.lower() != "time":
            raise NotImplementedError(
                f"Reading SAC files with IFTYPE=(I){self.iftype.upper()} is not supported."  # noqa: E501
            )

        # Read first data block
        start = 632
        length = npts * 4
        data_end = start + length
        self.data = np.array([])
        if length > 0:
            data_end = start + length
            data_format = file_byteorder + str(npts) + "f"
            if data_end > len(buffer):
                raise EOFError()
            content = buffer[start:data_end]
            data = struct.unpack(data_format, content)
            self.data = np.array(data)

        if self.nvhdr == 7:
            for footer, footer_metadata in SAC_FOOTERS.items():
                undefined = -12345.0
                length = 8
                start = footer_metadata.start + data_end
                end = start + length

                if end > len(buffer):
                    raise EOFError()
                content = buffer[start:end]

                value = struct.unpack(file_byteorder + "d", content)[0]

                # skip if undefined (value == -12345...)
                if value == undefined:
                    continue

                # SAC file has headers fields which are read only attributes in this
                # class. We skip them with this try/except.
                # TODO: This is a bit crude, should maybe be a bit more specific.
                try:
                    setattr(self, footer, value)
                except AttributeError as e:
                    if "object has no setter" in str(e):
                        pass

    @classmethod
    def from_file(cls, filename: str) -> Self:
        """Create a new SAC instance from a SAC file.

        Parameters:
            filename: Name of the SAC file to read.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read(filename)
        return newinstance

    @classmethod
    def from_buffer(cls, buffer: bytes) -> Self:
        """Create a new SAC instance from a SAC data buffer.

        Parameters:
            buffer: Buffer containing SAC file content.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read_buffer(buffer)
        return newinstance

    @classmethod
    def from_iris(
        cls,
        net: str,
        sta: str,
        cha: str,
        loc: str,
        force_single_result: bool = False,
        **kwargs: Any,
    ) -> Self | dict[str, Self] | None:
        """Create a list of SAC instances from a single IRIS
        request using the output format as "sac.zip".

        Parameters:
            force_single_result: If true, the function will return a single SAC
                                 object or None if the requests returns nothing.

        Returns:
            A new SacIO instance.
        """
        kwargs["net"] = net
        kwargs["sta"] = sta
        kwargs["cha"] = cha
        kwargs["loc"] = loc
        kwargs["output"] = "sac.zip"

        if isinstance(kwargs["start"], datetime.datetime):
            kwargs["start"] = kwargs["start"].isoformat()

        end = kwargs.get("end", None)
        if end is not None and isinstance(end, datetime.datetime):
            kwargs["end"] = end.isoformat()

        base = "https://service.iris.edu/irisws/timeseries/1/query"
        params = urllib.parse.urlencode(kwargs, doseq=False)
        url = f"{base}?{params}"
        response = requests.get(url)
        if not response:
            raise ValueError(response.content.decode("utf-8"))
        zip = zipfile.ZipFile(io.BytesIO(response.content))
        result = {}
        for name in zip.namelist():
            buffer = zip.read(name)
            sac = cls.from_buffer(buffer)
            if force_single_result:
                return sac
            result[name] = sac
        return None if force_single_result else result

    def write(self, filename: str) -> None:
        """Writes data and header values to a SAC file.

        Parameters:
            filename: Name of the sacfile to write to.
        """
        with open(filename, "wb") as file_handle:
            # loop over all valid header fields and write them to the file
            for header, header_metadata in SAC_HEADERS.items():
                header_type = header_metadata.type
                header_format = header_metadata.format
                start = header_metadata.start
                header_undefined = HEADER_TYPES[header_type].undefined

                value = None
                try:
                    if hasattr(self, header):
                        value = getattr(self, header)
                except SacHeaderUndefined:
                    value = None

                # convert enumerated header to integer if it is not None
                if header_type == "i" and value is not None:
                    value = SAC_ENUMS_DICT[header][value].value

                # set None to -12345
                if value is None:
                    value = header_undefined

                # Encode strings to bytes
                if isinstance(value, str):
                    value = value.encode()

                # write to file
                file_handle.seek(start)
                file_handle.write(struct.pack(header_format, value))

            # write data (if npts > 0)
            data_1_start = 632
            data_1_end = data_1_start + self.npts * 4
            file_handle.truncate(data_1_start)
            if self.npts > 0:
                file_handle.seek(data_1_start)
                for x in self.data:
                    file_handle.write(struct.pack("f", x))

            if self.nvhdr == 7:
                for footer, footer_metadata in SAC_FOOTERS.items():
                    undefined = -12345.0
                    start = footer_metadata.start + data_1_end
                    value = None
                    try:
                        if hasattr(self, footer):
                            value = getattr(self, footer)
                    except SacHeaderUndefined:
                        value = None

                    # set None to -12345
                    if value is None:
                        value = undefined

                    # write to file
                    file_handle.seek(start)
                    file_handle.write(struct.pack("d", value))
