"""
#####
Noise
#####

This module provides support for calculating random synthetic noise that matches the
naturally observed amplitude spectrum.

See Also:

Peterson, J., 1993. Observations and modelling of background seismic noise.
Open-file report 93-322, U. S. Geological Survey, Albuquerque, New Mexico.
"""
import numpy as np
from datetime import datetime
from dataclasses import dataclass, field
from scipy.integrate import cumtrapz  # type: ignore
from pysmo import MiniSeismogram
from pysmo.lib.defaults import SEISMOGRAM_DEFAULTS


@dataclass(frozen=True)
class NoiseModel:
    """Class to store seismic noise models."""
    psd: np.ndarray = field(default_factory=lambda: np.array([]))
    """Power spectral density of ground acceleration [dB]."""

    T: np.ndarray = field(default_factory=lambda: np.array([]))
    """Period [seconds]."""

    def __post_init__(self) -> None:
        if np.size(self.psd) != np.size(self.T):
            raise ValueError("dB and T arrays are not of same size",
                             f"({np.size(self.psd)} != {np.size(self.T)}")
        self.psd.flags.writeable = False
        self.T.flags.writeable = False


NLNM = NoiseModel(psd=np.array([-168.0, -166.7, -166.7, -169.2, -163.7, -148.6, -141.1,
                                -141.1, -149.0, -163.8, -166.2, -162.1, -177.5, -185.0,
                                -187.5, -187.5, -185.0, -185.0, -187.5, -184.4, -151.9,
                                -103.1]),
                  T=np.array([0.10, 0.17, 0.40, 0.80, 1.24, 2.40, 4.30, 5.00, 6.00,
                              10.00, 12.00, 15.60, 21.90, 31.60, 45.00, 70.00, 101.00,
                              154.00, 328.00, 600.00, 10**4, 10**5]))

NHNM = NoiseModel(psd=np.array([-91.5, -97.4, -110.5, -120.0, -98.0, -96.5, -101.0,
                                -113.5, -120.0, -138.5, -126.0, -80.1, -48.5]),
                  T=np.array([0.10, 0.22, 0.32, 0.80, 3.80, 4.60, 6.30, 7.90, 15.40,
                              20.00, 354.80, 10**4, 10**5]))


def peterson(noise_level: float) -> NoiseModel:
    """Generate a noise model by interpolating between Peterson's
    New Low Noise Model (NLNM) and New High Noice Model (NHNM).

    :param noise_level: Determines the noise level of the generated noise model.
        A noise level of 0 returns the NLNM, 1 returns the NHNM, and anything > 0 and
        < 1 returns an interpolated model that lies between the NLNM and NHNM.
    :type noise_level: float

    :returns: Noise model.
    :rtype: NoiseModel
    """
    # check for valid input
    if not 0 <= noise_level <= 1:
        raise ValueError(f"Parameter noise_level={noise_level} is not within 0-1 range.")

    # calculate noise model
    if noise_level == 0:
        return NLNM
    elif noise_level == 1:
        return NHNM
    else:
        T_common = np.unique(np.concatenate((NLNM.T, NHNM.T)))
        NLNM_interp = np.interp(T_common, NLNM.T, NLNM.psd)
        NHNM_interp = np.interp(T_common, NHNM.T, NHNM.psd)
        dB = NLNM_interp + (NHNM_interp - NLNM_interp) * noise_level
        return NoiseModel(psd=dB, T=T_common)


def generate_noise(model: NoiseModel, npts: int,
                   sampling_rate: float = SEISMOGRAM_DEFAULTS.sampling_rate,
                   begin_time: datetime = SEISMOGRAM_DEFAULTS.begin_time,
                   return_velocity: bool = False) -> MiniSeismogram:
    """Generate a random seismogram from a noise model. Realistic seismic noise is
    generated by assigning random phases to a fixed amplitude spectrum prescribed by a
    noise model.

    :param model: Noise model used to compute seismic noise.
    :type model: NoiseModel
    :param npts: Number of points of generated noise
    :type npts: int
    :param sampling_rate: Sampling rate of generated noise
    :type sampling_rate: float, optional
    :param begin_time: Seismogram begin time
    :type begin_time: datetime.datetime, optional
    :param return_velocity: Return velocity instead of acceleration.
    :type return_velocity: bool, optional

    :returns: Seismogram with random seismic noise as data.
    :rtype: MiniSeismogram

    Example usage::

        >>> from pysmo.tools.noise import generate_noise, peterson
        >>> NLNM = peterson(noise_level=0)
        >>> sampling_rate = 0.05
        >>> npts = 5000
        >>> low_noise_seismogram = generate_noise(NLMN, npts, sampling_rate)
    """
    # Sampling frequency
    Fs = 1 / sampling_rate

    # Nyquist frequency
    Fnyq = 0.5/sampling_rate

    # get next power of 2 of the nunmber of points and calculate frequencies from Fs/NPTS
    # to Fnyq (we skip a frequency of 0 for now to avoid dividing by 0)
    NPTS = int(2**np.ceil(np.log2(npts)))
    freqs = np.linspace(Fs/NPTS, Fnyq, NPTS-1)

    # interpolate psd and recreate amplitude spectrum with the first term=0 (i.e. mean=0).
    Pxx = np.interp(1/freqs, model.T, model.psd)
    spectrum = np.append(np.array([0]), np.sqrt(10**(Pxx/10) * NPTS / sampling_rate * 2))

    # phase is randomly generated
    phase = (np.random.rand(NPTS) - 0.5) * np.pi * 2

    # combine amplitude with phase and perform ifft
    NewX = spectrum * (np.cos(phase) + 1j * np.sin(phase))
    acceleration = np.fft.irfft(NewX)

    start = int((NPTS-npts)/2)
    end = start + npts
    if return_velocity:
        velocity = cumtrapz(acceleration, dx=sampling_rate)
        velocity = velocity[start:end]
        return MiniSeismogram(begin_time=begin_time, sampling_rate=sampling_rate,
                              data=velocity)
    acceleration = acceleration[start:end]
    return MiniSeismogram(begin_time=begin_time, sampling_rate=sampling_rate,
                          data=acceleration)
