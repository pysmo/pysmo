# WARNING: Do not edit this file. It is generated from a template and will be overwritten!
from __future__ import annotations
from pysmo.lib.exceptions import SacHeaderUndefined
from pysmo.lib.functions import _azdist
from pysmo.lib.defaults import SACIO_DEFAULTS

try:
    from typing import Any, Self  # py311+
except ImportError:
    from typing import Any
    from typing_extensions import Self  # py310
from attrs import define, field, validators, Attribute, converters
from attrs_strict import type_validator
from enum import Enum
import struct
import datetime
import io
import requests
import urllib.parse
import zipfile
import warnings
import numpy as np


@define(frozen=True)
class HeaderType:
    definition: str
    undefined: float | int | str | bool
    length: int
    format: str
    description: str | None = None


HEADER_TYPES = dict(
    f=HeaderType(definition="floating", undefined=-12345, length=4, format="f"),
    n=HeaderType(definition="integer", undefined=-12345, length=4, format="i"),
    i=HeaderType(definition="enumerated", undefined=-12345, length=4, format="i"),
    l=HeaderType(definition="logical", undefined=False, length=1, format="?"),
    k=HeaderType(definition="alphanumeric", undefined="-12345", length=8, format="8s"),
)


@define(frozen=True)
class Header:
    start: int
    length: int
    format: str
    type: str


SAC_HEADERS = dict(
    delta=Header(start=0, length=4, format="f", type="f"),
    depmin=Header(start=4, length=4, format="f", type="f"),
    depmax=Header(start=8, length=4, format="f", type="f"),
    scale=Header(start=12, length=4, format="f", type="f"),
    odelta=Header(start=16, length=4, format="f", type="f"),
    b=Header(start=20, length=4, format="f", type="f"),
    e=Header(start=24, length=4, format="f", type="f"),
    o=Header(start=28, length=4, format="f", type="f"),
    a=Header(start=32, length=4, format="f", type="f"),
    fmt=Header(start=36, length=4, format="f", type="f"),
    t0=Header(start=40, length=4, format="f", type="f"),
    t1=Header(start=44, length=4, format="f", type="f"),
    t2=Header(start=48, length=4, format="f", type="f"),
    t3=Header(start=52, length=4, format="f", type="f"),
    t4=Header(start=56, length=4, format="f", type="f"),
    t5=Header(start=60, length=4, format="f", type="f"),
    t6=Header(start=64, length=4, format="f", type="f"),
    t7=Header(start=68, length=4, format="f", type="f"),
    t8=Header(start=72, length=4, format="f", type="f"),
    t9=Header(start=76, length=4, format="f", type="f"),
    f=Header(start=80, length=4, format="f", type="f"),
    resp0=Header(start=84, length=4, format="f", type="f"),
    resp1=Header(start=88, length=4, format="f", type="f"),
    resp2=Header(start=92, length=4, format="f", type="f"),
    resp3=Header(start=96, length=4, format="f", type="f"),
    resp4=Header(start=100, length=4, format="f", type="f"),
    resp5=Header(start=104, length=4, format="f", type="f"),
    resp6=Header(start=108, length=4, format="f", type="f"),
    resp7=Header(start=112, length=4, format="f", type="f"),
    resp8=Header(start=116, length=4, format="f", type="f"),
    resp9=Header(start=120, length=4, format="f", type="f"),
    stla=Header(start=124, length=4, format="f", type="f"),
    stlo=Header(start=128, length=4, format="f", type="f"),
    stel=Header(start=132, length=4, format="f", type="f"),
    stdp=Header(start=136, length=4, format="f", type="f"),
    evla=Header(start=140, length=4, format="f", type="f"),
    evlo=Header(start=144, length=4, format="f", type="f"),
    evel=Header(start=148, length=4, format="f", type="f"),
    evdp=Header(start=152, length=4, format="f", type="f"),
    mag=Header(start=156, length=4, format="f", type="f"),
    user0=Header(start=160, length=4, format="f", type="f"),
    user1=Header(start=164, length=4, format="f", type="f"),
    user2=Header(start=168, length=4, format="f", type="f"),
    user3=Header(start=172, length=4, format="f", type="f"),
    user4=Header(start=176, length=4, format="f", type="f"),
    user5=Header(start=180, length=4, format="f", type="f"),
    user6=Header(start=184, length=4, format="f", type="f"),
    user7=Header(start=188, length=4, format="f", type="f"),
    user8=Header(start=192, length=4, format="f", type="f"),
    user9=Header(start=196, length=4, format="f", type="f"),
    dist=Header(start=200, length=4, format="f", type="f"),
    az=Header(start=204, length=4, format="f", type="f"),
    baz=Header(start=208, length=4, format="f", type="f"),
    gcarc=Header(start=212, length=4, format="f", type="f"),
    sb=Header(start=216, length=4, format="f", type="f"),
    sdelta=Header(start=220, length=4, format="f", type="f"),
    depmen=Header(start=224, length=4, format="f", type="f"),
    cmpaz=Header(start=228, length=4, format="f", type="f"),
    cmpinc=Header(start=232, length=4, format="f", type="f"),
    xminimum=Header(start=236, length=4, format="f", type="f"),
    xmaximum=Header(start=240, length=4, format="f", type="f"),
    yminimum=Header(start=244, length=4, format="f", type="f"),
    ymaximum=Header(start=248, length=4, format="f", type="f"),
    unused6=Header(start=254, length=4, format="f", type="f"),
    unused7=Header(start=258, length=4, format="f", type="f"),
    unused8=Header(start=262, length=4, format="f", type="f"),
    unused9=Header(start=264, length=4, format="f", type="f"),
    unused10=Header(start=268, length=4, format="f", type="f"),
    unused11=Header(start=272, length=4, format="f", type="f"),
    unused12=Header(start=276, length=4, format="f", type="f"),
    nzyear=Header(start=280, length=4, format="i", type="n"),
    nzjday=Header(start=284, length=4, format="i", type="n"),
    nzhour=Header(start=288, length=4, format="i", type="n"),
    nzmin=Header(start=292, length=4, format="i", type="n"),
    nzsec=Header(start=296, length=4, format="i", type="n"),
    nzmsec=Header(start=300, length=4, format="i", type="n"),
    nvhdr=Header(start=304, length=4, format="i", type="n"),
    norid=Header(start=308, length=4, format="i", type="n"),
    nevid=Header(start=312, length=4, format="i", type="n"),
    npts=Header(start=316, length=4, format="i", type="n"),
    nsnpts=Header(start=320, length=4, format="i", type="n"),
    nwfid=Header(start=324, length=4, format="i", type="n"),
    nxsize=Header(start=328, length=4, format="i", type="n"),
    nysize=Header(start=332, length=4, format="i", type="n"),
    unused15=Header(start=336, length=4, format="i", type="n"),
    iftype=Header(start=340, length=4, format="i", type="i"),
    idep=Header(start=344, length=4, format="i", type="i"),
    iztype=Header(start=348, length=4, format="i", type="i"),
    unused16=Header(start=352, length=4, format="i", type="i"),
    iinst=Header(start=356, length=4, format="i", type="i"),
    istreg=Header(start=360, length=4, format="i", type="i"),
    ievreg=Header(start=364, length=4, format="i", type="i"),
    ievtyp=Header(start=368, length=4, format="i", type="i"),
    iqual=Header(start=372, length=4, format="i", type="i"),
    isynth=Header(start=376, length=4, format="i", type="i"),
    imagtyp=Header(start=380, length=4, format="i", type="i"),
    imagsrc=Header(start=384, length=4, format="i", type="i"),
    unused19=Header(start=388, length=4, format="i", type="i"),
    unused20=Header(start=392, length=4, format="i", type="i"),
    unused21=Header(start=396, length=4, format="i", type="i"),
    unused22=Header(start=400, length=4, format="i", type="i"),
    unused23=Header(start=404, length=4, format="i", type="i"),
    unused24=Header(start=408, length=4, format="i", type="i"),
    unused25=Header(start=412, length=4, format="i", type="i"),
    unused26=Header(start=416, length=4, format="i", type="i"),
    leven=Header(start=420, length=1, format="?", type="l"),
    lpspol=Header(start=424, length=1, format="?", type="l"),
    lovrok=Header(start=428, length=1, format="?", type="l"),
    lcalda=Header(start=432, length=1, format="?", type="l"),
    unused27=Header(start=436, length=1, format="?", type="l"),
    kstnm=Header(start=440, length=8, format="8s", type="k"),
    kevnm=Header(start=448, length=16, format="16s", type="k"),
    khole=Header(start=464, length=8, format="8s", type="k"),
    ko=Header(start=472, length=8, format="8s", type="k"),
    ka=Header(start=480, length=8, format="8s", type="k"),
    kt0=Header(start=488, length=8, format="8s", type="k"),
    kt1=Header(start=496, length=8, format="8s", type="k"),
    kt2=Header(start=504, length=8, format="8s", type="k"),
    kt3=Header(start=512, length=8, format="8s", type="k"),
    kt4=Header(start=520, length=8, format="8s", type="k"),
    kt5=Header(start=528, length=8, format="8s", type="k"),
    kt6=Header(start=536, length=8, format="8s", type="k"),
    kt7=Header(start=544, length=8, format="8s", type="k"),
    kt8=Header(start=552, length=8, format="8s", type="k"),
    kt9=Header(start=560, length=8, format="8s", type="k"),
    kf=Header(start=568, length=8, format="8s", type="k"),
    kuser0=Header(start=576, length=8, format="8s", type="k"),
    kuser1=Header(start=584, length=8, format="8s", type="k"),
    kuser2=Header(start=592, length=8, format="8s", type="k"),
    kcmpnm=Header(start=600, length=8, format="8s", type="k"),
    knetwk=Header(start=608, length=8, format="8s", type="k"),
    kdatrd=Header(start=616, length=8, format="8s", type="k"),
    kinst=Header(start=624, length=8, format="8s", type="k"),
)


class SacEnum(Enum):
    time = 1
    rlim = 2
    amph = 3
    xy = 4
    unkn = 5
    disp = 6
    vel = 7
    acc = 8
    b = 9
    day = 10
    o = 11
    a = 12
    t0 = 13
    t1 = 14
    t2 = 15
    t3 = 16
    t4 = 17
    t5 = 18
    t6 = 19
    t7 = 20
    t8 = 21
    t9 = 22
    radnv = 23
    tannv = 24
    radev = 25
    tanev = 26
    north = 27
    east = 28
    horza = 29
    down = 30
    up = 31
    lllbb = 32
    wwsn1 = 33
    wwsn2 = 34
    hglp = 35
    sro = 36
    nucl = 37
    pren = 38
    postn = 39
    quake = 40
    preq = 41
    postq = 42
    chem = 43
    other = 44
    good = 45
    glch = 46
    drop = 47
    lowsn = 48
    rldta = 49
    volts = 50
    mb = 52
    ms = 53
    ml = 54
    mw = 55
    md = 56
    mx = 57
    neic = 58
    pdeq = 59
    pdew = 60
    pde = 61
    isc = 62
    reb = 63
    usgs = 64
    brk = 65
    caltech = 66
    llnl = 67
    evloc = 68
    jsop = 69
    user = 70
    unknown = 71
    qb = 72
    qb1 = 73
    qb2 = 74
    qbx = 75
    qmt = 76
    eq = 77
    eq1 = 78
    eq2 = 79
    me = 80
    ex = 81
    nu = 82
    nc = 83
    o_ = 84
    l = 85  # NOQA: E741
    r = 86
    t = 87
    u = 88
    eq3 = 89
    eq0 = 90
    ex0 = 91
    qc = 92
    qb0 = 93
    gey = 94
    lit = 95
    met = 96
    odor = 97
    os = 103


ENUM_DICT = dict(
    iftype=[
        "time",
        "rlim",
        "amph",
        "xy",
    ],
    idep=[
        "unkn",
        "disp",
        "vel",
        "volts",
        "acc",
    ],
    iztype=[
        "unkn",
        "b",
        "day",
        "o",
        "a",
        "t0",
        "t1",
        "t2",
        "t3",
        "t4",
        "t5",
        "t6",
        "t7",
        "t8",
        "t9",
    ],
    ievtyp=[
        "unkn",
        "nucl",
        "pren",
        "postn",
        "quake",
        "preq",
        "postq",
        "chem",
        "qb",
        "qb1",
        "qb2",
        "qbx",
        "qmt",
        "eq",
        "eq1",
        "eq2",
        "me",
        "ex",
        "nu",
        "nc",
        "o",
        "l",
        "r",
        "t",
        "u",
        "other",
    ],
    iqual=[
        "good",
        "glch",
        "drop",
        "lowsn",
        "other",
    ],
    isynth=[
        "rldta",
    ],
    imagtyp=[
        "mb",
        "ms",
        "ml",
        "mw",
        "md",
        "mx",
    ],
    imagsrc=[
        "neic",
        "pde",
        "isc",
        "reb",
        "usgs",
        "brk",
        "caltech",
        "llnl",
        "evloc",
        "jsop",
        "user",
        "unknown",
    ],
)


def validate_sacenum(instance: SacIO, attribute: Attribute, value: Any) -> None:
    if not hasattr(SacEnum, value):
        raise ValueError(f"{value=} is not a known sac enum.")
    valid_values_list = ENUM_DICT[attribute.name]
    if value not in valid_values_list:
        raise ValueError(
            f"{value=} is not valid for {attribute=}."
            + f"valid attributes are {valid_values_list}"
        )


@define(kw_only=True)
class SacIO:
    """
    The `SacIO` class reads and writes data and header values to and from a
    SAC file. Instances of `SacIO` provide attributes named identially to
    header names in the SAC file format. Additonal attributes may be set, but are
    not written to a SAC file (because there is no space reserved for them there).
    Class attributes with corresponding header fields in a SAC file (for example the
    begin time `b`) are checked for a valid format before being saved in the
    `SacIO` instance.

    Warning:
        This class should typically never be used directly. Instead please
        use the [SAC][pysmo.classes.sac.SAC] class, which inherits all
        attributes and methods from here.

    Examples:
        Create a new instance from a file and print seismogram data:

        >>> from pysmo.lib.io import SacIO
        >>> my_sac = SacIO.from_file('testfile.sac')
        >>> data = my_sac.data
        >>> data
        array([-1616.0, -1609.0, -1568.0, -1606.0, -1615.0, -1565.0, ...

        Read the sampling rate:

        >>> delta = my_sac.delta
        >>> delta
        0.019999999552965164

        Change the sampling rate:

        >>> newdelta = 0.05
        >>> my_sac.delta = newdelta
        >>> my_sac.delta
        0.05

        Create a new instance from IRIS services:

        >>> from pysmo.lib.io import SacIO
        >>> my_sac = SacIO.from_iris(
        >>>             net="C1",
        >>>             sta="VA01",
        >>>             cha="BHZ",
        >>>             loc="--",
        >>>             start="2021-03-22T13:00:00",
        >>>             duration=1 * 60 * 60,
        >>>             scale="AUTO",
        >>>             demean="true",
        >>>             force_single_result=True)
        >>> my_sac.npts
        144001

    For each SAC(file) header field there is a corresponding attribute in this class.
    There are a lot of header fields in a SAC file, which are all called the
    same way when using `SAC`.

    Attributes:
        delta:
            Increment between evenly spaced samples (nominal value).
        depmin:
            Minimum value of dependent variable.
        depmax:
            Maximum value of dependent variable.
        scale:
            Multiplying scale factor for dependent variable (not currently used).
        odelta:
            Observed increment if different from nominal value.
        b:
            Beginning value of the independent variable.
        e:
            Ending value of the independent variable.
        o:
            Event origin time (seconds relative to reference time).
        a:
            First arrival time (seconds relative to reference time).
        fmt:
            Internal.
        t0:
            User defined time pick or marker 0 (seconds relative to reference
            time).
        t1:
            User defined time pick or marker 1 (seconds relative to reference
            time).
        t2:
            User defined time pick or marker 2 (seconds relative to reference
            time).
        t3:
            User defined time pick or marker 3 (seconds relative to reference
            time).
        t4:
            User defined time pick or marker 4 (seconds relative to reference
            time).
        t5:
            User defined time pick or marker 5 (seconds relative to reference
            time).
        t6:
            User defined time pick or marker 6 (seconds relative to reference
            time).
        t7:
            User defined time pick or marker 7 (seconds relative to reference
            time).
        t8:
            User defined time pick or marker 8 (seconds relative to reference
            time).
        t9:
            User defined time pick or marker 9 (seconds relative to reference
            time).
        f:
            Fini or end of event time (seconds relative to reference time).
        resp0:
            Instrument response parameter 0 (not currently used).
        resp1:
            Instrument response parameter 1 (not currently used).
        resp2:
            Instrument response parameter 2 (not currently used).
        resp3:
            Instrument response parameter 3 (not currently used).
        resp4:
            Instrument response parameter 4 (not currently used).
        resp5:
            Instrument response parameter 5 (not currently used).
        resp6:
            Instrument response parameter 6 (not currently used).
        resp7:
            Instrument response parameter 7 (not currently used).
        resp8:
            Instrument response parameter 8 (not currently used).
        resp9:
            Instrument response parameter 9 (not currently used).
        stla:
            Station latitude (degrees, north positive).
        stlo:
            Station longitude (degrees, east positive).
        stel:
            Station elevation above sea level (meters).
        stdp:
            Station depth below surface (meters).
        evla:
            Event latitude (degrees, north positive).
        evlo:
            Event longitude (degrees, east positive).
        evel:
            Event elevation (meters).
        evdp:
            Event depth below surface (kilometers -- previously meters).
        mag:
            Event magnitude.
        user0:
            User defined variable storage area.
        user1:
            User defined variable storage area.
        user2:
            User defined variable storage area.
        user3:
            User defined variable storage area.
        user4:
            User defined variable storage area.
        user5:
            User defined variable storage area.
        user6:
            User defined variable storage area.
        user7:
            User defined variable storage area.
        user8:
            User defined variable storage area.
        user9:
            User defined variable storage area.
        dist:
            Station to event distance (km).
        az:
            Event to station azimuth (degrees).
        baz:
            Station to event azimuth (degrees).
        gcarc:
            Station to event great circle arc length (degrees).
        sb:
            Internal.
        sdelta:
            Internal.
        depmen:
            Mean value of dependent variable.
        cmpaz:
            Component azimuth (degrees clockwise from north).
        cmpinc:
            Component incident angle (degrees from vertical).
        xminimum:
            Minimum value of X (Spectral files only).
        xmaximum:
            Maximum value of X (Spectral files only).
        yminimum:
            Minimum value of Y (Spectral files only).
        ymaximum:
            Maximum value of Y (Spectral files only).
        unused6:
            Unused.
        unused7:
            Unused.
        unused8:
            Unused.
        unused9:
            Unused.
        unused10:
            Unused.
        unused11:
            Unused.
        unused12:
            Unused.
        nzyear:
            GMT year corresponding to reference (zero) time in file.
        nzjday:
            GMT julian day.
        nzhour:
            GMT hour.
        nzmin:
            GMT minute.
        nzsec:
            GMT second.
        nzmsec:
            GMT millisecond.
        nvhdr:
            Header version number.
        norid:
            Origin ID (CSS 3.0).
        nevid:
            Event ID (CSS 3.0).
        npts:
            Number of points per data component.
        nsnpts:
            Internal.
        nwfid:
            Waveform ID (CSS 3.0).
        nxsize:
            Spectral Length (Spectral files only).
        nysize:
            Spectral Length (Spectral files only).
        unused15:
            Unused.
        iftype:
            Type of file.
        idep:
            Type of dependent variable.
        iztype:
            Reference time equivalence.
        unused16:
            Unused.
        iinst:
            Type of recording instrument.
        istreg:
            Station geographic region.
        ievreg:
            Event geographic region.
        ievtyp:
            Type of event.
        iqual:
            Quality of data.
        isynth:
            Synthetic data flag.
        imagtyp:
            Magnitude type.
        imagsrc:
            Source of magnitude information.
        unused19:
            Unused.
        unused20:
            Unused.
        unused21:
            Unused.
        unused22:
            Unused.
        unused23:
            Unused.
        unused24:
            Unused.
        unused25:
            Unused.
        unused26:
            Unused.
        leven:
            TRUE if data is evenly spaced.
        lpspol:
            TRUE if station components have a positive polarity (left-hand rule).
        lovrok:
            TRUE if it is okay to overwrite this file on disk.
        lcalda:
            TRUE if DIST, AZ, BAZ, and GCARC are to be calculated from station and
            event coordinates.
        unused27:
            Unused.
        kstnm:
            Station name.
        kevnm:
            Event name.
        khole:
            Nuclear: hole identifier; Other: location identifier.
        ko:
            Event origin time identification.
        ka:
            First arrival time identification.
        kt0:
            User defined time pick identification.
        kt1:
            User defined time pick identification.
        kt2:
            User defined time pick identification.
        kt3:
            User defined time pick identification.
        kt4:
            User defined time pick identification.
        kt5:
            User defined time pick identification.
        kt6:
            User defined time pick identification.
        kt7:
            User defined time pick identification.
        kt8:
            User defined time pick identification.
        kt9:
            User defined time pick identification.
        kf:
            Fini identification.
        kuser0:
            User defined variable storage area.
        kuser1:
            User defined variable storage area.
        kuser2:
            User defined variable storage area.
        kcmpnm:
            Channel name. SEED volumes use three character names, and the third is
            the component/orientation. For horizontals, the current trend is to
            use 1 and 2 instead of N and E.
        knetwk:
            Name of seismic network.
        kdatrd:
            Date data was read onto computer.
        kinst:
            Generic name of recording instrument.
    """

    delta: float = field(
        default=SACIO_DEFAULTS.delta, converter=float, validator=[type_validator()]
    )
    scale: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    odelta: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    b: float = field(
        default=SACIO_DEFAULTS.b, converter=float, validator=[type_validator()]
    )
    o: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    a: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    fmt: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t0: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t1: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t2: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t3: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t4: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t5: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    t9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    f: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp0: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp1: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp2: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp3: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp4: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp5: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    resp9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    stla: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.ge(-90), validators.le(90)]
        ),
    )
    stlo: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.gt(-180), validators.le(180)]
        ),
    )
    stel: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    stdp: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    evla: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.ge(-90), validators.le(90)]
        ),
    )
    evlo: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional(
            [type_validator(), validators.gt(-180), validators.le(180)]
        ),
    )
    evel: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    evdp: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    mag: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user0: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user1: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user2: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user3: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user4: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user5: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    user9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    sb: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    sdelta: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    cmpaz: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    cmpinc: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused6: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused7: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused8: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused9: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused10: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused11: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    unused12: float | None = field(
        default=None,
        converter=converters.optional(float),
        validator=validators.optional([type_validator()]),
    )
    nzyear: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzjday: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzhour: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzmin: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzsec: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nzmsec: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nvhdr: int = field(default=SACIO_DEFAULTS.nvhdr, validator=[type_validator()])
    norid: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nevid: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nsnpts: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    nwfid: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    unused15: int | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    iftype: str = field(default=SACIO_DEFAULTS.iftype, validator=validate_sacenum)
    idep: str = field(default=SACIO_DEFAULTS.idep, validator=validate_sacenum)
    iztype: str = field(default=SACIO_DEFAULTS.iztype, validator=validate_sacenum)
    unused16: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    iinst: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    istreg: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    ievreg: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    ievtyp: str = field(default=SACIO_DEFAULTS.ievtyp, validator=validate_sacenum)
    iqual: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    isynth: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    imagtyp: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    imagsrc: str | None = field(
        default=None, validator=validators.optional(validate_sacenum)
    )
    unused19: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused20: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused21: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused22: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused23: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused24: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused25: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    unused26: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(4)]),
    )
    leven: bool = field(default=SACIO_DEFAULTS.leven, validator=[type_validator()])
    lpspol: bool | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    lovrok: bool | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    unused27: bool | None = field(
        default=None, validator=validators.optional([type_validator()])
    )
    kstnm: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kevnm: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(16)]),
    )
    khole: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    ko: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    ka: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt0: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt1: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt2: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt3: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt4: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt5: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt6: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt7: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt8: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kt9: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kf: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kuser0: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kuser1: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kuser2: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kcmpnm: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    knetwk: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kdatrd: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    kinst: str | None = field(
        default=None,
        validator=validators.optional([type_validator(), validators.max_len(8)]),
    )
    data: np.ndarray = field(factory=lambda: np.array([]))
    x: np.ndarray = field(factory=lambda: np.array([]))
    y: np.ndarray = field(factory=lambda: np.array([]))

    @property
    def depmin(self) -> float | None:
        if self.npts == 0:
            return None
        return np.min(self.data)

    @property
    def depmax(self) -> float | None:
        if self.npts == 0:
            return None
        return np.max(self.data)

    @property
    def depmen(self) -> float | None:
        if self.npts == 0:
            return None
        return np.mean(self.data)

    @property
    def e(self) -> float:
        if self.npts == 0:
            return self.b
        return self.b + (self.npts - 1) * self.delta

    @property
    def dist(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return (
                _azdist(lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo)[
                    2
                ]
                / 1000
            )
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def az(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return _azdist(
                lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo
            )[0]
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def baz(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            return _azdist(
                lat1=self.stla, lon1=self.stlo, lat2=self.evla, lon2=self.evlo
            )[1]
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def gcarc(self) -> float:
        if self.stla and self.stlo and self.evla and self.evlo:
            lat1, lon1 = np.deg2rad(self.stla), np.deg2rad(self.stlo)
            lat2, lon2 = np.deg2rad(self.evla), np.deg2rad(self.evlo)
            return np.rad2deg(
                np.arccos(
                    np.sin(lat1) * np.sin(lat2)
                    + np.cos(lat1) * np.cos(lat2) * np.cos(np.abs(lon1 - lon2))
                )
            )
        raise SacHeaderUndefined("One or more coordinates are None.")

    @property
    def xminimum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return float(np.min(self.x))

    @property
    def xmaximum(self) -> float | None:
        if self.nxsize == 0 or not self.nxsize:
            return None
        return np.max(self.x)

    @property
    def yminimum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.min(self.y)

    @property
    def ymaximum(self) -> float | None:
        if self.nysize == 0 or not self.nysize:
            return None
        return np.max(self.y)

    @property
    def npts(self) -> int:
        return np.size(self.data)

    @property
    def nxsize(self) -> float | None:
        if np.size(self.x) == 0:
            return None
        return np.size(self.x)

    @property
    def nysize(self) -> float | None:
        if np.size(self.y) == 0:
            return None
        return np.size(self.y)

    @property
    def lcalda(self) -> bool:
        # all distances and bearings are always calculated...
        return True

    @property
    def kzdate(self) -> str | None:
        """
        Returns:
            ISO 8601 format of GMT reference date.
        """
        if self.nzyear is None or self.nzjday is None:
            return None
        _kzdate = datetime.date(self.nzyear, 1, 1) + datetime.timedelta(self.nzjday - 1)
        return _kzdate.isoformat()

    @property
    def kztime(self) -> str | None:
        """
        Returns:
            Alphanumeric form of GMT reference time.
        """
        if (
            self.nzhour is None
            or self.nzmin is None
            or self.nzsec is None
            or self.nzmsec is None
        ):
            return None
        _kztime = datetime.time(self.nzhour, self.nzmin, self.nzsec, self.nzmsec * 1000)
        return _kztime.isoformat(timespec="milliseconds")

    def read(self, filename: str) -> None:
        """Read data and header values from a SAC file into an existing SAC instance.

        Parameters:
            filename: Name of the sac file to read.
        """

        with open(filename, "rb") as file_handle:
            self.read_buffer(file_handle.read())

    def read_buffer(self, buffer: bytes) -> None:
        """Read data and header values from a SAC byte buffer into an existing SAC instance.

        Parameters:
            buffer: Buffer containing SAC file content.
        """

        if len(buffer) < 632:
            raise EOFError()

        # Guess the file endianness first using the unused12 header field.
        # It is located at position 276 and its value should be -12345.0.
        # Try reading with little endianness
        if struct.unpack("<f", buffer[276:280])[-1] == -12345.0:
            file_byteorder = "<"
        # otherwise assume big endianness.
        else:
            file_byteorder = ">"

        # Loop over all header fields and store them in the SAC object under their
        # respective private names.
        npts = 0
        for header, metadata in SAC_HEADERS.items():
            header_type = metadata.type
            header_undefined = HEADER_TYPES[header_type].undefined
            start = metadata.start
            length = metadata.length
            end = start + length
            if end >= len(buffer):
                continue
            content = buffer[start:end]
            value = struct.unpack(file_byteorder + metadata.format, content)[0]
            if isinstance(value, bytes):
                # strip spaces and "\x00" chars
                value = value.decode().rstrip(" \x00")

            # npts is read only property in this class, but is needed for reading data
            if header == "npts":
                npts = int(value)

            # skip if undefined (value == -12345...)
            if value == header_undefined:
                continue

            # convert enumerated header to string and format others
            if header_type == "i":
                value = SacEnum(value).name

            # SAC file has headers fields which are read only attributes in this
            # class. We skip them with this try/except.
            # TODO: This is a bit crude, should maybe be a bit more specific.
            try:
                setattr(self, header, value)
            except AttributeError as e:
                if "object has no setter" in str(e):
                    pass

        # Only accept IFTYPE = ITIME SAC files. Other IFTYPE use two data blocks, which is something
        # we don't support.
        if self.iftype.lower() != "time":
            raise NotImplementedError(
                f"Reading SAC files with IFTYPE=(I){self.iftype.upper()} is not supported."
            )

        # Read first data block
        start = 632
        length = npts * 4
        self.data = np.array([])
        if length > 0:
            end = start + length
            data_format = file_byteorder + str(npts) + "f"
            if end > len(buffer):
                raise EOFError()
            content = buffer[start:end]
            data = struct.unpack(data_format, content)
            self.data = np.array(data)

        # TODO: implement reading and writing footer with double precision values.
        # Warn users for now that footer is not read in case of SAC header version 7.
        if self.nvhdr == 7:
            warnings.warn(
                f"SAC header version {self.nvhdr} not implemented. Reverting to version 6"
            )
            self.nvhdr = 6

    @classmethod
    def from_file(cls, filename: str) -> Self:
        """Create a new SAC instance from a SAC file.

        Parameters:
            filename: Name of the SAC file to read.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read(filename)
        return newinstance

    @classmethod
    def from_buffer(cls, buffer: bytes) -> Self:
        """Create a new SAC instance from a SAC data buffer.

        Parameters:
            buffer: Buffer containing SAC file content.

        Returns:
            A new SacIO instance.
        """
        newinstance = cls()
        newinstance.read_buffer(buffer)
        return newinstance

    @classmethod
    def from_iris(
        cls,
        net: str,
        sta: str,
        cha: str,
        loc: str,
        force_single_result: bool = False,
        **kwargs: Any,
    ) -> Self | dict[str, Self] | None:
        """Create a list of SAC instances from a single IRIS
        request using the output format as "sac.zip".

        Parameters:
            force_single_result: If true, the function will return a single SAC
                                 object or None if the requests returns nothing.

        Returns:
            A new SacIO instance.
        """
        kwargs["net"] = net
        kwargs["sta"] = sta
        kwargs["cha"] = cha
        kwargs["loc"] = loc
        kwargs["output"] = "sac.zip"

        if isinstance(kwargs["start"], datetime.datetime):
            kwargs["start"] = kwargs["start"].isoformat()

        end = kwargs.get("end", None)
        if end is not None and isinstance(end, datetime.datetime):
            kwargs["end"] = end.isoformat()

        base = "https://service.iris.edu/irisws/timeseries/1/query"
        params = urllib.parse.urlencode(kwargs, doseq=False)
        url = f"{base}?{params}"
        response = requests.get(url)
        if not response:
            raise ValueError(response.content.decode("utf-8"))
        zip = zipfile.ZipFile(io.BytesIO(response.content))
        result = {}
        for name in zip.namelist():
            buffer = zip.read(name)
            sac = cls.from_buffer(buffer)
            if force_single_result:
                return sac
            result[name] = sac
        return None if force_single_result else result

    def write(self, filename: str) -> None:
        """Writes data and header values to a SAC file.

        Parameters:
            filename: Name of the sacfile to write to.
        """
        with open(filename, "wb") as file_handle:
            # loop over all valid header fields and write them to the file
            for header, metadata in SAC_HEADERS.items():
                header_type = metadata.type
                header_format = metadata.format
                start = metadata.start
                header_undefined = HEADER_TYPES[header_type].undefined

                value = None
                try:
                    value = getattr(self, header)
                except SacHeaderUndefined:
                    value = None

                # convert enumerated header to integer if it is not None
                if header_type == "i" and value:
                    value = SacEnum[value].value

                # set None to -12345
                if not value:
                    value = header_undefined

                # Encode strings to bytes
                if isinstance(value, str):
                    value = value.encode()

                # write to file
                file_handle.seek(start)
                file_handle.write(struct.pack(header_format, value))

            # write data (if npts > 0)
            start1 = 632
            file_handle.truncate(start1)
            if self.npts > 0:
                file_handle.seek(start1)
                for x in self.data:
                    file_handle.write(struct.pack("f", x))
